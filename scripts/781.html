
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="foobar">
    <title>TabExpansion - PoshCode</title>

    <link rel="stylesheet" href="/css/superhero.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/highlight/arta.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" id="tabs">
                    <li class="nav-item"><a class="nav-link" href="/">Join Us!</a></li>
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video">Videos</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

	<div class="container">
		<div class="blog-header">
			<h1 class="blog-title">PoshCode</h1>
			<p class="lead blog-description">Community resources for PowerShell coders</p>
		</div>
		<div class="row">
            

<div class="blog-post">
    <h2 class="blog-post-title">TabExpansion</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2009-01-04</span> by <a class="blog-post-author">foobar</a>
    </p>

    <h3>Download <a href="/scripts/781.ps1">TabExpansion.ps1</a> - <a href="/scripts/769.html">parent</a></h3>
<p>Ported TabExpansion from V2CTP2 to v1.0 and extended.
Update:</p>
<p>Parameter expansion for function, filter and scripts
man -f<tab>
'param([System.StringSplitOptions]$foo,[System.Management.Automation.ActionPreference]$bar,[System.Management.Automation.CommandTypes]$baz) {}' &gt; foobar.ps1
.\foobar.ps1 -<tab> -b<tab></p>
<p>Enum expansion for function, filter and scripts parameter (this doesn't work latest V2 CTP)
.\foobar.ps1 -foo rem<tab> -bar <tab><comma>c<tab><comma>sc<tab> -ea silent<tab> -wa con<tab></p>
<p>Enum expansion for assignment expression
$ErrorActionPreference =<space><tab>
$cmdtypes = New-Object System.Management.Automation.CommandTypes[] 3
$cmdtypes =<space><tab><comma><space>func<tab><comma><space>cmd<tab> -as<space><tab></p>
<p>Better '$<em>.' expansion for Get-Item and Get-Command and a expression of only a variable
$data = Get-Process; $data[2,4,5]  | % { $</em>.<tab>
gi hkcu:\ | % { $<em>.subkey<tab>
gcm powershell.exe | % { $</em>.file<tab>
*this requires latest Get-PipeLineObject.ps1 in a same directory</p>
<pre><code class="language-powershell">## Tab-Completion
#################
## Please dot souce this script file.
## In first loading, it may take a several minutes, in order to generate ProgIDs and TypeNames list.
## What this can do is:
##
## [datetime]::n&lt;tab&gt;
## [datetime]::now.d&lt;tab&gt;
## $a = New-Object &quot;Int32[,]&quot; 2,3; $b = &quot;PowerShell&quot;,&quot;PowerShell&quot;
## $c = [ref]$a; $d = [ref]$b,$c
## $d[0].V&lt;tab&gt;[0][0].Get&lt;tab&gt;
## $d[1].V&lt;tab&gt;[0,0].tos&lt;tab&gt;
## $function:a&lt;tab&gt;
## $env:a&lt;tab&gt;
## [System.Type].a&lt;tab&gt;
## [datetime].Assembly.a&lt;tab&gt;
## ).a&lt;tab&gt; # shows System.Type properties and methods...

## #native command name expansion
## fsu&lt;tab&gt;

## #command option name expansion (for fsutil ipconfig net powershell only)
## fsutil &lt;tab&gt;
## ipconfig &lt;tab&gt;
## net &lt;tab&gt;
## powershell &lt;tab&gt;

## #TypeNames expansion
## [Dec&lt;tab&gt;
## [Microsoft.PowerShell.Com&lt;tab&gt;
## New-Object -TypeName IO.Dir&lt;tab&gt;
## New-Object System.Management.Auto&lt;tab&gt;

## #ProgIDs expansion
## New-Object -Com shel&lt;tab&gt;

## #Enum option expansion
## Set-ExecutionPolicy &lt;tab&gt;
## Set-ExecutionPolicy All&lt;tab&gt;
## Set-ExcusionPolisy -ex &lt;tab&gt;
## Get-TraceSource¬Å@Inte&lt;tab&gt;
## iex -Err &lt;tab&gt; -wa Sil&lt;tab&gt;

## #WmiClasses expansion
## Get-WmiObject -class Win32_&lt;tab&gt;
## gwmi __Instance&lt;tab&gt;

## #Encoding expansion
## [Out-File | Export-CSV | Select-String | Export-Clixml] -enc &lt;tab&gt;
## [Add-Content | Get-Content | Set-Content} -Encoding Big&lt;tab&gt;

## #PSProvider name expansion
## [Get-Location | Get-PSDrive | Get-PSProvider | New-PSDrive | Remove-PSDrive] [-PSProvider] &lt;tab&gt;
## Get-PSProvider &lt;tab&gt;
## pwd -psp al&lt;tab&gt;

## #PSDrive name expansion
## [Get-PSDrive | New-PSDrive | Remove-PSDrive] [-Name] &lt;tab&gt;
## Get-PSDrive &lt;tab&gt;
## pwd -psd &lt;tab&gt;

## #PSSnapin name expansion
## [Add-PSSnapin | Get-PSSnapin | Remove-PSSnapin ] [-Name] &lt;tab&gt;
## Get-Command -PSSnapin &lt;tab&gt;
## Remove-PSSnapin &lt;tab&gt;
## Get-PSSnapin M&lt;tab&gt;

## #Eventlog name and expansion
## Get-Eventlog -Log &lt;tab&gt;
## Get-Eventlog w&lt;tab&gt;

## #Eventlog's entrytype expansion
## Get-EventLog -EntryType &lt;tab&gt;
## Get-EventLog -EntryType Er&lt;tab&gt;
## Get-EventLog -Ent &lt;tab&gt;

## #Service name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-Name] &lt;tab&gt;
## New-Service -DependsOn &lt;tab&gt;
## New-Service -Dep e&lt;tab&gt;
## Get-Service -n &lt;tab&gt;
## Get-Service &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;
## gsv &lt;tab&gt;

## #Service display name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-DisplayName] &lt;tab&gt;
## Get-Service -Dis &lt;tab&gt;
## gsv -Dis &lt;tab&gt;,w&lt;tab&gt;,b&lt;tab&gt;

## #Cmdlet and Topic name expansion
## Get-Help [-Name] about_&lt;tab&gt;
## Get-Help &lt;tab&gt;

## #Category name expansion
## Get-Help -Category c&lt;tab&gt;,&lt;tab&gt;

## #Command name expansion
## Get-Command [-Name] &lt;tab&gt;
## Get-Command -Name &lt;tab&gt;
## gcm a&lt;tab&gt;,&lt;tab&gt;

## #Scope expansion
## [Clear-Variable | Export-Alias | Get-Alias | Get-PSDrive | Get-Variable | Import-Alias
## New-Alias | New-PSDrive | New-Variable | Remove-Variable | Set-Alias | Set-Variable] -Scope &lt;tab&gt;
## Clear-Variable -Scope G&lt;tab&gt;
## Set-Alias  -s &lt;tab&gt;

## #Process name expansion
## [Get-Process | Stop-Process] [-Name] &lt;tab&gt;
## Stop-Process -Name &lt;tab&gt;
## Stop-Process -N pow&lt;tab&gt;
## Get-Process &lt;tab&gt;
## ps power&lt;tab&gt;

## #Trace sources expansion
## [Trace-Command | Get-TraceSource | Set-TraceSource] [-Name] &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;

## #Trace -ListenerOption expansion
## [Set-TraceSource | Trace-Command] -ListenerOption &lt;tab&gt;
## Set-TraceSource -Lis &lt;tab&gt;,n&lt;tab&gt;

## #Trace -Option expansion
## [Set-TraceSource | Trace-Command] -Option &lt;tab&gt;
## Set-TraceSource -op &lt;tab&gt;,con&lt;tab&gt;

## #ItemType expansion
## New-Item -Item &lt;tab&gt;
## ni -ItemType d&lt;tab&gt;

## #ErrorAction and WarningAction option expansion
## CMDLET [-ErrorAction | -WarningAction] &lt;tab&gt;
## CMDLET -Error s&lt;tab&gt;
## CMDLET -ea con&lt;tab&gt;
## CMDLET -wa &lt;tab&gt;

## #Continuous expansion with comma when parameter can treat multiple option
## # if there are spaces, occur display bug in the line
## # if strings contains '$' or '-', not work
## Get-Command -CommandType &lt;tab&gt;,&lt;tab&gt;&lt;tab&gt;,cm&lt;tab&gt;
## pwd -psp &lt;tab&gt;,f&lt;tab&gt;,va&lt;tab&gt;
## Get-EventLog -EntryType &lt;tab&gt;,i&lt;tab&gt;,s&lt;tab&gt;

## #Enum expansion in method call expression
## # this needs one or more spaces after left parenthesis or comma
## $str = &quot;day   night&quot;
## $str.Split( &quot; &quot;,&lt;space&gt;rem&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; ) &lt;Enter&gt; ERROR
## $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as&lt;space&gt;&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions] ) &lt;Enter&gt; Success
## $type = [System.Type]
## $type.GetMembers(&lt;space&gt;Def&lt;tab&gt;
## [IO.Directory]::GetFiles( &quot;C:\&quot;, &quot;*&quot;,&lt;space&gt;All&lt;tab&gt;
## # this can do continuous enum expansion with comma and no spaces
## $type.GetMembers( &quot;IgnoreCase&lt;comma&gt;Dec&lt;tab&gt;&lt;comma&gt;In&lt;tab&gt;&quot;
## [IO.Directory]::GetAccessControl( &quot;C:\&quot;,&lt;space&gt;au&lt;tab&gt;&lt;comma&gt;ac&lt;tab&gt;&lt;comma&gt;G&lt;tab&gt;

## #Better '$_.' expansion when cmdlet output objects or method return objects
## ls |group { $_.Cr&lt;tab&gt;.Tost&lt;tab&gt;&quot;y&quot;)} | tee -var foo| ? { $_.G&lt;tab&gt;.c&lt;tab&gt; -gt 5 } | % { md $_.N&lt;tab&gt; ; copy $_.G&lt;tab&gt; $_.N&lt;tab&gt;  }
## [IO.DriveInfo]::GetDrives() | ? { $_.A&lt;tab&gt; -gt 1GB }
## $Host.UI.RawUI.GetBufferContents($rect) | % { $str += $_.c&lt;tab&gt; }
## gcm Add-Content |select -exp Par&lt;tab&gt;|select -exp &lt;tab&gt; |
## select -ExpandProperty Par&lt;tab&gt;| | ? { $_.Par&lt;tab&gt;.N&lt;tab&gt; -eq &quot;string&quot; }
## $data = Get-Process
## $data[2,4,5]  | % { $_.&lt;tab&gt;
## #when Get-PipeLineObject failed, '$_.' shows methods and properties name of FileInfo and String and Type

## #Property name expansion
## [ Format-List | Format-Custom | Format-Table | Format-Wide | Compare-Object |
##  ConvertTo-Html | Measure-Object | Select-Object | Group-Object | Sort-Object ] [-Property] &lt;tab&gt;
## Select-Object -ExcludeProperty &lt;tab&gt;
## Select-Object -ExpandProperty &lt;tab&gt;
## gcm Get-Acl|select -exp Par&lt;tab&gt;
## ps |group na&lt;tab&gt;
## ls | ft A&lt;tab&gt;,M&lt;tab&gt;,L&lt;tab&gt;

## #Hashtable key expansion in the variable name and '.&lt;tab&gt;'
## Get-Process | Get-Unique | % { $hash += @{$_.ProcessName=$_} }
## $hash.pow&lt;tab&gt;.pro&lt;tab&gt;

## #Parameter expansion for function, filter and script
## man -f&lt;tab&gt;
## 'param([System.StringSplitOptions]$foo,[System.Management.Automation.ActionPreference]$bar,[System.Management.Automation.CommandTypes]$baz) {}' &gt; foobar.ps1
## .\foobar.ps1 -&lt;tab&gt; -b&lt;tab&gt;

## #Enum expansion for function, filter and scripts
## # this can do continuous enum expansion with comma and no spaces
## .\foobar.ps1 -foo rem&lt;tab&gt; -bar &lt;tab&gt;&lt;comma&gt;c&lt;tab&gt;&lt;comma&gt;sc&lt;tab&gt; -ea silent&lt;tab&gt; -wa con&lt;tab&gt;

## #Enum expansion for assignment expression
## #needs space(s) after '=' and comma
## #strongly-typed with -as operator and space(s)
## $ErrorActionPreference =&lt;space&gt;&lt;tab&gt;
## $cmdtypes = New-Object System.Management.Automation.CommandTypes[] 3
## $cmdtypes =&lt;space&gt;&lt;tab&gt;&lt;comma&gt;&lt;space&gt;func&lt;tab&gt;&lt;comma&gt;&lt;space&gt;cmd&lt;tab&gt; -as&lt;space&gt;&lt;tab&gt;


### Generate ProgIDs list...
if ($_ProgID -eq $null) {
    $_HKCR = [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\&quot;)
    [Object[]] $_ProgID = $null
    foreach ( $_subkey in $_HKCR.GetSubKeyNames() )
    {
        foreach ( $_i in [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\$_subkey\ProgID&quot;) )
        {
            if ($_i -ne $null)
            {
                $_ProgID += $_i.GetValue(&quot;&quot;)
            }
        }
    }
    '$_ProgID was updated...' | Out-Host
    $_ProgID = $_ProgID|sort -Unique

    Set-Content -Value $_ProgID -Path $PSHOME\ProgIDs.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_ProgID = Get-Content -Path C:\WINDOWS\system32\windowspowershell\v1.0\ProgIDs.txt;'
}

### Generate TypeNames list...

if ( $_TypeNames -eq $null ) {
    [Object[]] $_TypeNames = $null
    foreach ( $_asm in [AppDomain]::CurrentDomain.GetAssemblies() )
    {
        foreach ( $_type in $_asm.GetTypes() )
        {
            $_TypeNames += $_type.FullName
        }
    }
    '$_TypeNames was updated...' | Out-Host
    $_TypeNames = $_TypeNames | sort -Unique

    Set-Content -Value $_TypeNames -Path $PSHOME\TypeNames.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_TypeNames = Get-Content -Path $PSHOME\TypeNames.txt;'
}

if ( $_TypeNames_System -eq $null ) {
    [Object[]] $_TypeNames_System = $null
    foreach ( $_type in $_TypeNames -like &quot;System.*&quot; )
    {
        $_TypeNames_System += $_type.Substring(7)
    }
    '$_TypeNames_System was updated...' | Out-Host
    Set-Content -Value $_TypeNames_System -Path $PSHOME\TypeNames_System.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_TypeNames_System = Get-Content -Path $PSHOME\TypeNames_System.txt;'
}

### Generate WMIClasses list...
if ( $_WMIClasses -eq $null ) {
    [Object[]] $_WMIClasses = $null
    foreach ( $_class in gwmi -List )
    {
        $_WMIClasses += $_class.Name
    }
    $_WMIClasses = $_WMIClasses | sort -Unique
    '$_WMIClasses was updated...' | Out-Host
    Set-Content -Value $_WMIClasses -Path $PSHOME\WMIClasses.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_WMIClasses = Get-Content -Path $PSHOME\WMIClasses.txt;'
}
$global:_snapin = $null

# Load Get-PipeLineObject function for $_ and property name expansion.
$_scriptpath = gi $MyInvocation.MyCommand.Path
iex (&quot;. &quot; + (Join-Path $_scriptpath.DirectoryName &quot;Get-PipeLineObject.ps1&quot;))

function TabExpansion {
            # This is the default function to use for tab expansion. It handles simple
            # member expansion on variables, variable name expansion and parameter completion
            # on commands. It doesn't understand strings so strings containing ; | ( or { may
            # cause expansion to fail.

            param($line, $lastWord)

            &amp; {
                # Helper function to write out the matching set of members. It depends
                # on dynamic scoping to get $_base, _$expression and $_pat
                function Write-Members ($sep='.')
                {

                    # evaluate the expression to get the object to examine...
                    Invoke-Expression ('$_val=' + $_expression)

                    if ( $_expression -match '^\$global:_dummy' )
                    {
                        $temp = $_expression -replace '^\$global:_dummy(.*)','$1'
                        $_expression = '$_' + $temp
                    }


                    $_method = [Management.Automation.PSMemberTypes] `
                        'Method,CodeMethod,ScriptMethod,ParameterizedProperty'

                    if ($sep -eq '.')
                    {
                        $members = 
                            (
                                [Object[]](Get-Member -InputObject $_val.PSextended $_pat) + 
                                [Object[]](Get-Member -InputObject $_val.PSadapted $_pat) + 
                                [Object[]](Get-Member -InputObject $_val.PSbase $_pat)
                            )
                        if ( $_val -is [Hashtable] )
                        {
                            [Microsoft.PowerShell.Commands.MemberDefinition[]]$_keys = $null
                            foreach ( $_name in $_val.Keys )
                            {
                                $_keys += `
                                New-Object Microsoft.PowerShell.Commands.MemberDefinition `
                                [int],$_name,&quot;Property&quot;,0
                            }

                            $members += [Object[]]$_keys | ? { $_.Name -like $_pat }
                        }

                        foreach ($_m in $members | sort membertype,name -Unique)
                            {
                                if ($_m.MemberType -band $_method)
                                {
                                    # Return a method...
                                    $_base + $_expression + $sep + $_m.name + '('
                                }
                                else {
                                    # Return a property...
                                    $_base + $_expression + $sep + $_m.name
                                }
                            }
                        }

                    else
                    {
                    foreach ($_m in Get-Member -Static -InputObject $_val $_pat |
                        Sort-Object membertype,name)
                       {
                           if ($_m.MemberType -band $_method)
                           {
                               # Return a method...
                               $_base + $_expression + $sep + $_m.name + '('
                           }
                           else {
                               # Return a property...
                               $_base + $_expression + $sep + $_m.name
                           }
                        }
                    }
                }

                switch -regex ($lastWord)
                {

                    # Handle property and method expansion at '$_'
                    '(^.*)(\$_\.)(\w*)$' {
                        $_base = $matches[1]
                        $_expression = '$global:_dummy'
                        $_pat = $matches[3] + '*'
                        $global:_dummy = $null
                        Get-PipeLineObject
                        if ( $global:_dummy -eq $null )
                        {

                            if ( $global:_exp -match '^\$.*\(.*$' )
                            {
                                $type = ( iex $_exp.Split(&quot;(&quot;)[0] ).OverloadDefinitions[0].Split(&quot; &quot;)[0] -replace '\[[^\[\]]*\]$' -as [type]

                                if ( $_expression -match '^\$global:_dummy' )
                                {
                                    $temp = $_expression -replace '^\$global:_dummy(.*)','$1'
                                    $_expression = '$_' + $temp
                                }

                                foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
                                {
                                   if ($_m.MemberType -eq &quot;Method&quot;)
                                   {
                                       $_base + $_expression + '.' + $_m.name + '('
                                   }
                                   else {
                                       $_base + $_expression + '.' + $_m.name
                                   }
                                }
                                break;
                            }
                            elseif ( $global:_exp -match '^\[.*\:\:.*\(.*$' )
                            {
                                $tname, $mname = $_exp.Split(&quot;:(&quot;, &quot;RemoveEmptyEntries&quot;-as [System.StringSplitOptions])[0,1]
                                $type = @(iex ($tname + '.GetMember(&quot;' + $mname + '&quot;)'))[0].ReturnType.FullName -replace '\[[^\[\]]*\]$' -as [type]

                                if ( $_expression -match '^\$global:_dummy' )
                                {
                                    $temp = $_expression -replace '^\$global:_dummy(.*)','$1'
                                    $_expression = '$_' + $temp
                                }

                                foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
                                {
                                   if ($_m.MemberType -eq &quot;Method&quot;)
                                   {
                                       $_base + $_expression + '.' + $_m.name + '('
                                   }
                                   else {
                                       $_base + $_expression + '.' + $_m.name
                                   }
                                }
                                break;
                            }
                            elseif ( $global:_exp -match '^(\$\w+(\[[0-9,\.]+\])*(\.\w+(\[[0-9,\.]+\])*)*)$' )
                            {
                                $global:_dummy = @(iex $Matches[1])[0]
                            }
                            else
                            {
                                $global:_dummy =  $global:_mix
                            }
                        }

                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at variables...
                    # e.g. $a.b.&lt;tab&gt;
                    '(^.*)(\$(\w|\.)+)\.(\w*)$' {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        [void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
                        $_pat = $matches[4] + '*'
                        if ( $_expression -match '^\$_\.' )
                        {
                            $_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
                        }
                        Write-Members
                        break;
                    }

                    # Handle simple property and method expansion on static members...
                    # e.g. [datetime]::n&lt;tab&gt;
                    '(^.*)(\[(\w|\.)+\])\:\:(\w*)$' {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        $_pat = $matches[4] + '*'
                        Write-Members '::'
                        break;
                    }

                    # Handle complex property and method expansion on static members
                    # where there are intermediate properties...
                    # e.g. [datetime]::now.d&lt;tab&gt;
                    '(^.*)(\[(\w|\.)+\]\:\:(\w+\.)+)(\w*)$' {
                        $_base = $matches[1]  # everything before the expression
                        $_expression = $matches[2].TrimEnd('.') # expression less trailing '.'
                        $_pat = $matches[5] + '*'  # the member to look for...
                        Write-Members
                        break;
                    }

                    # Handle variable name expansion...
                    '(^.*\$)(\w+)$' {
                        $_prefix = $matches[1]
                        $_varName = $matches[2]
                        foreach ($_v in Get-ChildItem ('variable:' + $_varName + '*'))
                        {
                            $_prefix + $_v.name
                        }
                        break;
                    }

                    # Handle env&amp;function drives variable name expansion...
                    '(^.*\$)(.*\:)(\w+)$' {
                        $_prefix = $matches[1]
                        $_drive = $matches[2]
                        $_varName = $matches[3]
                        if ($_drive -eq &quot;env:&quot; -or $_drive -eq &quot;function:&quot;)
                        {
                            foreach ($_v in Get-ChildItem ($_drive + $_varName + '*'))
                            {
                                $_prefix + $_drive + $_v.name
                            }
                        }
                        break;
                    }

                    # Handle array's element property and method expansion
                    # where there are intermediate properties...
                    # e.g. foo[0].n.b&lt;tab&gt;
                    '(^.*)(\$((\w+\.)|(\w+(\[(\w|,)+\])+\.))+)(\w*)$'
                    {
                        $_base = $matches[1]
                        $_expression = $matches[2].TrimEnd('.')
                        $_pat = $Matches[8] + '*'
                        [void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
                        if ( $_expression -match '^\$_\.' )
                        {
                            $_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
                        }
                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at type object...
                    # e.g. [System.Type].a&lt;tab&gt;
                    '(^\[(\w|\.)+\])\.(\w*)$'
                    {
                        if ( $(iex $Matches[1]) -isnot [System.Type] ) { break; }
                        $_expression = $Matches[1]
                        $_pat = $Matches[$matches.Count-1] + '*'
                        Write-Members
                        break;
                    }

                    # Handle complex property and method expansion on type object members
                    # where there are intermediate properties...
                    # e.g. [datetime].Assembly.a&lt;tab&gt;
                    '^(\[(\w|\.)+\]\.(\w+\.)+)(\w*)$' {
                        $_expression = $matches[1].TrimEnd('.') # expression less trailing '.'
                        $_pat = $matches[4] + '*'  # the member to look for...
                        if ( $(iex $_expression) -eq $null ) { break; }
                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at close parenthes...
                    # e.g. (123).a&lt;tab&gt;
                    '^(.*)\)((\w|\.)*)\.(\w*)$' {
                        $_base = $Matches[1] + &quot;)&quot;
                        if ( $matches[3] -eq $null) { $_expression = '[System.Type]' }
                        else { $_expression = '[System.Type]' + $Matches[2] }
                        $_pat = $matches[4] + '*'
                        iex &quot;$_expression | Get-Member $_pat | sort MemberType,Name&quot; |
                        % {
                            if ( $_.MemberType -like &quot;*Method*&quot; -or $_.MemberType -like &quot;*Parameterized*&quot; ) { $parenthes = &quot;(&quot; }
                            if ( $Matches[2] -eq &quot;&quot; ) { $_base + &quot;.&quot; + $_.Name + $parenthes }
                            else { $_base + $Matches[2] + &quot;.&quot; + $_.Name + $parenthes }
                          }
                        break;
                    }

                    # Handle .NET type name expansion ...
                    # e.g. [Microsoft.PowerShell.Com&lt;tab&gt;
                    '^\[((\w+\.?)+)$' {
                        $_opt = $matches[1] + '*'
                        foreach ( $_exp in $_TypeNames_System -like $_opt )
                        {
                            '[' + $_exp
                        }
                        foreach ( $_exp in $_TypeNames -like $_opt )
                        {
                            '[' + $_exp
                        }
                        break;
                    }

                    # Do completion on parameters...
                    '^-([\w0-9]*)' {
                        $_pat = $matches[1] + '*'

                        # extract the command name from the string
                        # first split the string into statements and pipeline elements
                        # This doesn't handle strings however.
                        $_cmdlet = [regex]::Split($line, '[|;=]')[-1]

                        #  Extract the trailing unclosed block e.g. ls | foreach { cp
                        if ($_cmdlet -match '\{([^\{\}]*)$')
                        {
                            $_cmdlet = $matches[1]
                        }

                        # Extract the longest unclosed parenthetical expression...
                        if ($_cmdlet -match '\(([^()]*)$')
                        {
                            $_cmdlet = $matches[1]
                        }

                        # take the first space separated token of the remaining string
                        # as the command to look up. Trim any leading or trailing spaces
                        # so you don't get leading empty elements.
                        $_cmdlet = $_cmdlet.Trim().Split()[0]

                        # now get the info object for it...
                        $_cmdlet = @(Get-Command -type 'cmdlet,alias,function,filter,ExternalScript' $_cmdlet)[0]

                        # loop resolving aliases...
                        while ($_cmdlet.CommandType -eq 'alias')
                        {
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias,function,filter,ExternalScript' $_cmdlet.Definition)[0]
                        }

                        if ( $_cmdlet.CommandType -eq &quot;Cmdlet&quot; )
                        {
                            # expand the parameter sets and emit the matching elements
                            foreach ($_n in $_cmdlet.ParameterSets |
                                Select-Object -expand parameters | Sort-Object -Unique name)
                            {
                                $_n = $_n.name
                                if ($_n -like $_pat) { '-' + $_n }
                            }
                            break;
                        }

                        if ( &quot;ExternalScript&quot;, &quot;Function&quot;, &quot;Filter&quot; -contains $_cmdlet.CommandType )
                        {
                            if ( $_cmdlet.CommandType -eq &quot;ExternalScript&quot; )
                            {
                                $_fsr = New-Object IO.StreamReader $_cmdlet.Definition
                                $_def = &quot;Function _Dummy { $($_fsr.ReadToEnd()) }&quot;
                                $_fsr.Close()
                                iex $_def
                                $_cmdlet = &quot;_Dummy&quot;
                            }

                            if ( ((gi &quot;Function:$_cmdlet&quot;).Definition -replace '\n').Split(&quot;{&quot;)[0] -match 'param\((.*\))\s*[;\.&amp;a-zA-Z]*\s*$' )
                            {
                                ( ( ( $Matches[1].Split('$', &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) -replace `
                                '^(\w+)(.*)','$1' ) -notmatch '^\s+$' ) -notmatch '^\s*\[.*\]\s*$' ) -like $_pat | sort | % { '-' + $_ }
                            }
                            break;
                        }

                    }


                    # try to find a matching command...
                    default {

                        $lastex =  [regex]::Split($line, '[|;]')[-1]
                        if ( $lastex -match '^\s*(\$\w+(\[[0-9,]+\])*(\.\w+(\[[0-9,]+\])*)*)\s*=\s+((&quot;\w+&quot;\s*,\s+)*)&quot;\w+&quot;\s*-as\s+$' )
                        {
                            if ( $Matches[6] -ne $nul )
                            {
                            $brackets = &quot;[]&quot;
                            }
                            '['+ $global:_enum + $brackets + ']'
                            break;
                        }


                        if ( $lastex -match '^\s*(\$\w+(\[[0-9,]+\])*(\.\w+(\[[0-9,]+\])*)*)\s*=\s+((&quot;\w+&quot;\s*,\s+)*)\s*(\w*)$' )
                        {
                            $_pat = $Matches[7] + '*'

                            $_type = @(iex $Matches[1])[0].GetType()
                            if ( $_type.IsEnum )
                            {
                                $global:_enum = $_type.FullName
                                [Enum]::GetValues($_type) -like $_pat -replace '^(.*)$','&quot;$1&quot;'
                                break;
                            }
                        }

                        $lastex =  [regex]::Split($line, '[|;=]')[-1]
                        if ($lastex  -match '[[$].*\w+\(.*-as\s*$')
                        {
                            '['+ $global:_enum + ']'
                        }
                        elseif ( $lastex -match '([[$].*(\w+))\((.*)$' )
                        #elseif ( $lastex -match '([[$].*(\w+))\(([^)]*)$' )
                        {
                            $_method = $Matches[1]

                            if ( $Matches[3] -match &quot;(.*)((`&quot;|')(\w+,)+(\w*))$&quot; )
                            {
                                $continuous = $true
                                $_opt =  $Matches[5] + '*'
                                $_base =  $Matches[2].TrimStart('&quot;') -replace '(.*,)\w+$','$1'
                                $position = $Matches[1].Split(&quot;,&quot;).Length
                            }
                            else
                            {
                                $continuous = $false
                                $_opt = ($Matches[3].Split(',')[-1] -replace '^\s*','') + &quot;*&quot;
                                $position = $Matches[3].Split(&quot;,&quot;).Length
                            }

                            if ( ($_mdefs = iex ($_method + &quot;.OverloadDefinitions&quot;)) -eq $null )
                            {
                                $tname, $mname = $_method.Split(&quot;:&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
                                $_mdefs = iex ($tname + '.GetMember(&quot;' + $mname + '&quot;) | % { $_.ToString() }')
                            }

                            foreach ( $def in $_mdefs )
                            {
                                [void] ($def -match '\((.*)\)')
                                foreach ( $param in [regex]::Split($Matches[1], ', ')[$position-1] )
                                {
                                    if ($param -eq $null -or $param -eq &quot;&quot;)
                                    {
                                        continue;
                                    }
                                    $type = $param.split()[0]

                                    if ( $type -like '*`[*' -or $type -eq &quot;Params&quot; -or $type -eq &quot;&quot; )
                                    {
                                        continue;
                                    }
                                    $fullname  = @($_typenames -like &quot;*$type*&quot;)
                                    foreach ( $name in $fullname )
                                    {
                                        if ( $continuous -eq $true -and ( $name  -as [System.Type] ).IsEnum )
                                        {
                                            $output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$',($_base + '$1')
                                            $output | sort
                                        }
                                        elseif ( ( $name  -as [System.Type] ).IsEnum ) 
                                        {
                                            $global:_enum = $name
                                            $output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$','&quot;$1&quot;'
                                            $output | sort
                                        }
                                    }
                                }
                            }
                            if ( $output -ne $null )
                            {
                                break;
                            }
                        }


                        if ( $line[-1] -eq &quot; &quot; )
                        {
                            $_cmdlet = $line.TrimEnd(&quot; &quot;).Split(&quot; |(;={&quot;)[-1]

                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

                            # loop resolving aliases...
                            while ($_cmdlet.CommandType -eq 'alias')
                            {
                                $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
                            }

                            if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
                            {
                                &quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; | sort
                                break;
                            }

                            if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
                            {
                               Get-TraceSource | % { $_.Name } | sort -Unique
                               break;
                            }

                            if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
                            {
                                 $_TypeNames_System
                                 $_TypeNames
                                 break;
                            }

                            if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
                            {
                                $_WMIClasses
                                break;
                            }

                            if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Process | % { $_.Name } | sort
                                 break;
                            }

                            if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin
                                    break;
                                }
                            }

                            if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; )
                            {
                                Get-PSDrive | sort
                                break;
                            }

                            if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
                            {
                                 Get-EventLog -List | % { $_base + ($_.Log -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
                            {
                                Get-Help -Category all | % { $_.Name } | sort -Unique
                                     break;
                            }

                            if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
                                 &quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
                                 -contains $_cmdlet.Name )
                            {
                                Get-Service | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Command -CommandType All | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
                                 &quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
                                  -contains $_cmdlet.Name )
                            {
                                 Get-PipeLineObject
                                 $_dummy | Get-Member -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                        }

                        if ( $line[-1] -eq &quot; &quot; )
                        {
                            # extract the command name from the string
                            # first split the string into statements and pipeline elements
                            # This doesn't handle strings however.
                            $_cmdlet = [regex]::Split($line, '[|;=]')[-1]

                            #  Extract the trailing unclosed block e.g. ls | foreach { cp
                            if ($_cmdlet -match '\{([^\{\}]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # Extract the longest unclosed parenthetical expression...
                            if ($_cmdlet -match '\(([^()]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # take the first space separated token of the remaining string
                            # as the command to look up. Trim any leading or trailing spaces
                            # so you don't get leading empty elements.
                            $_cmdlet = $_cmdlet.Trim().Split()[0]

                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'Application' $_cmdlet)[0]

                            if ( $_cmdlet.Name -eq &quot;powershell.exe&quot; )
                            {
                                &quot;-PSConsoleFile&quot;, &quot;-Version&quot;, &quot;-NoLogo&quot;, &quot;-NoExit&quot;, &quot;-Sta&quot;, &quot;-NoProfile&quot;, &quot;-NonInteractive&quot;,
                                &quot;-InputFormat&quot;, &quot;-OutputFormat&quot;, &quot;-EncodedCommand&quot;, &quot;-File&quot;, &quot;-Command&quot; | sort
                                break;
                            }
                            if ( $_cmdlet.Name -eq &quot;fsutil.exe&quot; )
                            {
                                &quot;behavior query&quot;, &quot;behavior set&quot;, &quot;dirty query&quot;, &quot;dirty set&quot;, 
                                &quot;file findbysid&quot;, &quot;file queryallocranges&quot;, &quot;file setshortname&quot;, &quot;file setvaliddata&quot;, &quot;file setzerodata&quot;, &quot;file createnew&quot;, 
                                &quot;fsinfo drives&quot;, &quot;fsinfo drivetype&quot;, &quot;fsinfo volumeinfo&quot;, &quot;fsinfo ntfsinfo&quot;, &quot;fsinfo statistics&quot;, 
                                &quot;hardlink create&quot;, &quot;objectid query&quot;, &quot;objectid set&quot;, &quot;objectid delete&quot;, &quot;objectid create&quot;,
                                &quot;quota disable&quot;, &quot;quota track&quot;, &quot;quota enforce&quot;, &quot;quota violations&quot;, &quot;quota modify&quot;, &quot;quota query&quot;,
                                &quot;reparsepoint query&quot;, &quot;reparsepoint delete&quot;, &quot;sparse setflag&quot;, &quot;sparse queryflag&quot;, &quot;sparse queryrange&quot;, &quot;sparse setrange&quot;,
                                &quot;usn createjournal&quot;, &quot;usn deletejournal&quot;, &quot;usn enumdata&quot;, &quot;usn queryjournal&quot;, &quot;usn readdata&quot;, &quot;volume dismount&quot;, &quot;volume diskfree&quot; | sort
                                break;
                            }
                            if ( $_cmdlet.Name -eq &quot;net.exe&quot; )
                            {
                                &quot;ACCOUNTS &quot;, &quot; COMPUTER &quot;, &quot; CONFIG &quot;, &quot; CONTINUE &quot;, &quot; FILE &quot;, &quot; GROUP &quot;, &quot; HELP &quot;, 
                                &quot;HELPMSG &quot;, &quot; LOCALGROUP &quot;, &quot; NAME &quot;, &quot; PAUSE &quot;, &quot; PRINT &quot;, &quot; SEND &quot;, &quot; SESSION &quot;, 
                                &quot;SHARE &quot;, &quot; START &quot;, &quot; STATISTICS &quot;, &quot; STOP &quot;, &quot; TIME &quot;, &quot; USE &quot;, &quot; USER &quot;, &quot; VIEW&quot; | sort
                                break;
                            }
                            if ( $_cmdlet.Name -eq &quot;ipconfig.exe&quot; )
                            {
                                &quot;/?&quot;, &quot;/all&quot;, &quot;/renew&quot;, &quot;/release&quot;, &quot;/flushdns&quot;, &quot;/displaydns&quot;,
                                &quot;/registerdns&quot;, &quot;/showclassid&quot;, &quot;/setclassid&quot;
                                break;
                            }
                        }

                        if ( $line -match '\w+\s+(\w+(\.|[^\s\.])*)$' )
                        {
                            #$_opt = $Matches[1] + '*'
                            $_cmdlet = $line.TrimEnd(&quot; &quot;).Split(&quot; |(;={&quot;)[-2]

                            $_opt = $Matches[1].Split(&quot; ,&quot;)[-1] + '*'
                            $_base = $Matches[1].Substring(0,$Matches[1].Length-$Matches[1].Split(&quot; ,&quot;)[-1].length)


                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

                            # loop resolving aliases...
                            while ($_cmdlet.CommandType -eq 'alias')
                            {
                                $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
                            }

                            if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
                            {
                                &quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; -like $_opt | sort
                                break;
                            }

                            if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
                            {
                               Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
                               break;
                            }

                            if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
                            {
                                 $_TypeNames_System -like $_opt
                                 $_TypeNames -like $_opt
                                 break;
                            }

                            if ( $_cmdlet.Name -like &quot;*WMI*&quot; )
                            {
                                $_WMIClasses -like $_opt
                                break;
                            }

                            if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                            }

                            if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; )
                            {
                                Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-PSProvider&quot; -eq $_cmdlet.Name )
                            {
                                Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }


                            if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
                            {
                                 Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
                            {
                                Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
                                     break;
                            }

                            if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
                                 &quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
                                 -contains $_cmdlet.Name )
                            {
                                Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
                                 &quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
                                  -contains $_cmdlet.Name )
                            {
                                 Get-PipeLineObject
                                 $_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }
                        }

                        if ( $line -match '(-(\w+))\s+([^-]*$)' )
                        {

                            $_param = $matches[2] + '*'
                            $_opt = $Matches[3].Split(&quot; ,&quot;)[-1] + '*'
                            $_base = $Matches[3].Substring(0,$Matches[3].Length-$Matches[3].Split(&quot; ,&quot;)[-1].length)

                            # extract the command name from the string
                            # first split the string into statements and pipeline elements
                            # This doesn't handle strings however.
                            $_cmdlet = [regex]::Split($line, '[|;=]')[-1]

                            #  Extract the trailing unclosed block e.g. ls | foreach { cp
                            if ($_cmdlet -match '\{([^\{\}]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # Extract the longest unclosed parenthetical expression...
                            if ($_cmdlet -match '\(([^()]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # take the first space separated token of the remaining string
                            # as the command to look up. Trim any leading or trailing spaces
                            # so you don't get leading empty elements.
                            $_cmdlet = $_cmdlet.Trim().Split()[0]

                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias,ExternalScript,Filter,Function' $_cmdlet)[0]

                            # loop resolving aliases...
                            while ($_cmdlet.CommandType -eq 'alias')
                            {
                                $_cmdlet = @(Get-Command -type 'cmdlet,alias,ExternalScript,Filter,Function' $_cmdlet.Definition)[0]
                            }

                            if ( $_param.TrimEnd(&quot;*&quot;) -eq &quot;ea&quot; -or $_param.TrimEnd(&quot;*&quot;) -eq &quot;wa&quot; )
                            {
                               &quot;SilentlyContinue&quot;, &quot;Stop&quot;, &quot;Continue&quot;, &quot;Inquire&quot; |
                               ? { $_ -like $_opt } | sort -Unique
                               break;
                            }

                            if ( &quot;Out-File&quot;,&quot;Export-CSV&quot;,&quot;Select-String&quot;,&quot;Export-Clixml&quot; -contains $_cmdlet.Name `
                                 -and &quot;Encoding&quot; -like $_param)
                            {
                                &quot;Unicode&quot;,  &quot;UTF7&quot;, &quot;UTF8&quot;, &quot;ASCII&quot;, &quot;UTF32&quot;, &quot;BigEndianUnicode&quot;, &quot;Default&quot;, &quot;OEM&quot; |
                                ? { $_ -like $_opt } | sort -Unique
                                break;
                            }

                            if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name `
                                -and &quot;Name&quot; -like $_param)
                            {
                               Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
                               break;
                            }

                            if ( &quot;New-Object&quot; -like $_cmdlet.Name )
                            {
                                if ( &quot;ComObject&quot; -like $_param )
                                {
                                    $_ProgID -like $_opt  | % { $_ -replace '\s','` ' }
                                    break;
                                }

                                if ( &quot;TypeName&quot; -like $_param )
                                {
                                    $_TypeNames_System -like $_opt
                                    $_TypeNames -like $_opt
                                    break;
                                }
                            }

                            if ( &quot;New-Item&quot; -eq $_cmdlet.Name )
                            {
                                if ( &quot;ItemType&quot; -like $_param )
                                {
                                    &quot;directory&quot;, &quot;file&quot; -like $_opt
                                    break;
                                }
                            }

                            if ( &quot;Get-Location&quot;, &quot;Get-PSDrive&quot;, &quot;Get-PSProvider&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name `
                                 -and &quot;PSProvider&quot; -like $_param )
                            {
                                Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort  | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Location&quot; -eq $_cmdlet.Name -and &quot;PSDrive&quot; -like $_param )
                            {
                                Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and  &quot;PSSnapin&quot; -like $_param)
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin -like $_opt  | % { $_base + $_ }
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin -like $_opt  | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                            }

                            if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin -like $_opt | % { $_base + $_ }
                                    break;
                                }
                            }

                            if ( &quot;Clear-Variable&quot;, &quot;Export-Alias&quot;, &quot;Get-Alias&quot;, &quot;Get-PSDrive&quot;, &quot;Get-Variable&quot;, &quot;Import-Alias&quot;,
                                 &quot; New-Alias&quot;, &quot;New-PSDrive&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Alias&quot;, &quot;Set-Variable&quot; `
                                 -contains $_cmdlet.Name -and &quot;Scope&quot; -like $_param )
                            {
                                &quot;Global&quot;, &quot;Local&quot;, &quot;Script&quot; -like $_opt
                                break;
                            }

                            if ( &quot;Get-Process&quot;, &quot;Stop-Process&quot;, &quot;Wait-Process&quot; -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                 Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name -and &quot;LogName&quot; -like $_param )
                            {
                                 Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
                            {
                                 if ( &quot;Name&quot; -like $_param )
                                 {
                                     Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
                                     break;
                                 }
                                 if ( &quot;Category&quot; -like $_param )
                                 {
                                     &quot;Alias&quot;, &quot;Cmdlet&quot;, &quot;Provider&quot;, &quot;General&quot;, &quot;FAQ&quot;,
                                     &quot;Glossary&quot;, &quot;HelpFile&quot;, &quot;All&quot; -like $_opt | sort | % { $_base + $_ }
                                     break;
                                 }
                            }

                            if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
                                 &quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
                                 -contains $_cmdlet.Name )
                            {
                                 if ( &quot;Name&quot; -like $_param )
                                 {
                                     Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
                                     break;
                                 }
                                 if ( &quot;DisplayName&quot; -like $_param )
                                 {
                                     Get-Service -Name $_opt | sort DisplayName | % { $_base + ($_.DisplayName -replace '\s','` ') }
                                     break;
                                 }
                            }

                            if ( &quot;New-Service&quot; -eq $_cmdlet.Name -and &quot;dependsOn&quot; -like $_param )
                            {
                                 Get-Service -Name $_opt | sort Name | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-EventLog&quot; -eq $_cmdlet.Name -and &quot;EntryType&quot; -like $_param )
                            {
                                 &quot;Error&quot;, &quot;Information&quot;, &quot;FailureAudit&quot;, &quot;SuccessAudit&quot;, &quot;Warning&quot; -like $_opt | sort | % { $_base + $_ }
                                 break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                 Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
                            {
                                if ( &quot;Class&quot; -like $_param )
                                {
                                    $_WMIClasses -like $_opt
                                    break;
                                }
                            }

                            if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
                                 &quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
                                  -contains $_cmdlet.Name -and &quot;Property&quot; -like $_param )
                            {
                                 Get-PipeLineObject
                                 $_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Select-Object&quot; -eq $_cmdlet.Name )
                            {
                                if ( &quot;ExcludeProperty&quot; -like $_param )
                                {
                                 Get-PipeLineObject
                                 $_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                                }

                                if ( &quot;ExpandProperty&quot; -like $_param )
                                {
                                 Get-PipeLineObject
                                 $_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_.Name }
                                 break;
                                }
                            }

                        if ( &quot;ExternalScript&quot;, &quot;Function&quot;, &quot;Filter&quot; -contains $_cmdlet.CommandType )
                        {
                            if ( $_cmdlet.CommandType -eq &quot;ExternalScript&quot; )
                            {
                                $_fsr = New-Object IO.StreamReader $_cmdlet.Definition
                                $_def = &quot;Function _Dummy { $($_fsr.ReadToEnd()) }&quot;
                                $_fsr.Close()
                                iex $_def
                                $_cmdlet = &quot;_Dummy&quot;
                            }

                            if ( ((gi &quot;Function:$_cmdlet&quot;).Definition -replace '\n').Split(&quot;{&quot;)[0] -match 'param\((.*\))\s*[;\.&amp;a-zA-Z]*\s*$' )
                            {
                                $Matches[1].Split(',', &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) -like &quot;*$_param&quot; |
                                % { $_.Split(&quot;$ )`r`n&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])[0] -replace '^\[(.*)\]$','$1' -as &quot;System.Type&quot; } |
                                ? { $_.IsEnum } | % { [Enum]::GetNames($_) -like $_opt | sort } | % { $_base + $_ }
                            }
                            break;
                        }

                            select -InputObject $_cmdlet -ExpandProperty ParameterSets | select -ExpandProperty Parameters |
                            ? { $_.Name -like $_param } | ? { $_.ParameterType.IsEnum } |
                            % { [Enum]::GetNames($_.ParameterType) } | ? { $_ -like $_opt } | sort -Unique | % { $_base + $_ }

                        }


                               if ( $line[-1] -match &quot;\s&quot; ) { break; }
	
                               if ( $lastWord -ne $null -and $lastWord.IndexOfAny('/\') -eq -1 ) {
                                  $command = $lastWord.Substring( ($lastWord -replace '([^\|\(;={]*)$').Length )
                                  $_base = $lastWord.Substring( 0, ($lastWord -replace '([^\|\(;={]*)$').Length )
                                  $pattern = $command + &quot;*&quot;
                                  gcm -Name $pattern -CommandType All | % { $_base + $_.Name } | sort -Unique
                               }
                    }
                }
            }
        
}
</code></pre>

</div>
			<!-- sidebar? -->
		</div>
		<hr>
		<footer class="blog-footer">
			<p>Generated by Joel &quot;Jaykul&quot; Bennett - 2018</p>
		</footer>
	</div> <!-- /container -->

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>
    <script src="/js/vendor/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>