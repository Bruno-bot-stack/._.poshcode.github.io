
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="Martijn Jonker">
    <title>NetBackup Backup Report - PoshCode</title>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" data-tabs="tabs" id="tabs">
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video" data-toggle="tab">Video Feed</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

    

<div class="blog-post">
    <h2 class="blog-post-title">NetBackup Backup Report</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2010-12-21</span> by <a class="blog-post-author">Martijn Jonker</a>
    </p>

    <h1>NetBackup Backup Report</h1>
<h3><a href="//scripts/2415.ps1">download</a></h3>
<p>Script to create a backup report from Netbackup jobs
The script was tested with NetBackup 6.5, 6.5.5 and 7.0, in a single master/media server environment.</p>
<pre><code class="language-posh">###################################################################################################
#
# NAME: NBU-BackupReport.ps1
#
# AUTHOR: Martijn Jonker
#
# COMMENT: Script to create a backup report from Netbackup jobs on windows platform.
# Adjust variables below this section.
# The script generates a report every weekday. Monday report covers the weekend.
# To adjust this, edit lines 94-103 and 483-490
#
# The script calls Netbackup commandline tools to gather information.
# Job status is checked against three different arrays (Successful, partial, failed).
# Depending on Status, Client, Policy, Schedule and EndTime lines are either added to or
# removed from the arrays.
# The script gathers statistics per policy/server about the backup operation,
# (number of files backed up,size of files backed up and elapsed time),
# so servers is multiple policies will show up multiple times in the statistics.
# The script reports tape media and disk storage unit usage.
# The script e-mails the result
#
# Run the script interactively, or as a scheduled task.
#
# The script requires &quot;&lt;Programdir&gt;\NetBackup\bin\admincmd&quot; and
# &quot;&lt;Programdir&gt;\NetBackup\bin\goodies&quot; to be in the %path% ($Env:path) environment variable
# 
# The script was tested with NetBackup 6.5, 6.5.5 and 7.0,
# in a single master/media server environment.
#
# VERSION HISTORY:
# 1.0: Transcoded from .vbs to .ps1
# 1.1: Added E-mail notification
# 2.0: Rewrote logic for better efficiency
# 2.1: Minor tweaks to date/time formatting
# 3.0: Added Tape Media used for backup
#      Added Storage Unit Status
#      Added Backup statictics
# 3.1: Documented script
#      Minor efficiency tweaks
###################################################################################################
# --------------------------- Adjust variables below to suit your needs --------------------------- #
$StartTime = &quot;17:00:00&quot; # Starttime for backup operation, in NBU format
$Endtime = &quot;17:00:00&quot; # Endtime for backup operation, in NBU format
$OutputPth = &quot;C:\scripts&quot; # Path to $outputfile
$OutputFile = &quot;BackupReport.txt&quot; # Name of outputfile
$SmtpServer = &quot;smtp.server&quot; # Address of SMTP server
$From = &quot;netbackup@company.com&quot; # From e-mail address
$To = &quot;report@company.com&quot; # To e-mail address. Multiple addresses can be used, seperate by comma
$CC = &quot;CC-Recipients.txt&quot; # Textfile containing e-mail addresses to CC, one per line. Located in $outputpth
$ClientStringLength = 15 # Number of characters in the $client string, including whitespace
$PolicyStringLength = 25 # Number of characters in the $Policy string, including whitespace
$FileStringLength = 10 # Number of characters in the $Files string, including whitespace
$KBStringLength = 12 # Number of characters in the $KBs string, including whitespace
$ElapsedString = 10 # Number of characters in the $Elapsed string, including whitespace
#
# !&gt; ---------------------------! Do not change anything beyond this point !--------------------------- &lt;!
#
Switch (Test-Path $OutputPth) # Check if $OutputPth exists
{
 False # If $OutputPth does not exist
 {
  New-Item $OutputPth -ItemType Directory | Out-Null # Create $OutputPth
  Write-Host &quot;Output Path did not exist, it was created: $OutputPth&quot; -ForegroundColor &quot;White&quot; # Write to console
  Write-Host &quot;----------&quot; -ForegroundColor &quot;Yellow&quot; # Write to console
 }
}
$OutputStr = $OutputPth + &quot;\&quot; + $OutputFile # Combine $OutputPth and $OutputFile to a single string
# ---
$JobHeader = &quot;STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED&quot; # General header for backup job status
$ClientNotReported = @(&quot;&quot;;&quot;Servers that did not (yet) report any activity&quot;;&quot;----------------------------------------------&quot;;(&quot;CLIENT&quot;+&quot; &quot;*($ClientStringLength-6))+(&quot;POLICY&quot;+&quot; &quot;*($PolicyStringLength-6))) # initialize array for servers that did not report activity at the time of running the report and add header
$TotalOK = @() # Initialize array to contain the final results for all successful jobs
$TotalPartial = @() # Initialize array to contain the final results for all partially successful jobs
$TotalFail = @() # Initialize array to contain the final results for all failed jobs
$UsedPolSched = @() # Initialize array to contain policies and schedules used during backup operation, used to report on disk storageunits.
# ---
$NBU_BaseTime = get-date &quot;1/1/1970 00:00:00&quot; # Netbackup Basetime, used to calculate elapsed time
$TotalFiles = 0 # Initialize variable to contain the total number of files backed up
$TotalKB = 0 # Initialize variable to contain the total KiloBytes backed up
$NBUStats = @() # Initialize array to contain the backup operation statistics
$NBUStatsHeader = @(&quot;&quot;;&quot;BACKUP STATISTICS&quot;;(&quot;CLIENT&quot;+&quot; &quot;*($ClientStringLength-6))+(&quot;POLICY&quot;+&quot; &quot;*($PolicyStringLength-6))+(&quot;FILES&quot;+&quot; &quot;*($FileStringLength-5))+(&quot;SIZE&quot;+&quot; &quot;*($KBStringLength-4))+(&quot;ELAPSED&quot;+&quot; &quot;*($ElapsedString-7))) # Array containing header for backup statistics
$NBUStatsHeader += @(&quot;-&quot;*$NBUStatsHeader[2].Length) # Add separator
# ---------------------------
Clear-Host
# Set the console foreground color
[console]::ForegroundColor = &quot;White&quot;
# --------------------------- write to console
Write-Host &quot;&quot;
Write-Host &quot;============================================================&quot; -ForegroundColor &quot;Yellow&quot;
Write-Host &quot;                  NetBackup - Daily Report&quot;
Write-Host &quot;============================================================&quot; -ForegroundColor &quot;Yellow&quot;
Write-Host &quot;&quot;
Write-Host &quot;&quot;
# ---------------------------
$Now = Get-date # Store current date and time
If (($Now.DayOfWeek -eq &quot;Tuesday&quot;) -OR ($Now.DayOfWeek -eq &quot;Wednesday&quot;) -OR ($Now.DayOfWeek -eq &quot;Thursday&quot;) -OR ($Now.DayOfWeek -eq &quot;Friday&quot;)) # For every weekday except monday
{
 $StartDate = &quot;{0:MM\/dd\/yyyy $StartTime}&quot; -f ($Now.AddDays(-1)) # set the startdate back one day, using the previously set starttime
}
If ($Now.DayOfWeek -eq &quot;Monday&quot;) # For every monday
{
 $StartDate = &quot;{0:MM\/dd\/yyyy $StartTime}&quot; -f ($Now.AddDays(-3)) # set the startdate back three days (to encompass the weekend), using the previously set starttime
}
$EndDate = &quot;{0:MM\/dd\/yyyy $Endtime}&quot; -f ($Now) # set the enddate to today, using the previously set endtime
# ---------------------------
$NbuPolicyList = Invoke-Expression &quot;bppllist&quot; # Using NBU cmd get a list of all policies
ForEach ($Policy in $NbuPolicyList) # Process all listed policies
{
 # ---
 $OKHeader = @(&quot;&quot;;&quot;Successful jobs during the $Policy backup&quot;) # header to add to below declared array
 $OKHeader += @(&quot;-&quot;*$OKHeader[1].Length) # Add variable length horizontal separator
 $JobOK = New-Object System.Collections.ArrayList # Array to contain successful jobs
 $JobOK.Add($OKHeader) | Out-Null # Add header to array
 $JobOK.Add($JobHeader) | Out-Null # Add general header to array
 $JobOKCount=1 # Record count in array
 # ---
 $PartialHeader = @(&quot;&quot;;&quot;Partially Successful jobs during the $Policy backup&quot;) # header to add to below declared array
 $PartialHeader += @(&quot;-&quot;*$PartialHeader[1].Length) # Add variable length horizontal separator
 $JobPartial = New-Object System.Collections.ArrayList # Array to contain partially successful jobs
 $JobPartial.Add($PartialHeader) | Out-Null # Add header to array
 $JobPartial.Add($JobHeader) | Out-Null # Add general header to array
 $JobPartialCount=1 # Record count in array
 # ---
 $FailHeader = @(&quot;&quot;;&quot;Failed jobs during the $Policy backup&quot;) # header to add to below declared array
 $FailHeader += @(&quot;-&quot;*$FailHeader[1].Length) #Add variable length horizontal separator
 $JobFail = New-Object System.Collections.ArrayList # Array to contain failed jobs
 $JobFail.Add($FailHeader) | Out-Null # Add header to array
 $JobFail.Add($JobHeader) | Out-Null # Add general header to array
 $JobFailCount=1 # Record count in array
 # ---
 If ($Policy.Length -gt 16) # If policy name is longer than 16 chars
 {
  $PolicyFilter = $Policy.SubString(0,16).Trim() # Trim policy name down to 16 chars
 }
 Else
 {
  $PolicyFilter = $Policy
 }
 $PolicyDetails = Invoke-Expression &quot;bppllist $Policy -L&quot; # Using NBU cmd get policy details
 $PolicyActive =  $PolicyDetails | Select-String &quot;Active&quot; | %{$_.ToString().SubString(19).Trim()} # From policy details, get the policy status
 $PolicyType = $PolicyDetails | Select-String &quot;Policy Type:&quot; | %{$_.ToString().SubString(19).Trim()} # From policy details, get the policy type
 If ($PolicyActive -eq &quot;yes&quot;) # If policy is active, process it, inactive policies are not processed
 {
  $PolicyClientList = $PolicyDetails | select-String &quot;Client/HW/OS/Pri:&quot; | Sort-Object # From policy details, get the list of clients
  ForEach ($ClientStr in $PolicyClientList)
  {
   $Client = $ClientStr.ToString().Split()[2] # Extrapolate Client name
   If ($Client.Length -gt $ClientStringLength) # For report makeup check lenght of the string
   {
	$ClientStringLength = $Client.Length+3 # If necessary add three characters whitespace to the string
   }
   $ClientJobList = Invoke-Expression &quot;bperror.exe -client $Client -U -backstat -s info -d $StartDate -e $EndDate 2&gt;&amp;1&quot;  | Select-String &quot; $PolicyFilter&quot; # Using NBU cmd get the jobs for currently processing client and narrow the selection of jobs to the currently processing policy
   #-- Start Statistics gathering for the currently processing policy and the currently processing client
   $ClientImages = Invoke-Expression &quot;bpimagelist -client $Client -d $StartDate -e $EndDate 2&gt;&amp;1&quot; | Select-String $Policy # Using NBU cmd get backup images for the currently processing client narrowed by the currently processing policy
   If (($ClientImages) -AND ($ClientImages.GetType().Name -ne &quot;ErrorRecord&quot;)) # If backup images are available
   {
	ForEach ($Image in $ClientImages) # Process each backup image
    {
	 $Image = $Image.ToString().Split() # Convert the current backup image line to a string and split the string at every space
	 [Int32]$Files = $Image[19] # From the split string, get the number of files at row 19
	 [Int32]$KBs = $Image[18] # From the split string, get the KiloBytes at row 18
	 [Int32]$JobStart = $Image[13] # From the split string, get the start time (relative to the NBU_BaseTime in seconds) at row 13
     [Int32]$JobEnd = ($JobStart+[Int32]$Image[14]) #  From the split string, add the elapsed seconds at row 14 to the jobstart variable to get the endtime (relative to the NBU_BaseTime in seconds)
	 $JobStartTime = $NBU_BaseTime.AddSeconds($JobStart) # Add the seconds from jobstart to NBU_BaseTime to get a datetime object for starttime
     $JobEndTime = $NBU_BaseTime.AddSeconds($JobEnd) # Add the seconds from jobend to NBU_BaseTime to get a datetime object for endtime
	 $ElapsedTime = New-TimeSpan $JobStartTime $JobEndTime # Get a timespan for the elapsed time
	 $TotalElapsedTime = ($TotalElapsedTime+$ElapsedTime) # Add the timespan to the total elapsed time for this policy
	 $TotalFiles = ($TotalFiles+$Files) # Add the number of files to the total file count for this policy
	 $TotalKB = ($TotalKB+$KBs) # Add the KiloBytes to the total KiloBytes for this policy
	}
	$TotalKB = ($TotalKB*1024) # mulitply by 1024
	$GrandTotalKB = ($GrandTotalKB+$TotalKB) # Add totalkb to GrandTotalKB, aggregate for all policies
	$GrandTotalFiles = ($GrandTotalFiles+$TotalFiles) # Add totalfiles to GrandTotalFiles, aggregate for all policies
	If ($TotalKB -lt 1048576) # Format TotalKB to reflect:
	{
	 $TotalKBs = &quot;{0:N} KB&quot; -f $($TotalKB/1KB) # KiloBytes or,
	}
    If (($TotalKB -ge 1048576) -AND ($TotalKB -lt 1073741824))
	{
	 $TotalKBs = &quot;{0:N} MB&quot; -f $($TotalKB/1MB) # MegaBytes or,
	}
	If (($TotalKB -ge 1073741824) -AND ($TotalKB -lt 1099511627776))
 	{
	 $TotalKBs = &quot;{0:N} GB&quot; -f $($TotalKB/1GB) # GigaBytes or,
	}
	If ($TotalKB -ge 1099511627776)
    {
     $TotalKBs = &quot;{0:N} TB&quot; -f $($TotalKB/1TB) # TeraBytes
    }
    $TotalFiles = &quot;{0:N0}&quot; -f $TotalFiles # format the number for further processing
    $StatString = ($Client+&quot; &quot;*($ClientStringLength-$Client.Length))+($Policy+&quot; &quot;*($PolicyStringLength-$Policy.Length))+($TotalFiles+&quot; &quot;*($FileStringLength-$TotalFiles.Length))+($TotalKBs+&quot; &quot;*($KBStringLength-$TotalKBs.Length))+&quot;$TotalElapsedTime&quot; # Create a String per server, per policy with the following fields: CLIENT,POLICY,FILES,SIZE,ELAPSED
    $NBUStats += @($StatString) # Add the above string to the NBUStats array
	$TotalFiles = 0 # Reset variable
    $TotalKB = 0 # Reset variable
	$TotalKBs = 0 # Reset variable
	Clear-variable TotalElapsedTime # Reset variable
   }
   # --- End Statistics gathering
   If ($ClientJobList) # Process backup jobs for currently processing client if they are available
   {
	$ClientReported += @(&quot;$Client`t$PolicyType&quot;) # Add the client and policy name to array for checking
	ForEach ($Job in $ClientJobList) # Process each job
    {
     $Job = [String]$Job # Stringify the job
	 $StatusCode = $Job.SubString(0,7).Trim() # From string $job, extract statuscode
     If (($StatusCode -eq &quot;STATUS&quot;) -OR (!$StatusCode)) # If $statuscode equals &quot;status&quot; or is emtpy
     {
      Continue # Skip this job
     }
     Else
     {
      $StatusCode = [Int]$StatusCode # Set statuscode as integer
     }
     $JobClient = $Job.SubString(7,14).Trim() # From string $job, extract clientname
     $JobPolicy = $Job.SubString(21,17).Trim() # From string $job, extract policyname
     $JobSchedule = $Job.SubString(38,11).Trim() # From string $job, extract schedule
	 If ($JobSchedule -match &quot;Default&quot;) # If schedule matches &quot;default&quot;,
	 {
	  Continue # skip this job
	 }
	 If ($UsedPolSched -notcontains &quot;$Policy,$JobSchedule&quot;) # If this policy and schedule are not yet registered in the array,
	 {
	  $UsedPolSched += @(&quot;$Policy,$JobSchedule&quot;) # Register this policy and schedule in the array
	 }
     $JobNBServer = $Job.SubString(49,12).Trim() # From string $job, extract NBU master server
     $JobTimeComplete = $Job.SubString(61).Trim() # From string $job, extract time completed
	 # ---
	 $ReadOKClient = $JobOK[$JobOKCount].SubString(7,14).Trim() # From the $JobOK array read the $JobOKCount row and extract client name
	 $ReadOKPolicy = $JobOK[$JobOKCount].SubString(21,17).Trim() # From the $JobOK array read the $JobOKCount row and extract policy name
	 $ReadOKSchedule = $JobOK[$JobOKCount].SubString(38,11).Trim() # From the $JobOK array read the $JobOKCount row and extract schedule
	 $ReadOKTimeStamp = $JobOK[$JobOKCount].SubString(61).Trim() # From the $JobOK array read the $JobOKCount row and extract time completed
	 # ---
	 $ReadPartialClient = $JobPartial[$JobPartialCount].SubString(7,14).Trim() # From the $JobPartial array read the $JobPartialCount row and extract client name
	 $ReadPartialPolicy = $JobPartial[$JobPartialCount].SubString(21,17).Trim() # From the $JobPartial array read the $JobPartialCount row and extract policy name
	 $ReadPartialSchedule = $JobPartial[$JobPartialCount].SubString(38,11).Trim() # From the $JobPartial array read the $JobPartialCount row and extract schedule
	 $ReadPartialTimeStamp = $JobPartial[$JobPartialCount].SubString(61).Trim() # From the $JobPartial array read the $JobPartialCount row and extract time completed
	 # ---
	 $ReadFailClient = $JobFail[$JobFailCount].SubString(7,14).Trim() # From the $JobFail array read the $JobFailCount row and extract client name
	 $ReadFailPolicy = $JobFail[$JobFailCount].SubString(21,17).Trim() # From the $JobFail array read the $JobFailCount row and extract policy name
	 $ReadFailSchedule = $JobFail[$JobFailCount].SubString(38,11).Trim() # From the $JobFail array read the $JobFailCount row and extract schedule
	 $ReadFailTimeStamp = $JobFail[$JobFailCount].SubString(61).Trim() # From the $JobFail array read the $JobFailCount row and extract time completed
	 # --- Write progress to console
     $ClntStr = $Client+&quot; &quot;*($ClientStringLength-$Client.Length) # For interactive use only, get client name and add whitespace
	 Write-Host &quot; Client: &quot; -NoNewLine # Write to console,
	 Write-Host $ClntStr -NoNewLine -ForeGroundColor &quot;Cyan&quot; # The currently processing client
	 Write-Host &quot;Status: &quot; -NoNewLine # Write to console,
	 Switch ($StatusCode)
	 {
	  0
	  {
	   Write-Host $StatusCode -NoNewLine -ForeGroundColor &quot;Green&quot; # Status successful
	  }
	  1
	  {
	   Write-Host $StatusCode -NoNewLine -ForeGroundColor &quot;Yellow&quot; # Status partially successful
	  }
	  Default
	  {
	   Write-Host $StatusCode -NoNewLine -ForeGroundColor &quot;Red&quot; # Status failed
	  }
	 }
	 Write-Host &quot;`tPolicy: &quot; -NoNewLine # Write to console,
	 Write-Host $Policy -ForeGroundColor &quot;Cyan&quot; # The currently processing clients' policy
	 # ---
	 Switch ($StatusCode) # Process jobs by statuscode
	 {
	  {$StatusCode -eq 0} # If statuscode equals 0 (Successful), process job
	  {
	   If ($JobOKCount -eq 1) # If row count of the $JobOK array equals 1
	   {
	    $JobOK.Add($Job) | Out-Null # Add the currently processing job values to the array
	    $JobOKCount++ # Increment the row count
	   }
	   ElseIf (($JobClient -eq $ReadOKClient) -AND ($JobPolicy -eq $ReadOKPolicy) -AND ($JobSchedule -eq $ReadOKSchedule) -AND ($JobTimeComplete -ge $ReadOKTimeStamp)) # If Client, Policy and Schedule are the same, but the time completed is greater than the values read from the $JobOK array,
	   {
	    $JobOK[$JobOKCount] = $Job # Replace the read values with the currently processing job values
	   }
	   Else
	   {
	    $JobOK.Add($Job) | Out-Null # If all above logic is not true, add the currently processing job values to the array
	    $JobOKCount++ # Increment the row count
	   }
	   If (($JobPartialCount -gt 1) -AND ($JobClient -eq $ReadPartialClient) -AND ($JobPolicy -eq $ReadPartialPolicy) -AND ($JobSchedule -eq $ReadPartialSchedule) -AND ($JobTimeComplete -ge $ReadPartialTimeStamp)) # Check if client, policy and schedule are the same in the last row of the $JobPartial Array, if currently processing job time completed is greater than the value of time completed in $JobPartial,
	   {
	    $JobPartial.Remove($JobPartial[$JobPartialCount]) | Out-Null # Remove the read values from the array
	    $JobPartialCount-- # Decrement the row count
	   }
	   If (($JobFailCount -gt 1) -AND ($JobClient -eq $ReadFailClient) -AND ($JobPolicy -eq $ReadFailPolicy) -AND ($JobSchedule -eq $ReadFailSchedule) -AND ($JobTimeComplete -ge $ReadFailTimeStamp)) # Check if client, policy and schedule are the same in the last row of the $JobFail Array, if currently processing job time completed is greater than the value of time completed in $JobFail,
	   {
	    $JobFail.Remove($JobFail[$JobFailCount]) | Out-Null # Remove the read job values from the array
	    $JobFailCount-- # Decrement the row count
	   }
	  }
	  {$StatusCode -eq 1} # If statuscode equals 1 (Partially successful), process job
	  {
	   If ($JobPartialCount -eq 1) # If row count of the $JobPartial array equals 1
	   {
	    $JobPartial.Add($Job) | Out-Null # Add the currently processing job values to the array
	    $JobPartialCount++ # Increment the row count
	   }
	   Else
	   {
	    If (($JobClient -eq $ReadPartialClient) -AND ($JobPolicy -eq $ReadPartialPolicy) -AND ($JobSchedule -eq $ReadPartialSchedule) -AND ($JobTimeComplete -ge $ReadPartialTimeStamp)) # If Client, Policy and Schedule are the same, but the time completed is greater than the values read from the $JobPartial array,
	    {
	     $JobPartial[$JobPartialCount] = $Job # Replace the read values with the currently processing job values
	    }
	    Else
	    {
	     $JobPartial.Add($Job) | Out-Null # If all above logic is not true, add the currently processing job values to the array
	     $JobPartialCount++ # Increment the row count
	    }
	   }
	   If (($JobOKCount -gt 1) -AND ($JobClient -eq $ReadOKClient) -AND ($JobPolicy -eq $ReadOKPolicy) -AND ($JobSchedule -eq $ReadOKSchedule) -AND ($JobTimeComplete -ge $ReadOKTimeStamp)) # Check if client, policy and schedule are the same in the last row of the $JobOK Array, if currently processing job time completed is greater than the value of time completed in $JobOK,
	   {
	    $JobOK.Remove($JobOK[$JobOKCount]) | Out-Null # Remove the read job $JobOK values from the array
	    $JobOKCount-- # Decrement the row count
	   }
	   If (($JobFailCount -gt 1) -AND ($JobClient -eq $ReadFailClient) -AND ($JobPolicy -eq $ReadFailPolicy) -AND ($JobSchedule -eq $ReadFailSchedule) -AND ($JobTimeComplete -ge $ReadFailTimeStamp)) # Check if client, policy and schedule are the same in the last row of the $JobFail Array, if currently processing job time completed is greater than the value of time completed in $JobFail,
	   {
	    $JobFail.Remove($JobFail[$JobFailCount]) | Out-Null # Remove the read job $JobFail values from the array
	    $JobFailCount-- # Decrement the row count
	   }
	  }
	  {$StatusCode -gt 1} # If statuscode greater than 1 (Failed), process job
	  {
	   If ($JobFailCount -eq 1)
	   {
	    $JobFail.Add($Job) | Out-Null # Add the currently processing job values to the array
	    $JobFailCount++ # Increment the row count
	   }
	   Else
	   {
	    If (($JobClient -eq $ReadFailClient) -AND ($JobPolicy -eq $ReadFailPolicy) -AND ($JobSchedule -eq $ReadFailSchedule) -AND ($JobTimeComplete -ge $ReadFailTimeStamp)) # If Client, Policy and Schedule are the same, but the time completed is greater than the values read from the $JobFail array,
	    {
	     $JobFail[$JobFailCount] = $Job # Replace the read values with the currently processing job values
	    }
	    Else
	    {
	     $JobFail.Add($Job) | Out-Null # If all above logic is not true, add the currently processing job values to the array
	     $JobFailCount++ # Increment the row count
	    }
	   }
	   If (($JobOKCount -gt 1) -AND ($JobClient -eq $ReadOKClient) -AND ($JobPolicy -eq $ReadOKPolicy) -AND ($JobSchedule -eq $ReadOKSchedule) -AND ($JobTimeComplete -ge $ReadOKTimeStamp)) # Check if client, policy and schedule are the same in the last row of the $JobOK Array, if currently processing job time completed is greater than the value of time completed in $JobOK,
	   {
	    $JobOK.Remove($JobOK[$JobOKCount]) | Out-Null # Remove the read job $JobOK values from the array
	    $JobOKCount-- # Decrement the row count
	   }
	   If (($JobPartialCount -gt 1) -AND ($JobClient -eq $ReadPartialClient) -AND ($JobPolicy -eq $ReadPartialPolicy) -AND ($JobSchedule -eq $ReadPartialSchedule) -AND ($JobTimeComplete -ge $ReadPartialTimeStamp)) # Check if client, policy and schedule are the same in the last row of the $JobPartial Array, if currently processing job time completed is greater than the value of time completed in $JobPartial,
	   {
	    $JobPartial.Remove($JobPartial[$JobPartialCount]) | Out-Null # Remove the read job $JobPartial values from the array
	    $JobPartialCount-- # Decrement the row count
	   }
	  }
	 }
	}
   }
   Else # If $ClientJobList is empty
   {
    If ($ClientReported -contains &quot;$Client`t$PolicyType&quot;) # If client and schedule are present in the $ClientReported array
	{
	 Continue # Continue
	}
	Else # If client and schedule are NOT present in the $ClientReported array (line 195)
	{
     $CNRString = ($Client+&quot; &quot;*($ClientStringLength-$Client.Length))+($Policy+&quot; &quot;*($PolicyStringLength-$Policy.Length)) # Format a string with client and policy values
	 $ClientNotReported += @($CNRString) # Add the string value to the $ClientNotReported array
     Continue
	}
   }
  }
  If ($JobOK.Count -gt 2) # If the row count of $JobOK array is greater than 2,
  {
   $TotalOK += $JobOK # Add the values of $JobOK to $TotalOK
   If ($JobOK) {Clear-Variable JobOK} # Clear the array in preparation of processing the next policy
  }
  If ($JobPartial.Count -gt 2) # If the row count of $JobPartial array is greater than 2,
  {
   $TotalPartial += $JobPartial # Add the values of $JobPartial to $TotalPartial
   If ($JobPartial) {Clear-Variable JobPartial} # Clear the array in preparation of processing the next policy
  }
  If ($JobFail.Count -gt 2) # If the row count of $JobFail array is greater than 2,
  {
   $TotalFail += $JobFail # Add the values of $JobFail to $TotalFail
   If ($JobFail) {Clear-Variable JobFail} # Clear the array in preparation of processing the next policy
  }
 }
}
# ---
$NBUStats = $NBUStats | Sort-Object # Sort the NBUStats array
$GrandTotalFiles = &quot;{0:N0}&quot; -f $GrandTotalFiles # Format the value of GrandTotalFiles
If ($GrandTotalKB -lt 1048576) # Format GrandTotalKB to reflect,
{
 $GrandTotalKBs = &quot;{0:N} KB&quot; -f $($GrandTotalKB/1KB) # KiloBytes,
}
If (($GrandTotalKB -gt 1048576) -AND ($GrandTotalKB -lt 1073741824))
{
 $GrandTotalKBs = &quot;{0:N} MB&quot; -f $($GrandTotalKB/1MB) # MegaBytes,
}
If ($GrandTotalKB -gt 1073741824 -AND ($GrandTotalKB -lt 1099511627776))
{
 $GrandTotalKBs = &quot;{0:N} GB&quot; -f $($GrandTotalKB/1GB) # GigaBytes, or
}
If ($GrandTotalKB -gt 1099511627776)
{
 $GrandTotalKBs = &quot;{0:N} TB&quot; -f $($GrandTotalKB/1TB) #TeraBytes
}
$NBUStats += @(&quot;&quot;;&quot;Total Files backedup: $GrandTotalFiles&quot;;&quot;Total Data backedup: $GrandTotalKBs&quot;) # Add the aggregate values to the NBUStats array
# ---------------------------
Write-Host &quot;&quot; # Write to console
Write-Host &quot;Checking for active jobs...&quot; -ForegroundColor &quot;Yellow&quot; # Write to console
$ActivejobList = Invoke-Expression &quot;bpdbjobs -ignore_parent_jobs&quot; | Select-String &quot;Active&quot; # Using NBU cmd check for active jobs at the time of reporting
$ActiveJobs = @(&quot;&quot;;&quot;Active jobs at the time of report&quot;) # Initialize ActiveJobs array and add header
$ActiveJobs += @(&quot;-&quot;*$ActiveJobs[1].Length) #Add variable length horizontal separator
If ($ActivejobList) # If ActivejobList contains data
{
 ForEach ($ActiveJob in $ActiveJobList) # Process active jobs
 {
  $ActiveClient = $Activejob.ToString().SubString(0,112) # Get the first 112 characters from the job string
  $ActiveJobs += @($ActiveClient) # Add it to the ActiveJobs array
 }
}
# ---------------------------
Write-Host &quot;&quot; # Write to console
Write-Host &quot;Getting tape media used...&quot; -ForegroundColor &quot;Yellow&quot; # Write to console
$TapeMediaUsed = @(&quot;&quot;;&quot;Tape Media used during backup&quot;) # Initialize array and add header
$TapeMediaUsed += @(&quot;-&quot;*$TapeMediaUsed[1].Length) # Add variable length horizontal separator
$ColTapeMediaUsed = Invoke-Expression &quot;bpimagelist -media -L -d $StartDate -e $EndDate&quot; # Using NBU cmd get tape media used
$TapeMediaUsedCount = ($ColTapeMediaUsed | Select-String &quot;Media ID:&quot;).Count # From ColTapeMediaUsed get the number of media used
[Int]$1=0 # Row number of &quot;Media ID&quot; in ColTapeMediaUsed
[Int]$2=2 # Row number of &quot;Last Time Written&quot; in ColTapeMediaUsed
[Int]$3=3 # Row number of &quot;Times Written&quot; in ColTapeMediaUsed
[Int]$4=4 # Row number of &quot;Kilobytes&quot; in ColTapeMediaUsed
For ($i=0; $i -le $TapeMediaUsedCount; $i++) # For the number of media used,
{
 $TapeMediaUsed += @($ColTapeMediaUsed[$1,$2,$3,$4];&quot;&quot;) # Write the values to the array
 $1=$1+7 # Increment the row number by 7 for the next media used
 $2=$2+7 # Increment the row number by 7 for the next media used
 $3=$3+7 # Increment the row number by 7 for the next media used
 $4=$4+7 # Increment the row number by 7 for the next media used
}
# ---------------------------
Write-Host &quot;&quot; # Write to console
Write-Host &quot;Getting disk storage units used...&quot; -ForegroundColor &quot;Yellow&quot; # Write to console
$DiskStorageUnits = @(&quot;&quot;;&quot;Disk Storage Units Status&quot;) # Initialize array and add header
$DiskStorageUnits += @(&quot;-&quot;*$DiskStorageUnits[1].Length) # Add variable length horizontal separator
$ColDiskStorageUnits = Invoke-Expression &quot;nbdevquery -listdv -stype BasicDisk -U&quot; # Using NBU cmd to get disk storageunits
ForEach ($PolSched in $UsedPolSched) # Process policies/schedules used during backup operation (see line 215,74) to extract disk storageunit usage
{
 $PolSched=$PolSched.Split(&quot;,&quot;) # Split the $polSched string at the comma
 $UsedPolicy = $PolSched[0] # From the split string extract the Policyname
 $UsedSchedule = $PolSched[1] # From the split string extract the Schedule
 $UsedPolicyDetails = Invoke-Expression &quot;bppllist $UsedPolicy -L&quot; # Using NBU cmd get currently processing policy details
 $ScheduleStartLine = ($UsedPolicyDetails | Select-String &quot;Schedule:.*$UsedSchedule&quot;).LineNumber-1 # From the policy details extract the linenumber where the used schedule details begin
 $Schedule = $UsedPolicyDetails[$ScheduleStartLine..$Usedpolicydetails.Count] # From above acquired linenumber select all lines to the last line of the policy details
 Try
 {
  $ScheduleEndLine = ($Schedule | Select-String &quot;Schedule&quot;)[1].LineNumber-2 # Check if multiple schedule details are selected, by selecting the word &quot;Schedule&quot;. If true acquire the linenumber of the second instance of the word &quot;Schedule&quot; and extract 2 lines
 }
 Catch
 {
  $ScheduleEndLine = $Usedpolicydetails.Count # If the above statement fails, it is the last schedule description in policy details, so the last line of the policydetails is also the last line of the schedule description
 }
 $Schedule = $Schedule[0..$ScheduleEndLine] # Final selection to acquire the schedule description
 $StorageUnitString = ($Schedule | Select-String &quot;Residence:&quot;).ToString().SubString(19).Trim() # From the schedule details acquire the &quot;residence&quot; value
 If ($ColDiskStorageUnits -contains &quot;Disk Pool Name      : $StorageUnitString&quot;) # If previously collected disk storageunits data, contains the StorageUnitString,
 {
  [Int]$ColStorageUnitLineNumber = ($ColDiskStorageUnits | Select-String &quot;Disk Pool Name .*$StorageUnitString&quot;).LineNumber-1 # Get the linenumber for the line that contains &quot;Disk Pool Name .*$StorageUnitString&quot; and extract 1 to compensate for the fact that powershell starts counting at 0 instead of 1
  [Int]$1=$ColStorageUnitLineNumber # linenumber for &quot;Disk Pool Name&quot;
  [Int]$2=$ColStorageUnitLineNumber+4 # linenumber for &quot;Total Capacity&quot;
  [Int]$3=$ColStorageUnitLineNumber+5 # linenumber for &quot;Free Space&quot;
  [Int]$4=$ColStorageUnitLineNumber+6 # linenumber for &quot;Use%&quot;
  [Int]$5=$ColStorageUnitLineNumber+7 # linenumber for &quot;Status&quot;
  If ($DiskStorageUnits -notcontains &quot;Disk Pool Name      : $StorageUnitString&quot;) # If array DiskStorageUnits does not contain a line like &quot;Disk Pool Name      : $StorageUnitString&quot;,
  {
   $DiskStorageUnits += @($ColDiskStorageUnits[$1,$2,$3,$4,$5];&quot;&quot;) # Add the disk storageunit details to the array
  }
 }
}
# ---------------------------
Write-Host &quot;&quot; # Write to console
Write-Host &quot;Creating report...&quot; -ForegroundColor &quot;Yellow&quot; # Write to console
Set-Content $OutputStr &quot;&quot; # initialize the output file
$ReportStart = &quot;{0:dddd dd\-MM\-yyyy H:mm:ss}&quot; -f $Now # Format date and time for the script start timestamp
If (($Now.DayOfWeek -eq &quot;Tuesday&quot;) -OR ($Now.DayOfWeek -eq &quot;Wednesday&quot;) -OR ($Now.DayOfWeek -eq &quot;Thursday&quot;) -OR ($Now.DayOfWeek -eq &quot;Friday&quot;))  # For every weekday except monday
{
 $ReportingDate = &quot;{0:dddd dd\-MM\-yyyy}&quot; -f ($Now.AddDays(-1)) # Set the date back one day and format the date for the date of the backup operation
}
If ($Now.DayOfWeek -eq &quot;Monday&quot;) # For every monday
{
 $ReportingDate = &quot;{0:dddd dd\-MM\-yyyy}&quot; -f ($Now.AddDays(-3)) # Set the date back three days and format the date for the date of the backup operation
}
$ReportHeader = @(&quot;Report Generated on $env:COMPUTERNAME, $ReportStart&quot;;&quot;&quot;;&quot;Backup report for $ReportingDate&quot;) # Array with multiline header
Add-Content $OutputStr $ReportHeader # Add the header to the output file
$ReportParts = @($TotalFail,$TotalPartial,$TotalOK) # Array containing the names of the arrays with the overall results of the backup operation
ForEach ($Part in $ReportParts) # For each array,
{
 If ($Part.Count -ge 3) # If the line count is greater than 3,
 {
  Add-Content $OutputStr $Part # Add the array to the output file
 }
}
If ($ActiveJobs.Count -gt 4) # If the line count is greater than 3,
{
 Add-Content $OutputStr $ActiveJobs # Add the array to the output file
}
If ($ClientNotReported.Count -gt 4) # If the line count is greater than 4,
{
 Add-Content $OutputStr $ClientNotReported # Add the array to the output file
}
If ($NBUStats.Count -ge 1) # If the line count is greater than 4,
{
 Add-Content $OutputStr $NBUStatsHeader # Add the header array to the output file
 Add-Content $OutputStr $NBUStats # Add the array to the output file
}
If ($TapeMediaUsed.Count -gt 3) # If the line count is greater than 3,
{
 Add-Content $OutputStr $TapeMediaUsed # Add the array to the output file
}
If ($DiskStorageUnits.Count -gt 3) # If the line count is greater than 3,
{
 Add-Content $OutputStr $DiskStorageUnits # Add the array to the output file
}
Add-Content $OutputStr &quot;&quot; # Add blank line to the output file
Add-Content $OutputStr &quot;--------------------------------------------------&quot; # Add a separator to the output file
$ReportEnd = &quot;{0:dddd dd\-MM\-yyyy H:mm:ss}&quot; -f (Get-Date) # Get and format the current date and time
$ReportFooter = @(&quot;Report finished on $env:COMPUTERNAME, $ReportEnd&quot;;&quot;&quot;) # Array with multiline footer
Add-Content $OutputStr $ReportFooter # Add the footer to the output file
# ---------------------------
Write-Host &quot;&quot; # Write to console
Write-Host &quot;Sending e-mail...&quot; -ForegroundColor &quot;Yellow&quot; # Write to console
$MailBody = Get-Content $OutputStr | %{ &quot;$_`r&quot; } # Read and parse the contents of the output file
$CcRecipients = Get-Content ($OutputPth + &quot;\&quot; + $CC) # read the contents of the file containing CC recipients
$Attachment = $OutputStr # declare variable containing the path to the output file
$Msg = New-Object Net.Mail.MailMessage # Create new e-mail message object
$Att = New-Object Net.Mail.Attachment($Attachment) # Create new attachment object
$Smtp = New-Object Net.Mail.SmtpClient($SmtpServer) # Create new smtp client object
$Msg.From = $From # Add from address to the message
$Msg.To.Add($To) # Add to address to the message
$Msg.CC.Add($CcRecipients) # Add CC address(es) to the message
$Msg.Subject = &quot;Backup report for last $ReportingDate&quot; # Set the message subject
$Msg.Body = $MailBody # Add the bodytext to the message
$Msg.Attachments.Add($Att) # Add the attachment to the message
$Smtp.Send($Msg) # Send the message
$Att.Dispose() # Clear memory of the attachment
# ---------------------------
#Write-EventLog -LogName &quot;Scripts&quot; -Source &quot;Reporting_Script&quot; -EventID 30 -Message &quot;Backup Report: Mail Sent&quot; -EntryType &quot;Information&quot;
# ---------------------------
# reset the colors back to default
[console]::ResetColor()

@@ End of Script
@@ Below is an example of the actual output

Report Generated on NBUSRV, monday 06-12-2010 8:30:07

Backup report for friday 03-12-2010

Failed jobs during the FileBackup backup
----------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
156    SRV001        FileBackup       Week       NBUSRV      12/04/2010 15:17:48 

Failed jobs during the Linux_filebackup2 backup
-----------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
 71    SRV002        Linux_filebackup Week       NBUSRV      12/03/2010 18:17:54 

Partially Successful jobs during the FileBackup backup
------------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  1    NBUSRV        FileBackup       Week       NBUSRV      12/03/2010 23:56:46 

Partially Successful jobs during the FileBackup2 backup
-------------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  1    SRV003        FileBackup2      Week       NBUSRV      12/03/2010 20:44:03 

Partially Successful jobs during the NAS_FileBackup_SQL_WWW backup
------------------------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  1    SRV004        NAS_FileBackup_S Full       NBUSRV      12/04/2010 12:26:59 
  1    SRV005        NAS_FileBackup_S Full       NBUSRV      12/04/2010 00:02:49 

Partially Successful jobs during the PRTG backup
------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  1    SRV006        PRTG             Full       NBUSRV      12/04/2010 13:28:54 

Successful jobs during the CatalogBackup backup
-----------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    NBUSRV        CatalogBackup    Daily      NBUSRV      12/06/2010 08:11:56 

Successful jobs during the ExchangeBackup backup
------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV003        ExchangeBackup   Week       NBUSRV      12/04/2010 19:51:29 

Successful jobs during the FileBackup backup
--------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV007        FileBackup       Week       NBUSRV      12/04/2010 14:21:31 
  0    SRV008        FileBackup       Week       NBUSRV      12/03/2010 20:54:54 
  0    SRV009        FileBackup       Week       NBUSRV      12/04/2010 01:40:42 
  0    SRV010        FileBackup       Week       NBUSRV      12/04/2010 01:33:09 
  0    SRV004        FileBackup       Week       NBUSRV      12/03/2010 23:57:03 
  0    SRV011        FileBackup       Week       NBUSRV      12/04/2010 01:16:40 
  0    SRV012        FileBackup       Week       NBUSRV      12/04/2010 01:52:23 
  0    SRV013        FileBackup       Week       NBUSRV      12/04/2010 18:11:10 
  0    SRV014        FileBackup       Week       NBUSRV      12/04/2010 01:17:05 
  0    SRV015        FileBackup       Week       NBUSRV      12/04/2010 01:14:31 
  0    SRV016        FileBackup       Week       NBUSRV      12/04/2010 13:20:02 
  0    SRV017        FileBackup       Week       NBUSRV      12/04/2010 01:36:57 
  0    SRV005        FileBackup       Week       NBUSRV      12/04/2010 11:25:06 

Successful jobs during the FileBackup2 backup
---------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV018        FileBackup2      Week       NBUSRV      12/05/2010 14:49:59 

Successful jobs during the Linux_filebackup backup
--------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV019        Linux_filebackup Week       NBUSRV      12/03/2010 18:09:46 
  0    SRV020        Linux_filebackup Week       NBUSRV      12/03/2010 20:55:21 
  0    SRV021        Linux_filebackup Week       NBUSRV      12/03/2010 18:16:15 

Successful jobs during the MailboxBackup backup
-----------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV003        MailboxBackup    Week       NBUSRV      12/04/2010 02:22:32 

Successful jobs during the NAS_Daily_SRV018 backup
--------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV018        NAS_Daily_SRV018 Full       NBUSRV      12/05/2010 06:19:59 

Successful jobs during the NAS_FileBackup_Citrix backup
-------------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV015        NAS_FileBackup_C Week       NBUSRV      12/03/2010 19:49:17 
  0    SRV016        NAS_FileBackup_C Week       NBUSRV      12/03/2010 19:48:46 
  0    SRV017        NAS_FileBackup_C Week       NBUSRV      12/03/2010 19:49:29 

Successful jobs during the NAS_FileBackup_DCs backup
----------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV007        NAS_FileBackup_D Week       NBUSRV      12/03/2010 20:55:59 
  0    SRV008        NAS_FileBackup_D Week       NBUSRV      12/03/2010 20:33:49 

Successful jobs during the NAS_FileBackup_SQL_WWW backup
--------------------------------------------------------
STATUS CLIENT        POLICY           SCHED      SERVER      TIME COMPLETED
  0    SRV009        NAS_FileBackup_S Full       NBUSRV      12/04/2010 00:31:03 
  0    SRV010        NAS_FileBackup_S Full       NBUSRV      12/04/2010 10:21:18 
  0    SRV001        NAS_FileBackup_S Full       NBUSRV      12/03/2010 23:42:43 
  0    SRV013        NAS_FileBackup_S Full       NBUSRV      12/04/2010 00:23:24 

Servers that did not (yet) report any activity
----------------------------------------------
CLIENT         POLICY                   
SRV022         FileBackup2            
SRV023         ExchangeBackup           
SRV024         FileBackup                        
  
BACKUP STATISTICS
CLIENT         POLICY                   FILES     SIZE        ELAPSED   
------------------------------------------------------------------------
NBUSRV         CatalogBackup            7.209     7,97 GB     00:11:29
NBUSRV         FileBackup               32.870    25,60 GB    05:04:51
SRV001         FileBackup               312.592   118,36 GB   05:25:18
SRV001         NAS_FileBackup_SQL_WWW   189.777   84,10 GB    03:45:15
SRV002         Linux_filebackup2        98.381    3,81 GB     00:20:35
SRV003         ExchangeBackup           9         247,01 GB   09:59:45
SRV003         FileBackup2              51.021    9,15 GB     00:57:07
SRV003         MailboxBackup            192.399   5,45 GB     01:22:26
SRV004         FileBackup               111.210   56,53 GB    06:04:05
SRV004         NAS_FileBackup_SQL_WWW   61.901    28,16 GB    01:20:48
SRV005         FileBackup               102.547   185,43 GB   06:44:37
SRV005         NAS_FileBackup_SQL_WWW   43.621    78,96 GB    03:52:15
SRV006         PRTG                     48.992    13,36 GB    01:16:57
SRV007         FileBackup               74.042    27,96 GB    03:01:21
SRV007         NAS_FileBackup_DCs       37.012    13,92 GB    01:06:18
SRV008         FileBackup               76.314    14,05 GB    01:47:51
SRV008         NAS_FileBackup_DCs       38.157    7,00 GB     00:40:53
SRV009         FileBackup               135.311   182,96 GB   11:30:10
SRV009         NAS_FileBackup_SQL_WWW   74.393    91,12 GB    02:18:39
SRV010         FileBackup               118.870   155,18 GB   08:16:04
SRV010         NAS_FileBackup_SQL_WWW   67.660    57,78 GB    01:27:28
SRV011         FileBackup               29.968    5,80 GB     00:52:46
SRV012         FileBackup               84.197    11,41 GB    01:20:36
SRV013         FileBackup               164.644   259,76 GB   10:42:15
SRV013         NAS_FileBackup_SQL_WWW   81.413    129,37 GB   04:12:44
SRV014         FileBackup               34.022    5,87 GB     00:51:19
SRV015         FileBackup               60.459    16,21 GB    01:10:15
SRV015         NAS_FileBackup_Citrix    30.224    8,07 GB     00:22:53
SRV016         FileBackup               73.496    39,25 GB    01:48:33
SRV016         NAS_FileBackup_Citrix    36.742    19,55 GB    00:26:46
SRV017         FileBackup               195.726   47,95 GB    02:22:57
SRV017         NAS_FileBackup_Citrix    97.863    23,88 GB    00:33:53
SRV018         FileBackup2              5.964.297 505,46 GB   1.06:46:30
SRV018         NAS_Daily_SRV018         5.921.262 496,49 GB   1.02:24:36
SRV019         Linux_filebackup         108.119   2,17 GB     00:11:06
SRV020         Linux_filebackup         127.037   6,28 GB     02:57:13
SRV021         Linux_filebackup         132.949   7,69 GB     00:18:09

Total Files backedup: 15.016.706
Total Data backedup: 2,93 TB

Tape Media used during backup
-----------------------------
Media ID:          TAPE001
Last Time Written:       4-12-2010 12:47:33 (1291463253)
Times Written:     2311 (within this time period)
Kilobytes:         838688875 (within this time period)

Media ID:          TAPE002
Last Time Written:       3-12-2010 22:16:36 (1291410996)
Times Written:     1018 (within this time period)
Kilobytes:         139560051 (within this time period)

Media ID:          TAPE003
Last Time Written:       4-12-2010 12:47:29 (1291463249)
Times Written:     501 (within this time period)
Kilobytes:         481352638 (within this time period)

Media ID:          CATALOG
Last Time Written:        6-12-2010 8:02:04 (1291618924)
Times Written:     6 (within this time period)
Kilobytes:         8360274 (within this time period)



Disk Storage Units Status
-------------------------
Disk Pool Name      : DISK_POOL1
Total Capacity (GB) : 300.00
Free Space (GB)     : 280.76
Use%                : 6
Status              : UP

Disk Pool Name      : DISK_POOL2
Total Capacity (GB) : 5526.45
Free Space (GB)     : 2460.72
Use%                : 55
Status              : UP


--------------------------------------------------
Report finished on NBUSRV, monday 06-12-2010 8:30:51
</code></pre>

</div>

    <footer class="blog-footer">
        <p>&copy; Joel &quot;Jaykul&quot; Bennett 2018</p>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>