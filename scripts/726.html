
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="foobar">
    <title>TabExpansion - PoshCode</title>

    <link rel="stylesheet" href="/css/superhero.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/highlight/arta.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" id="tabs">
                    <li class="nav-item"><a class="nav-link" href="/">Join Us!</a></li>
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video">Videos</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

	<div class="container">
		<div class="blog-header">
			<h1 class="blog-title">PoshCode</h1>
			<p class="lead blog-description">Community resources for PowerShell coders</p>
		</div>
		<div class="row">
            

<div class="blog-post">
    <h2 class="blog-post-title">TabExpansion</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2008-12-11</span> by <a class="blog-post-author">foobar</a>
    </p>

    <h3><a href="/scripts/726.ps1">download TabExpansion.ps1</a> - <a href="/scripts/722.md">parent</a></h3>
<p>Added enum expansion in method call expression
[IO.Directory]::GetAccessControl( &quot;C:&quot;,<space>au<tab><comma>ac<tab><comma>G<tab></p>
<pre><code class="language-powershell">## Tab-Completion
#################
## Please dot souce this script file.
## In first loading, it may take a several minutes, in order to generate ProgIDs and TypeNames list.
## What this can do is:
##
## [datetime]::n&lt;tab&gt;
## [datetime]::now.d&lt;tab&gt;
## $foo[0].&lt;tab&gt;
## $foo[0].n.b&lt;tab&gt;
## $function:a&lt;tab&gt;
## $env:a&lt;tab&gt;
## [System.Type].a&lt;tab&gt;
## [datetime].Assembly.a&lt;tab&gt;
## ).a&lt;tab&gt; # shows System.Type properties and methods...

## #native command name expansion
## fsu&lt;tab&gt;

## #command option name expansion (for fsutil ipconfig net powershell only)
## fsutil &lt;tab&gt;
## ipconfig &lt;tab&gt;
## net &lt;tab&gt;
## powershell &lt;tab&gt;

## #TypeNames expansion
## [Dec&lt;tab&gt;
## [Microsoft.PowerShell.Com&lt;tab&gt;
## New-Object -TypeName IO.Dir&lt;tab&gt;
## New-Object System.Management.Auto&lt;tab&gt;

## #ProgIDs expansion
## New-Object -Com shel&lt;tab&gt;

## #Enum option expansion
## Set-ExecutionPolicy &lt;tab&gt;
## Set-ExecutionPolicy All&lt;tab&gt;
## Set-ExcusionPolisy -ex &lt;tab&gt;
## Get-TraceSource¬Å@Inte&lt;tab&gt;
## iex -Err &lt;tab&gt; -wa Sil&lt;tab&gt;

## #WmiClasses expansion
## Get-WmiObject -class Win32_&lt;tab&gt;
## gwmi __Instance&lt;tab&gt;

## #Encoding expansion
## [Out-File | Export-CSV | Select-String | Export-Clixml] -enc &lt;tab&gt;
## [Add-Content | Get-Content | Set-Content} -Encoding Big&lt;tab&gt;

## #PSProvider name expansion
## [Get-Location | Get-PSDrive | Get-PSProvider | New-PSDrive | Remove-PSDrive] [-PSProvider] &lt;tab&gt;
## Get-PSProvider &lt;tab&gt;
## pwd -psp al&lt;tab&gt;

## #PSDrive name expansion
## [Get-PSDrive | New-PSDrive | Remove-PSDrive] [-Name] &lt;tab&gt;
## Get-PSDrive &lt;tab&gt;
## pwd -psd &lt;tab&gt;

## #PSSnapin name expansion
## [Add-PSSnapin | Get-PSSnapin | Remove-PSSnapin ] [-Name] &lt;tab&gt;
## Get-Command -PSSnapin &lt;tab&gt;
## Remove-PSSnapin &lt;tab&gt;
## Get-PSSnapin M&lt;tab&gt;

## #Eventlog name and expansion
## Get-Eventlog -Log &lt;tab&gt;
## Get-Eventlog w&lt;tab&gt;

## #Eventlog's entrytype expansion
## Get-EventLog -EntryType &lt;tab&gt;
## Get-EventLog -EntryType Er&lt;tab&gt;
## Get-EventLog -Ent &lt;tab&gt;

## #Service name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-Name] &lt;tab&gt;
## New-Service -DependsOn &lt;tab&gt;
## New-Service -Dep e&lt;tab&gt;
## Get-Service -n &lt;tab&gt;
## Get-Service &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;
## gsv &lt;tab&gt;

## #Service display name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-DisplayName] &lt;tab&gt;
## Get-Service -Dis &lt;tab&gt;
## gsv -Dis &lt;tab&gt;,w&lt;tab&gt;,b&lt;tab&gt;

## #Cmdlet and Topic name expansion
## Get-Help [-Name] about_&lt;tab&gt;
## Get-Help &lt;tab&gt;

## #Category name expansion
## Get-Help -Category c&lt;tab&gt;,&lt;tab&gt;

## #Command name expansion
## Get-Command [-Name] &lt;tab&gt;
## Get-Command -Name &lt;tab&gt;
## gcm a&lt;tab&gt;,&lt;tab&gt;

## #Scope expansion
## [Clear-Variable | Export-Alias | Get-Alias | Get-PSDrive | Get-Variable | Import-Alias
## New-Alias | New-PSDrive | New-Variable | Remove-Variable | Set-Alias | Set-Variable] -Scope &lt;tab&gt;
## Clear-Variable -Scope G&lt;tab&gt;
## Set-Alias  -s &lt;tab&gt;

## #Process name expansion
## [Get-Process | Stop-Process] [-Name] &lt;tab&gt;
## Stop-Process -Name &lt;tab&gt;
## Stop-Process -N pow&lt;tab&gt;
## Get-Process &lt;tab&gt;
## ps power&lt;tab&gt;

## #Trace sources expansion
## [Trace-Command | Get-TraceSource | Set-TraceSource] [-Name] &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;

## #Trace -ListenerOption expansion
## [Set-TraceSource | Trace-Command] -ListenerOption &lt;tab&gt;
## Set-TraceSource -Lis &lt;tab&gt;,n&lt;tab&gt;

## #Trace -Option expansion
## [Set-TraceSource | Trace-Command] -Option &lt;tab&gt;
## Set-TraceSource -op &lt;tab&gt;,con&lt;tab&gt;

## #ItemType expansion
## New-Item -Item &lt;tab&gt;
## ni -ItemType d&lt;tab&gt;

## #ErrorAction and WarningAction option expansion
## CMDLET [-ErrorAction | -WarningAction] &lt;tab&gt;
## CMDLET -Error s&lt;tab&gt;
## CMDLET -ea con&lt;tab&gt;
## CMDLET -wa &lt;tab&gt;

## #Continuous expansion with comma when parameter can treat multiple option
## # if there are spaces, occur display bug in the line
## # if strings contains '$' or '-', not work
## Get-Command -CommandType &lt;tab&gt;,&lt;tab&gt;&lt;tab&gt;,cm&lt;tab&gt;
## pwd -psp &lt;tab&gt;,f&lt;tab&gt;,va&lt;tab&gt;
## Get-EventLog -EntryType &lt;tab&gt;,i&lt;tab&gt;,s&lt;tab&gt;

## #Enum expansion in method call expression
## # this needs one or more spaces after left parenthesis or comma
## $str = &quot;day   night&quot;
## $str.Split( &quot; &quot;,&lt;space&gt;rem&lt;tab&gt;
## $type = [System.Type]
## $type.GetMembers(&lt;space&gt;Def&lt;tab&gt;
## [IO.Directory]::GetFiles( &quot;C:\&quot;, &quot;*&quot;,&lt;space&gt;All&lt;tab&gt;
## # this can do continuous enum expansion with comma and no spaces
## $type.GetMembers( &quot;IgnoreCase&lt;comma&gt;Dec&lt;tab&gt;&lt;comma&gt;In&lt;tab&gt;&quot;
## [IO.Directory]::GetAccessControl( &quot;C:\&quot;,&lt;space&gt;au&lt;tab&gt;&lt;comma&gt;ac&lt;tab&gt;&lt;comma&gt;G&lt;tab&gt;

### Generate ProgIDs list...
if ($_ProgID -eq $null) {
    $_HKCR = [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\&quot;)
    [Object[]] $_ProgID = $null
    foreach ( $_subkey in $_HKCR.GetSubKeyNames() )
    {
        foreach ( $_i in [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\$_subkey\ProgID&quot;) )
        {
            if ($_i -ne $null)
            {
                $_ProgID += $_i.GetValue(&quot;&quot;)
            }
        }
    }
    '$_ProgID was updated...' | Out-Host
    $_ProgID = $_ProgID|sort -Unique

    Export-Clixml -InputObject $_TypeNames -Path $PSHOME\ProgIDs.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_ProgID = Import-Clixml -Path C:\WINDOWS\system32\windowspowershell\v1.0\ProgIDs.txt;'
}

### Generate TypeNames list...

if ( $_TypeNames -eq $null ) {
    [Object[]] $_TypeNames = $null
    foreach ( $_asm in [AppDomain]::CurrentDomain.GetAssemblies() )
    {
        foreach ( $_type in $_asm.GetTypes() )
        {
            $_TypeNames += $_type.FullName
        }
    }
    '$_TypeNames was updated...' | Out-Host
    $_TypeNames = $_TypeNames | sort -Unique

    Export-Clixml -InputObject $_TypeNames -Path $PSHOME\TypeNames.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_TypeNames = Import-Clixml -Path $PSHOME\TypeNames.txt;'
}

if ( $_TypeNames_System -eq $null ) {
    [Object[]] $_TypeNames_System = $null
    foreach ( $_type in $_TypeNames -like &quot;System.*&quot; )
    {
        $_TypeNames_System += $_type.Substring(7)
    }
    '$_TypeNames_System was updated...' | Out-Host
    Export-Clixml -InputObject $_TypeNames_System -Path $PSHOME\TypeNames_System.txt
    Add-Content -Path $PSHOME\profile.ps1 -Value ';$_TypeNames_System = Import-Clixml -Path $PSHOME\TypeNames_System.txt;'
}

### Generate WMIClasses list...
if ( $_WMIClasses -eq $null ) {
    [Object[]] $_WMIClasses = $null
    foreach ( $_class in gwmi -List )
    {
        $_WMIClasses += $_class.Name
    }
    $_WMIClasses = $_WMIClasses | sort -Unique
    '$_WMIClasses was updated...' | Out-Host
    Set-Content -Value $_WMIClasses -Path $PSHOME\WMIClasses.txt
}
$global:_snapin = $null

function TabExpansion {
            # This is the default function to use for tab expansion. It handles simple
            # member expansion on variables, variable name expansion and parameter completion
            # on commands. It doesn't understand strings so strings containing ; | ( or { may
            # cause expansion to fail.

            param($line, $lastWord)

            &amp; {
                # Helper function to write out the matching set of members. It depends
                # on dynamic scoping to get $_base, _$expression and $_pat
                function Write-Members ($sep='.')
                {
                    # evaluate the expression to get the object to examine...
                    Invoke-Expression ('$_val=' + $_expression)

                    $_method = [Management.Automation.PSMemberTypes] `
                        'Method,CodeMethod,ScriptMethod,ParameterizedProperty'
                    if ($sep -eq '.')
                    {
                        $members = 
                           (
                              [Object[]](Get-Member -InputObject $_val.PSextended $_pat) + 
                              [Object[]](Get-Member -InputObject $_val.PSadapted $_pat) + 
                              [Object[]](Get-Member -InputObject $_val.PSbase $_pat) 
                           ) | sort MemberType,Name -Unique

                    foreach ($_m in $members)
                       {
                           if ($_m.MemberType -band $_method)
                           {
                               # Return a method...
                               $_base + $_expression + $sep + $_m.name + '('
                           }
                           else {
                               # Return a property...
                               $_base + $_expression + $sep + $_m.name
                           }
                        }
                    }

                    else
                    {
                    foreach ($_m in Get-Member -Static -InputObject $_val $_pat |
                        Sort-Object membertype,name)
                       {
                           if ($_m.MemberType -band $_method)
                           {
                               # Return a method...
                               $_base + $_expression + $sep + $_m.name + '('
                           }
                           else {
                               # Return a property...
                               $_base + $_expression + $sep + $_m.name
                           }
                        }
                    }
                }

                switch -regex ($lastWord)
                {
                    # Handle property and method expansion rooted at variables...
                    # e.g. $a.b.&lt;tab&gt;
                    '(^.*)(\$(\w|\.)+)\.(\w*)$' {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        [void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
                        $_pat = $matches[4] + '*'
                        Write-Members
                        break;
                    }

                    # Handle simple property and method expansion on static members...
                    # e.g. [datetime]::n&lt;tab&gt;
                    '(^.*)(\[(\w|\.)+\])\:\:(\w*)$' {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        $_pat = $matches[4] + '*'
                        Write-Members '::'
                        break;
                    }

                    # Handle complex property and method expansion on static members
                    # where there are intermediate properties...
                    # e.g. [datetime]::now.d&lt;tab&gt;
                    '(^.*)(\[(\w|\.)+\]\:\:(\w+\.)+)(\w*)$' {
                        $_base = $matches[1]  # everything before the expression
                        $_expression = $matches[2].TrimEnd('.') # expression less trailing '.'
                        $_pat = $matches[5] + '*'  # the member to look for...
                        Write-Members
                        break;
                    }

                    # Handle variable name expansion...
                    '(^.*\$)(\w+)$' {
                        $_prefix = $matches[1]
                        $_varName = $matches[2]
                        foreach ($_v in Get-ChildItem ('variable:' + $_varName + '*'))
                        {
                            $_prefix + $_v.name
                        }
                        break;
                    }

                    # Handle env&amp;function drives variable name expansion...
                    '(^.*\$)(.*\:)(\w+)$' {
                        $_prefix = $matches[1]
                        $_drive = $matches[2]
                        $_varName = $matches[3]
                        if ($_drive -eq &quot;env:&quot; -or $_drive -eq &quot;function:&quot;)
                        {
                            foreach ($_v in Get-ChildItem ($_drive + $_varName + '*'))
                            {
                                $_prefix + $_drive + $_v.name
                            }
                        }
                        break;
                    }

                    # Handle array's element property and method expansion...
                    # e.g. foo[0].a&lt;tab&gt;
                    '(^.*)(\$(\w|\.)+\[(\w|\.)+\])\.(\w*)$'
                    {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        $_pat = $Matches[$matches.Count-1] + '*'
                        Write-Members
                        break;
                    }

                    # Handle array's element property and method expansion
                    # where there are intermediate properties...
                    # e.g. foo[0].n.b&lt;tab&gt;
                    '(^.*)((\$(\w|\.)+\[(\w|\.)+\])\.(\w+\.)+)(\w*)$'
                    {
                        $_base = $matches[1]
                        $_expression = $matches[2].TrimEnd('.')
                        $_pat = $Matches[$matches.Count-1] + '*'
                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at type object...
                    # e.g. [System.Type].a&lt;tab&gt;
                    '(^\[(\w|\.)+\])\.(\w*)$'
                    {
                        if ( $(iex $Matches[1]) -isnot [System.Type] ) { break; }
                        $_expression = $Matches[1]
                        $_pat = $Matches[$matches.Count-1] + '*'
                        Write-Members
                        break;
                    }

                    # Handle complex property and method expansion on type object members
                    # where there are intermediate properties...
                    # e.g. [datetime].Assembly.a&lt;tab&gt;
                    '^(\[(\w|\.)+\]\.(\w+\.)+)(\w*)$' {
                        $_expression = $matches[1].TrimEnd('.') # expression less trailing '.'
                        $_pat = $matches[4] + '*'  # the member to look for...
                        if ( $(iex $_expression) -eq $null ) { break; }
                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at close parenthes...
                    # e.g. (123).a&lt;tab&gt;
                    '^(.*)\)((\w|\.)*)\.(\w*)$' {
                        $_base = $Matches[1] + &quot;)&quot;
                        if ( $matches[3] -eq $null) { $_expression = '[System.Type]' }
                        else { $_expression = '[System.Type]' + $Matches[2] }
                        $_pat = $matches[4] + '*'
                        iex &quot;$_expression | Get-Member $_pat | sort MemberType,Name&quot; |
                        % {
                            if ( $_.MemberType -like &quot;*Method*&quot; -or $_.MemberType -like &quot;*Parameterized*&quot; ) { $parenthes = &quot;(&quot; }
                            if ( $Matches[2] -eq &quot;&quot; ) { $_base + &quot;.&quot; + $_.Name + $parenthes }
                            else { $_base + $Matches[2] + &quot;.&quot; + $_.Name + $parenthes }
                          }
                        break;
                    }

                    # Handle .NET type name expansion ...
                    # e.g. [Microsoft.PowerShell.Com&lt;tab&gt;
                    '^\[((\w+\.?)+)$' {
                        $_opt = $matches[1] + '*'
                        foreach ( $_exp in $_TypeNames_System -like $_opt )
                        {
                            '[' + $_exp
                        }
                        foreach ( $_exp in $_TypeNames -like $_opt )
                        {
                            '[' + $_exp
                        }
                        break;
                    }

                    # Do completion on parameters...
                    '^-([\w0-9]*)' {
                        $_pat = $matches[1] + '*'

                        # extract the command name from the string
                        # first split the string into statements and pipeline elements
                        # This doesn't handle strings however.
                        $_cmdlet = [regex]::Split($line, '[|;=]')[-1]

                        #  Extract the trailing unclosed block e.g. ls | foreach { cp
                        if ($_cmdlet -match '\{([^\{\}]*)$')
                        {
                            $_cmdlet = $matches[1]
                        }

                        # Extract the longest unclosed parenthetical expression...
                        if ($_cmdlet -match '\(([^()]*)$')
                        {
                            $_cmdlet = $matches[1]
                        }

                        # take the first space separated token of the remaining string
                        # as the command to look up. Trim any leading or trailing spaces
                        # so you don't get leading empty elements.
                        $_cmdlet = $_cmdlet.Trim().Split()[0]

                        # now get the info object for it...
                        $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

                        # loop resolving aliases...
                        while ($_cmdlet.CommandType -eq 'alias')
                        {
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
                        }

                        # expand the parameter sets and emit the matching elements
                        foreach ($_n in $_cmdlet.ParameterSets |
                            Select-Object -expand parameters | Sort-Object -Unique name)
                        {
                            $_n = $_n.name
                            if ($_n -like $_pat) { '-' + $_n }
                        }
                        break;
                    }

                    # try to find a matching command...
                    default {

                        $lastex =  [regex]::Split($line, '[|;=]')[-1]

                        if ( $lastex -match '([[$].*(\w+))\(([^)]*)$' )
                        {
                            $_method = $Matches[1]

                            if ( $Matches[3] -match &quot;(.*)((`&quot;|')(\w+,)+(\w*))$&quot; )
                            {
                                $continuous = $true
                                $_opt =  $Matches[5] + '*'
                                $_base =  $Matches[2].TrimStart('&quot;') -replace '(.*,)\w+$','$1'
                                $position = $Matches[1].Split(&quot;,&quot;).Length
                            }
                            else
                            {
                                $continuous = $false
                                $_opt = ($Matches[3].Split(',')[-1] -replace '^\s*','') + &quot;*&quot;
                                $position = $Matches[3].Split(&quot;,&quot;).Length
                            }

                            foreach ( $def in iex ($_method + &quot;.OverloadDefinitions&quot;) )
                            {
                                [void] ($def -match '\((.*)\)')
                                foreach ( $param in [regex]::Split($Matches[1], ', ')[$position-1] )
                                {
                                    if ($param -eq $null -or $param -eq &quot;&quot;)
                                    {
                                        continue;
                                    }
                                    $type = $param.split()[0]

                                    if ( $type -like '*`[*' -or $type -eq &quot;Params&quot; -or $type -eq &quot;&quot; )
                                    {
                                        continue;
                                    }
                                    $fullname  = @($_typenames -like &quot;*$type*&quot;)
                                    foreach ( $name in $fullname )
                                    {
                                        if ( $continuous -eq $true -and ( $name  -as [System.Type] ).IsEnum )
                                        {
                                            $output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$',($_base + '$1')
                                            $output | sort
                                        }
                                        elseif ( $name -match &quot;System.\w+$&quot; -and ( $name  -as [System.Type] ).IsEnum )
                                        {
                                            $output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$',(&quot;[$name]::&quot; + '$1')
                                            $output | sort
                                        }
                                        elseif ( ( $name  -as [System.Type] ).IsEnum ) 
                                        {
                                            $output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$','&quot;$1&quot;'
                                            $output | sort
                                        }
                                    }
                                }
                            }
                            if ( $output -ne $null )
                            {
                                break;
                            }
                        }

                        if ( $line[-1] -eq &quot; &quot; )
                        {
                            $_cmdlet = $line.TrimEnd(&quot; &quot;).Split()[-1]

                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

                            # loop resolving aliases...
                            while ($_cmdlet.CommandType -eq 'alias')
                            {
                                $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
                            }

                            if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
                            {
                                &quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; | sort
                                break;
                            }

                            if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
                            {
                               Get-TraceSource | % { $_.Name } | sort -Unique
                               break;
                            }

                            if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
                            {
                                 $_TypeNames_System
                                 $_TypeNames
                                 break;
                            }

                            if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
                            {
                                $_WMIClasses
                                break;
                            }

                            if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Process | % { $_.Name } | sort
                                 break;
                            }

                            if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin
                                    break;
                                }
                            }

                            if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; )
                            {
                                Get-PSDrive | sort
                                break;
                            }

                            if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
                            {
                                 Get-EventLog -List | % { $_base + ($_.Log -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
                            {
                                Get-Help -Category all | % { $_.Name } | sort -Unique
                                     break;
                            }

                            if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
                                 &quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
                                 -contains $_cmdlet.Name )
                            {
                                Get-Service | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Command -CommandType All | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                        }

                        if ( $line[-1] -eq &quot; &quot; )
                        {
                            # extract the command name from the string
                            # first split the string into statements and pipeline elements
                            # This doesn't handle strings however.
                            $_cmdlet = [regex]::Split($line, '[|;=]')[-1]

                            #  Extract the trailing unclosed block e.g. ls | foreach { cp
                            if ($_cmdlet -match '\{([^\{\}]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # Extract the longest unclosed parenthetical expression...
                            if ($_cmdlet -match '\(([^()]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # take the first space separated token of the remaining string
                            # as the command to look up. Trim any leading or trailing spaces
                            # so you don't get leading empty elements.
                            $_cmdlet = $_cmdlet.Trim().Split()[0]

                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'Application' $_cmdlet)[0]

                            if ( $_cmdlet.Name -eq &quot;powershell.exe&quot; )
                            {
                                &quot;-PSConsoleFile&quot;, &quot;-Version&quot;, &quot;-NoLogo&quot;, &quot;-NoExit&quot;, &quot;-Sta&quot;, &quot;-NoProfile&quot;, &quot;-NonInteractive&quot;,
                                &quot;-InputFormat&quot;, &quot;-OutputFormat&quot;, &quot;-EncodedCommand&quot;, &quot;-File&quot;, &quot;-Command&quot; | sort
                                break;
                            }
                            if ( $_cmdlet.Name -eq &quot;fsutil.exe&quot; )
                            {
                                &quot;behavior query&quot;, &quot;behavior set&quot;, &quot;dirty query&quot;, &quot;dirty set&quot;, 
                                &quot;file findbysid&quot;, &quot;file queryallocranges&quot;, &quot;file setshortname&quot;, &quot;file setvaliddata&quot;, &quot;file setzerodata&quot;, &quot;file createnew&quot;, 
                                &quot;fsinfo drives&quot;, &quot;fsinfo drivetype&quot;, &quot;fsinfo volumeinfo&quot;, &quot;fsinfo ntfsinfo&quot;, &quot;fsinfo statistics&quot;, 
                                &quot;hardlink create&quot;, &quot;objectid query&quot;, &quot;objectid set&quot;, &quot;objectid delete&quot;, &quot;objectid create&quot;,
                                &quot;quota disable&quot;, &quot;quota track&quot;, &quot;quota enforce&quot;, &quot;quota violations&quot;, &quot;quota modify&quot;, &quot;quota query&quot;,
                                &quot;reparsepoint query&quot;, &quot;reparsepoint delete&quot;, &quot;sparse setflag&quot;, &quot;sparse queryflag&quot;, &quot;sparse queryrange&quot;, &quot;sparse setrange&quot;,
                                &quot;usn createjournal&quot;, &quot;usn deletejournal&quot;, &quot;usn enumdata&quot;, &quot;usn queryjournal&quot;, &quot;usn readdata&quot;, &quot;volume dismount&quot;, &quot;volume diskfree&quot; | sort
                                break;
                            }
                            if ( $_cmdlet.Name -eq &quot;net.exe&quot; )
                            {
                                &quot;ACCOUNTS &quot;, &quot; COMPUTER &quot;, &quot; CONFIG &quot;, &quot; CONTINUE &quot;, &quot; FILE &quot;, &quot; GROUP &quot;, &quot; HELP &quot;, 
                                &quot;HELPMSG &quot;, &quot; LOCALGROUP &quot;, &quot; NAME &quot;, &quot; PAUSE &quot;, &quot; PRINT &quot;, &quot; SEND &quot;, &quot; SESSION &quot;, 
                                &quot;SHARE &quot;, &quot; START &quot;, &quot; STATISTICS &quot;, &quot; STOP &quot;, &quot; TIME &quot;, &quot; USE &quot;, &quot; USER &quot;, &quot; VIEW&quot; | sort
                                break;
                            }
                            if ( $_cmdlet.Name -eq &quot;ipconfig.exe&quot; )
                            {
                                &quot;/?&quot;, &quot;/all&quot;, &quot;/renew&quot;, &quot;/release&quot;, &quot;/flushdns&quot;, &quot;/displaydns&quot;,
                                &quot;/registerdns&quot;, &quot;/showclassid&quot;, &quot;/setclassid&quot;
                                break;
                            }
                        }

                        if ( $line -match '\s+(\w+(\.|[^\s\.])*)$' )
                        {
                            #$_opt = $Matches[1] + '*'
                            $_cmdlet = $line.TrimEnd(&quot; &quot;).Split()[-2]

                            $_opt = $Matches[1].Split(&quot; ,&quot;)[-1] + '*'
                            $_base = $Matches[1].Substring(0,$Matches[1].Length-$Matches[1].Split(&quot; ,&quot;)[-1].length)


                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

                            # loop resolving aliases...
                            while ($_cmdlet.CommandType -eq 'alias')
                            {
                                $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
                            }

                            if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
                            {
                                &quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; -like $_opt | sort
                                break;
                            }

                            if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
                            {
                               Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
                               break;
                            }

                            if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
                            {
                                 $_TypeNames_System -like $_opt
                                 $_TypeNames -like $_opt
                                 break;
                            }

                            if ( $_cmdlet.Name -like &quot;*WMI*&quot; )
                            {
                                $_WMIClasses -like $_opt
                                break;
                            }

                            if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                            }

                            if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; )
                            {
                                Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-PSProvider&quot; -eq $_cmdlet.Name )
                            {
                                Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }


                            if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
                            {
                                 Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
                            {
                                Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
                                     break;
                            }

                            if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
                                 &quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
                                 -contains $_cmdlet.Name )
                            {
                                Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
                            {
                                 Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                        }

                        if ( $line -match '(-(\w+))\s+([^-]*$)' )
                        {

                            $_param = $matches[2] + '*'
                            $_opt = $Matches[3].Split(&quot; ,&quot;)[-1] + '*'
                            $_base = $Matches[3].Substring(0,$Matches[3].Length-$Matches[3].Split(&quot; ,&quot;)[-1].length)
                            #$_opt = ($Matches[3] -replace '(^.*\s*,?\s*)\w*$','$1') + '*'

                            # extract the command name from the string
                            # first split the string into statements and pipeline elements
                            # This doesn't handle strings however.
                            $_cmdlet = [regex]::Split($line, '[|;=]')[-1]

                            #  Extract the trailing unclosed block e.g. ls | foreach { cp
                            if ($_cmdlet -match '\{([^\{\}]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # Extract the longest unclosed parenthetical expression...
                            if ($_cmdlet -match '\(([^()]*)$')
                            {
                                $_cmdlet = $matches[1]
                            }

                            # take the first space separated token of the remaining string
                            # as the command to look up. Trim any leading or trailing spaces
                            # so you don't get leading empty elements.
                            $_cmdlet = $_cmdlet.Trim().Split()[0]

                            # now get the info object for it...
                            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

                            # loop resolving aliases...
                            while ($_cmdlet.CommandType -eq 'alias')
                            {
                                $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
                            }

                            if ( $_param.TrimEnd(&quot;*&quot;) -eq &quot;ea&quot; -or $_param.TrimEnd(&quot;*&quot;) -eq &quot;wa&quot; )
                            {
                               &quot;SilentlyContinue&quot;, &quot;Stop&quot;, &quot;Continue&quot;, &quot;Inquire&quot; |
                               ? { $_ -like $_opt } | sort -Unique
                               break;
                            }

                            if ( &quot;Out-File&quot;,&quot;Export-CSV&quot;,&quot;Select-String&quot;,&quot;Export-Clixml&quot; -contains $_cmdlet.Name `
                                 -and &quot;Encoding&quot; -like $_param)
                            {
                                &quot;Unicode&quot;,  &quot;UTF7&quot;, &quot;UTF8&quot;, &quot;ASCII&quot;, &quot;UTF32&quot;, &quot;BigEndianUnicode&quot;, &quot;Default&quot;, &quot;OEM&quot; |
                                ? { $_ -like $_opt } | sort -Unique
                                break;
                            }

                            if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name `
                                -and &quot;Name&quot; -like $_param)
                            {
                               Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
                               break;
                            }

                            if ( &quot;New-Object&quot; -like $_cmdlet.Name )
                            {
                                if ( &quot;ComObject&quot; -like $_param )
                                {
                                    $_ProgID -like $_opt | % { $_ -replace '\s','` ' }
                                    break;
                                }

                                if ( &quot;TypeName&quot; -like $_param )
                                {
                                    $_TypeNames_System -like $_opt
                                    $_TypeNames -like $_opt
                                    break;
                                }
                            }

                            if ( &quot;New-Item&quot; -eq $_cmdlet.Name )
                            {
                                if ( &quot;ItemType&quot; -like $_param )
                                {
                                    &quot;directory&quot;, &quot;file&quot; -like $_opt
                                    break;
                                }
                            }

                            if ( &quot;Get-Location&quot;, &quot;Get-PSDrive&quot;, &quot;Get-PSProvider&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name `
                                 -and &quot;PSProvider&quot; -like $_param )
                            {
                                Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort  | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Location&quot; -eq $_cmdlet.Name -and &quot;PSDrive&quot; -like $_param )
                            {
                                Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
                                break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and  &quot;PSSnapin&quot; -like $_param)
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin -like $_opt  | % { $_base + $_ }
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin -like $_opt  | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                            }

                            if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; `
                                 -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                if ( $global:_snapin -ne $null )
                                {
                                    $global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
                                    break;
                                }
                                else
                                {
                                    $global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
                                    $global:_snapin -like $_opt | % { $_base + $_ }
                                    break;
                                }
                            }

                            if ( &quot;Clear-Variable&quot;, &quot;Export-Alias&quot;, &quot;Get-Alias&quot;, &quot;Get-PSDrive&quot;, &quot;Get-Variable&quot;, &quot;Import-Alias&quot;,
                                 &quot; New-Alias&quot;, &quot;New-PSDrive&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Alias&quot;, &quot;Set-Variable&quot; `
                                 -contains $_cmdlet.Name -and &quot;Scope&quot; -like $_param )
                            {
                                &quot;Global&quot;, &quot;Local&quot;, &quot;Script&quot; -like $_opt
                                break;
                            }

                            if ( &quot;Get-Process&quot;, &quot;Stop-Process&quot;, &quot;Wait-Process&quot; -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                 Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name -and &quot;LogName&quot; -like $_param )
                            {
                                 Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
                            {
                                 if ( &quot;Name&quot; -like $_param )
                                 {
                                     Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
                                     break;
                                 }
                                 if ( &quot;Category&quot; -like $_param )
                                 {
                                     &quot;Alias&quot;, &quot;Cmdlet&quot;, &quot;Provider&quot;, &quot;General&quot;, &quot;FAQ&quot;,
                                     &quot;Glossary&quot;, &quot;HelpFile&quot;, &quot;All&quot; -like $_opt | sort | % { $_base + $_ }
                                     break;
                                 }
                            }

                            if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
                                 &quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
                                 -contains $_cmdlet.Name )
                            {
                                 if ( &quot;Name&quot; -like $_param )
                                 {
                                     Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
                                     break;
                                 }
                                 if ( &quot;DisplayName&quot; -like $_param )
                                 {
                                     Get-Service -Name $_opt | sort DisplayName | % { $_base + ($_.DisplayName -replace '\s','` ') }
                                     break;
                                 }
                            }

                            if ( &quot;New-Service&quot; -eq $_cmdlet.Name -and &quot;dependsOn&quot; -like $_param )
                            {
                                 Get-Service -Name $_opt | sort Name | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( &quot;Get-EventLog&quot; -eq $_cmdlet.Name -and &quot;EntryType&quot; -like $_param )
                            {
                                 &quot;Error&quot;, &quot;Information&quot;, &quot;FailureAudit&quot;, &quot;SuccessAudit&quot;, &quot;Warning&quot; -like $_opt | sort | % { $_base + $_ }
                                 break;
                            }

                            if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and &quot;Name&quot; -like $_param )
                            {
                                 Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
                                 break;
                            }

                            if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
                            {
                                if ( &quot;Class&quot; -like $_param )
                                {
                                    $_WMIClasses -like $_opt
                                    break;
                                }
                            }

                            select -InputObject $_cmdlet -ExpandProperty ParameterSets | select -ExpandProperty Parameters |
                            ? { $_.Name -like $_param } | ? { $_.ParameterType.IsEnum } |
                            % { [Enum]::GetNames($_.ParameterType) } | ? { $_ -like $_opt } | sort -Unique | % { $_base + $_ }

                        }


                               if ( $line[-1] -match &quot;\s&quot; ) { break; }

                               if ( $lastWord -ne $null -and $lastWord.IndexOfAny('/\') -eq -1 ) {
                                  $command = $lastWord
                                  $pattern = $command + &quot;*&quot;
                                  gcm -Name $pattern -CommandType All | % { $_.Name } | sort -Unique
                               }
                    }
                }
            }
        
}
</code></pre>

</div>
			<!-- sidebar? -->
		</div>
		<hr>
		<footer class="blog-footer">
			<p>Generated by Joel &quot;Jaykul&quot; Bennett - 2018</p>
		</footer>
	</div> <!-- /container -->

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>
    <script src="/js/vendor/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>