
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="foobar">
    <title>TabExpansion - PoshCode</title>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" data-tabs="tabs" id="tabs">
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video" data-toggle="tab">Video Feed</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

    

<div class="blog-post">
    <h2 class="blog-post-title">TabExpansion</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2009-06-27</span> by <a class="blog-post-author">foobar</a>
    </p>

    <h1>TabExpansion</h1>
<h3><a href="//scripts/1180.ps1">download</a> - <a href="//scripts/1137.md">parent</a></h3>
<p>The most needless, useless and worthless Tabexpansion for powershell.exe(v1.0) in PoshCode.
Please dot souce this script file to use.
Update:.</p>
<h1>WMI Namespaces expansion for Get-WmiObject</h1>
<p>gwmi -Namespace <tab>.
Get-WmiObject -Namespace root\asp<tab>.</p>
<h1>WMI Classes expansion which is corresponding to WMI Namespace (*)</h1>
<p>gwmi -Namespace ROOT\CIMV2\ms_409 -Class <tab>_<tab>.</p>
<p>(*) it needs to remove old $PSHOME\WMIClasses.txt if it exists.</p>
<pre><code class="language-posh">## Tab-Completion
#################
## Please dot souce this script file.
## In first loading, it may take a several minutes, in order to generate ProgIDs and TypeNames list.
## 
## What this can do is:
##
## [datetime]::n&lt;tab&gt;
## [datetime]::now.d&lt;tab&gt;
## $a = New-Object &quot;Int32[,]&quot; 2,3; $b = &quot;PowerShell&quot;,&quot;PowerShell&quot;
## $c = [ref]$a; $d = [ref]$b,$c
## $d[0].V&lt;tab&gt;[0][0].Get&lt;tab&gt;
## $d[1].V&lt;tab&gt;[0,0].tos&lt;tab&gt;
## $function:a&lt;tab&gt;
## $env:a&lt;tab&gt;
## [System.Type].a&lt;tab&gt;
## [datetime].Assembly.a&lt;tab&gt;
## ).a&lt;tab&gt; # shows System.Type properties and methods...

## #native command name expansion
## fsu&lt;tab&gt;

## #command option name expansion (for fsutil ipconfig net powershell only)
## fsutil &lt;tab&gt;
## ipconfig &lt;tab&gt;
## net &lt;tab&gt;
## powershell &lt;tab&gt;

## #TypeNames and Type accelerators expansion
## [Dec&lt;tab&gt;
## [system.Man&lt;tab&gt;.auto&lt;tab&gt;.p&lt;tab&gt;
## New-Object -TypeName IO.Dir&lt;tab&gt;
## New-Object System.win&lt;tab&gt;.for&lt;tab&gt;.bu&lt;tab&gt;

## #ProgIDs expansion
## New-Object -Com shel&lt;tab&gt;

## #Enum option expansion
## Set-ExecutionPolicy &lt;tab&gt;
## Set-ExecutionPolicy All&lt;tab&gt;
## Set-ExcusionPolisy -ex &lt;tab&gt;
## Get-TraceSource Inte&lt;tab&gt;
## iex -Errora &lt;tab&gt; -wa Sil&lt;tab&gt;

## #WmiClasses expansion
## Get-WmiObject -class Win32_&lt;tab&gt;
## gwmi __Instance&lt;tab&gt;

## #Encoding expansion
## [Out-File | Export-CSV | Select-String | Export-Clixml] -enc &lt;tab&gt;
## [Add-Content | Get-Content | Set-Content} -Encoding Big&lt;tab&gt;

## #PSProvider name expansion
## [Get-Location | Get-PSDrive | Get-PSProvider | New-PSDrive | Remove-PSDrive] -PSProvider &lt;tab&gt;
## Get-PSProvider &lt;tab&gt;
## pwd -psp al&lt;tab&gt;

## #PSDrive name expansion
## [Get-PSDrive | New-PSDrive | Remove-PSDrive] [-Name] &lt;tab&gt;
## Get-PSDrive &lt;tab&gt;
## pwd -psd &lt;tab&gt;

## #PSSnapin name expansion
## [Add-PSSnapin | Get-PSSnapin | Remove-PSSnapin ] [-Name] &lt;tab&gt;
## Get-Command -PSSnapin &lt;tab&gt;
## Remove-PSSnapin &lt;tab&gt;
## Get-PSSnapin M&lt;tab&gt;

## #Eventlog name and expansion
## Get-Eventlog -Log &lt;tab&gt;
## Get-Eventlog w&lt;tab&gt;

## #Eventlog's entrytype expansion
## Get-EventLog -EntryType &lt;tab&gt;
## Get-EventLog -EntryType Er&lt;tab&gt;
## Get-EventLog -Ent &lt;tab&gt;

## #Service name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-Name] &lt;tab&gt;
## New-Service -DependsOn &lt;tab&gt;
## New-Service -Dep e&lt;tab&gt;
## Get-Service -n &lt;tab&gt;
## Get-Service &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;
## gsv &lt;tab&gt;

## #Service display name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-DisplayName] &lt;tab&gt;
## Get-Service -Dis &lt;tab&gt;
## gsv -Dis &lt;tab&gt;,w&lt;tab&gt;,b&lt;tab&gt;

## #Cmdlet and Topic name expansion (this also support default help function and man alias)
## Get-Help [-Name] about_&lt;tab&gt;
## Get-Help &lt;tab&gt;

## #Category name expansion (this also support default help function and man alias)
## Get-Help -Category c&lt;tab&gt;,&lt;tab&gt;

## #Command name expansion
## Get-Command [-Name] &lt;tab&gt;
## Get-Command -Name &lt;tab&gt;
## gcm a&lt;tab&gt;,&lt;tab&gt;

## #Scope expansion
## [Clear-Variable | Export-Alias | Get-Alias | Get-PSDrive | Get-Variable | Import-Alias
## New-Alias | New-PSDrive | New-Variable | Remove-Variable | Set-Alias | Set-Variable] -Scope &lt;tab&gt;
## Clear-Variable -Scope G&lt;tab&gt;
## Set-Alias  -s &lt;tab&gt;

## #Process name expansion
## [Get-Process | Stop-Process] [-Name] &lt;tab&gt;
## Stop-Process -Name &lt;tab&gt;
## Stop-Process -N pow&lt;tab&gt;
## Get-Process &lt;tab&gt;
## ps power&lt;tab&gt;

## #Trace sources expansion
## [Trace-Command | Get-TraceSource | Set-TraceSource] [-Name] &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;

## #Trace -ListenerOption expansion
## [Set-TraceSource | Trace-Command] -ListenerOption &lt;tab&gt;
## Set-TraceSource -Lis &lt;tab&gt;,n&lt;tab&gt;

## #Trace -Option expansion
## [Set-TraceSource | Trace-Command] -Option &lt;tab&gt;
## Set-TraceSource -op &lt;tab&gt;,con&lt;tab&gt;

## #ItemType expansion
## New-Item -Item &lt;tab&gt;
## ni -ItemType d&lt;tab&gt;

## #ErrorAction and WarningAction option expansion
## CMDLET [-ErrorAction | -WarningAction] &lt;tab&gt;
## CMDLET -Errora s&lt;tab&gt;
## CMDLET -ea con&lt;tab&gt;
## CMDLET -wa &lt;tab&gt;

## #Continuous expansion with comma when parameter can treat multiple option
## # if there are spaces, occur display bug in the line
## # if strings contains '$' or '-', not work
## Get-Command -CommandType &lt;tab&gt;,&lt;tab&gt;&lt;tab&gt;,cm&lt;tab&gt;
## pwd -psp &lt;tab&gt;,f&lt;tab&gt;,va&lt;tab&gt;
## Get-EventLog -EntryType &lt;tab&gt;,i&lt;tab&gt;,s&lt;tab&gt;

## #Enum expansion in method call expression
## # this needs one or more spaces after left parenthesis or comma
## $str = &quot;day   night&quot;
## $str.Split( &quot; &quot;,&lt;space&gt;rem&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; ) &lt;Enter&gt; ERROR
## $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as&lt;space&gt;&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions] ) &lt;Enter&gt; Success
## $type = [System.Type]
## $type.GetMembers(&lt;space&gt;Def&lt;tab&gt;
## [IO.Directory]::GetFiles( &quot;C:\&quot;, &quot;*&quot;,&lt;space&gt;All&lt;tab&gt;
## # this can do continuous enum expansion with comma and no spaces
## $type.GetMembers( &quot;IgnoreCase&lt;comma&gt;Dec&lt;tab&gt;&lt;comma&gt;In&lt;tab&gt;&quot;
## [IO.Directory]::GetAccessControl( &quot;C:\&quot;,&lt;space&gt;au&lt;tab&gt;&lt;comma&gt;ac&lt;tab&gt;&lt;comma&gt;G&lt;tab&gt;

## #Better '$_.' expansion when cmdlet output objects or method return objects
## ls |group { $_.Cr&lt;tab&gt;.Tost&lt;tab&gt;&quot;y&quot;)} | tee -var foo| ? { $_.G&lt;tab&gt;.c&lt;tab&gt; -gt 5 } | % { md $_.N&lt;tab&gt; ; copy $_.G&lt;tab&gt; $_.N&lt;tab&gt;  }
## [IO.DriveInfo]::GetDrives() | ? { $_.A&lt;tab&gt; -gt 1GB }
## $Host.UI.RawUI.GetBufferContents($rect) | % { $str += $_.c&lt;tab&gt; }
## gcm Add-Content |select -exp Par&lt;tab&gt;| select -ExpandProperty Par&lt;tab&gt; | ? { $_.Par&lt;tab&gt;.N&lt;tab&gt; -eq &quot;string&quot; }
## $data = Get-Process
## $data[2,4,5]  | % { $_.&lt;tab&gt;
## #when Get-PipeLineObject failed, '$_.' shows methods and properties name of FileInfo and String and Type

## #Property name expansion by -Property parameter
## [ Format-List | Format-Custom | Format-Table | Format-Wide | Compare-Object |
##  ConvertTo-Html | Measure-Object | Select-Object | Group-Object | Sort-Object ] [-Property] &lt;tab&gt;
## Select-Object -ExcludeProperty &lt;tab&gt;
## Select-Object -ExpandProperty &lt;tab&gt;
## gcm Get-Acl|select -exp Par&lt;tab&gt;
## ps |group na&lt;tab&gt;
## ls | ft A&lt;tab&gt;,M&lt;tab&gt;,L&lt;tab&gt;

## #Hashtable key expansion in the variable name and '.&lt;tab&gt;'
## Get-Process | Get-Unique | % { $hash += @{$_.ProcessName=$_} }
## $hash.pow&lt;tab&gt;.pro&lt;tab&gt;

## #Parameter expansion for function, filter and script
## man -f&lt;tab&gt;
## 'param([System.StringSplitOptions]$foo,[System.Management.Automation.ActionPreference]$bar,[System.Management.Automation.CommandTypes]$baz) {}' &gt; foobar.ps1
## .\foobar.ps1 -&lt;tab&gt; -b&lt;tab&gt;

## #Enum expansion for function, filter and scripts
## # this can do continuous enum expansion with comma and no spaces
## .\foobar.ps1 -foo rem&lt;tab&gt; -bar &lt;tab&gt;&lt;comma&gt;c&lt;tab&gt;&lt;comma&gt;sc&lt;tab&gt; -ea silent&lt;tab&gt; -wa con&lt;tab&gt;

## #Enum expansion for assignment expression
## #needs space(s) after '=' and comma
## #strongly-typed with -as operator and space(s)
## $ErrorActionPreference =&lt;space&gt;&lt;tab&gt;
## $cmdtypes = New-Object System.Management.Automation.CommandTypes[] 3
## $cmdtypes =&lt;space&gt;&lt;tab&gt;&lt;comma&gt;&lt;space&gt;func&lt;tab&gt;&lt;comma&gt;&lt;space&gt;cmd&lt;tab&gt; -as&lt;space&gt;&lt;tab&gt;

## #Path expansion with variable and '\' or '/'
## $PWD\../../&lt;tab&gt;\&lt;tab&gt;
## &quot;$env:SystemDrive/pro&lt;tab&gt;/&lt;tab&gt;

## #Operator expansion which starts with '-'
## &quot;Power&quot;,&quot;Shell&quot; -m&lt;tab&gt; &quot;Power&quot; -r&lt;tab&gt; '(Pow)(er)','$1d$2'
## 1..9 -co&lt;tab&gt; 5

## #Keyword expansion
## fu&lt;tab&gt; test { p&lt;tab&gt; $foo, $bar ) b&lt;tab&gt; &quot;foo&quot; } pr&lt;tab&gt; $_ } en&lt;tab&gt; &quot;$bar&quot; } }

## #Variable name expansion (only global scope)
## [Clear-Variable | Get-Variable | New-Variable | Remove-Variable | Set-Variable] [-Name] &lt;tab&gt;
## [Cmdlet | Function | Filter | ExternalScript] -ErrorVariable &lt;tab&gt;
## [Cmdlet | Function | Filter | ExternalScript] -OutVariable &lt;tab&gt;
## Tee-Object -Variable &lt;tab&gt;
##  gv pro&lt;tab&gt;,&lt;tab&gt;
##  Remove-Variable -Name out&lt;tab&gt;,&lt;tab&gt;,ps&lt;tab&gt;
##  ... | ... | tee -v &lt;tab&gt;

## #Alias name expansion
## [Get-Alias | New-Alias | Set-Alias] [-Name] &lt;tab&gt;
## Export-Alias -Name &lt;tab&gt;
##  Get-Alias i&lt;tab&gt;,e&lt;tab&gt;,a&lt;tab&gt;
##  epal -n for&lt;tab&gt;

## #Property name expansion with -groupBy parameter
## [Format-List | Format-Custom | Format-Table | Format-Wide] -groupBy &lt;tab&gt;
##  ps | ft -g &lt;tab&gt;
##  gcm | Format-Wide -GroupBy Par&lt;tab&gt;

## #Type accelerators expansion with no characters
##  [&lt;tab&gt;
##  New-Object -typename &lt;tab&gt;
##  New-Object &lt;tab&gt;

## # File glob expansion with '@'
##  ls *.txt@&lt;tab&gt;
##  ls file.txt, foo1.txt, 'bar``[1``].txt', 'foo bar .txt'	# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter *.txt						# 2 &lt;tab&gt; refactoring 
##  ls *.txt							# 3 &lt;tab&gt; (or 1 &lt;tab&gt; &amp; 1 &lt;shift&gt;+&lt;tab&gt;) return original glob pattern

## This can also use '^'(hat) or '~'(tilde) for Excluding
##  ls &lt;hat&gt;*.txt@&lt;tab&gt;
##  ls foo.ps1, 'bar``[1``].xml'		# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter * -Excluding *.txt		# 2 &lt;tab&gt; refactoring 
##  *.txt&lt;tilde&gt;foo*&lt;tilde&gt;bar*@&lt;tab&gt;
##  ls file.txt					# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter *.txt -Excluding foo*, bar*	# 2 &lt;tab&gt; refactoring 

## # Ported history expansion from V2CTP3 TabExpansion with '#' ( #&lt;pattern&gt; or #&lt;id&gt; )
##  ls * -Filter * -Excluding foo*, bar*&lt;Enter&gt;
##  #ls&lt;tab&gt;
##  #1&lt;tab&gt;

## # Command buffer stack with ';'(semicolon)
##  ls * -Filter * -Excluding foo*, bar*&lt;semicolon&gt;&lt;tab&gt; # push command1
##  echo &quot;PowerShell&quot;&lt;semicolon&gt;&lt;tab&gt; # push command2
##  get-process&lt;semicolon&gt;&lt;tab&gt; # push command3
##  {COMMAND}&lt;Enter&gt; # execute another command 
##  get-process # Auto pop command3 from stack by LIFO
## This can also hand-operated pop with ';,'(semicolon&amp;comma) or ';:'(semicolon&amp;colon)
##  get-process; &lt;semicolon&gt;&lt;comma&gt;&lt;tab&gt;
##  get-process; echo &quot;PowerShell&quot; # pop command2 from stack by LIFO

## # Function name expansion after 'function' or 'filter' keywords
## function cl&lt;tab&gt;

## #Switch syntax option expansion
##  switch -w&lt;tab&gt; -f&lt;tab&gt;

## #Better powershell.exe option expansion with '-'
##  powershell -no&lt;tab&gt; -&lt;tab&gt; -en&lt;tab&gt;

## #A part of PowerShell attributes expansion ( CmdletBinding, Parameter, Alias, Validate*, Allow* )
##  [par&lt;tab&gt;
##  [cmd&lt;tab&gt;

## #Member expansion for CmdletBinding and Parameter attributes
##  [Parameter(man&lt;tab&gt;,&lt;tab&gt;1,val&lt;tab&gt;$true)]
##  [CmdletBinding( &lt;tab&gt;&quot;foo&quot;, su&lt;tab&gt;$true)]

## #Several current date/time formats with Ctrl+D
##  &lt;Ctrl+D&gt;&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;...

## #Hand-operated pop from command buffer with Ctrl+P (this is also available with ';:' or ';,')
##  &lt;command&gt;;&lt;tab&gt; # push command
##  &lt;Ctrl+D&gt;&lt;tab&gt; # pop

## #Paste clipboard with Ctrl+V
##  &lt;Ctrl+V&gt;&lt;tab&gt;

## # Cut current line with Ctrl+X
##  &lt;command&gt;&lt;Ctrl+X&gt;&lt;tab&gt;

## # Cut words with a character after Ctrl+X until the character
## 1: PS &gt; dir -Filter *.txt&lt;Ctrl+X&gt;-&lt;tab&gt; # Cut words until '-'
## 2: PS &gt; dir -
## 3: PS &gt; dir -&lt;Ctrl+V&gt;&lt;tab&gt; # Paste words that were copyed now

## # Cut last word in current line with Ctrl+Z
## 1: PS &gt;  Get-ChildItem *.txt&lt;Ctrl+Z&gt;&lt;tab&gt; # Cut last word in current line
## 2: PS &gt;  Get-ChildItem 
## 3: PS &gt;  Get-ChildItem -Exclude &lt;Ctrl+V&gt;&lt;tab&gt; # Paste last word that was copyed now

## #[ScriptBlock] member expansion for [ScriptBlock] literal
##  { 1+1 }.inv&lt;tab&gt;

## #A part of history commands expansion with Ctrl+L (using split(&quot;;&quot;),split(&quot;|&quot;),split(&quot;;|&quot;) )
## ls -Force -Recurse -Filter *.txt | ? { $_.LastWriteTime -lt  [DateTime]::Today } ; echo PowerShell
## ls&lt;Ctrl+L&gt;&lt;tab&gt;&lt;tab&gt;
## ?&lt;Ctrl+L&gt;&lt;tab&gt;&lt;tab&gt;
## ec&lt;Ctrl+L&gt;&lt;tab&gt;

## # Using Ctrl+K, characters insertion (bihind space or semi-coron or pipe operator) feature : it encloses tokens with parnthesis by default
##  1 - 1 - 1 - 1&lt;Ctrl+K&gt;&lt;tab&gt;
##  1 - 1 - 1 - (1)&lt;tab&gt;
##  1 - 1 - 1 (- 1)&lt;tab&gt;
##  1 - 1 - (1 - 1)&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;...
## with double Ctrl+K, it encloses tokens with $( )
##  for ( $i=0;$j=1&lt;Ctrl+K&gt;&lt;Ctrl+K&gt;&lt;tab&gt;&lt;tab&gt;
##  for ( $($i=0;$j=1)
## if there is a character between &lt;Ctrl+K&gt; and  &lt;tab&gt;, it is inserted between tokens
##  1+1 | {$_*2}&lt;Ctrl+K&gt;%&lt;tab&gt;
##  1+1 | %{$_*2}
##  1+1 +1+1&lt;Ctrl+K&gt;;&lt;tab&gt;
##  1+1 ;+1+1
## if the character is ( or { or {, tokens are enclosed ( ) or { } or {}
##  int&lt;Ctrl+K&gt;[&lt;tab&gt;
##  [int]
## with double Ctrl+K, and if there is a character between &lt;Ctrl+K&gt; and  &lt;tab&gt;, it is inserted between tokens with '$'
##  C:\WINDOWS\system32\notepad.exe&lt;Ctrl+K&gt;&lt;Ctrl+K&gt;{&lt;tab&gt;
##  ${C:\WINDOWS\system32\notepad.exe}
## % and ? are given special treatment with double Ctrl+K, these enclose tokens with % { } or ? { } behind '|'
##  ls | $_.LastWriteTime -gt &quot;2009/5&quot;&lt;Ctrl+K&gt;&lt;Ctrl+K&gt;?&lt;tab&gt;
##  ls | ? {$_.LastWriteTime -gt &quot;2009/5&quot;}
##  ls | $_.FullName&lt;Ctrl+K&gt;&lt;Ctrl+K&gt;%&lt;tab&gt;
##  ls | % {$_.FullName}

## # WMI Namespaces expansion for Get-WmiObject
##  gwmi -Namespace &lt;tab&gt;
##  Get-WmiObject -Namespace root\asp&lt;tab&gt;

## # WMI Classes expansion which is corresponding to WMI Namespace (*)
##  gwmi -Namespace ROOT\CIMV2\ms_409 -Class &lt;tab&gt;_&lt;tab&gt;


### Generate ProgIDs list...
if ( Test-Path $PSHOME\ProgIDs.txt )
{
    $_ProgID = type $PSHOME\ProgIDs.txt -ReadCount 0
}
else
{
    $_HKCR = [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\&quot;)
    $_ProgID = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
    foreach ( $_subkey in $_HKCR.GetSubKeyNames() )
    {
        foreach ( $_i in [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\$_subkey\ProgID&quot;) )
        {
            if ($_i -ne $null)
            {
                $_ProgID.Add($_i.GetValue(&quot;&quot;))
            }
        }
    }
    '$_ProgID was updated...' | Out-Host
    $_ProgID = $_ProgID|sort -Unique

    Set-Content -Value $_ProgID -Path $PSHOME\ProgIDs.txt -Verbose
}

### Generate TypeNames list...

if ( Test-Path $PSHOME\TypeNames.txt )
{
    $_TypeNames = type $PSHOME\TypeNames.txt -ReadCount 0
}
else
{
    $_TypeNames = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
    foreach ( $_asm in [AppDomain]::CurrentDomain.GetAssemblies() )
    {
        foreach ( $_type in $_asm.GetTypes() )
        {
            $_TypeNames.Add($_type.FullName)
        }
    }
    '$_TypeNames was updated...' | Out-Host
    $_TypeNames = $_TypeNames | sort -Unique

    Set-Content -Value $_TypeNames -Path $PSHOME\TypeNames.txt -Verbose
}

if ( Test-Path $PSHOME\TypeNames_System.txt )
{
    $_TypeNames_System = type $PSHOME\TypeNames_System.txt -ReadCount 0
}
else
{
    $_TypeNames_System = $_TypeNames -like &quot;System.*&quot; -replace '^System\.'
    '$_TypeNames_System was updated...' | Out-Host
    Set-Content -Value $_TypeNames_System -Path $PSHOME\TypeNames_System.txt -Verbose
}

### Generate Namespaces list...
if ( Test-Path $PSHOME\WMINamespaces.txt )
{
    $_WMINamespaces = type $PSHOME\WMINamespaces.txt -ReadCount 0
}
else
{
    $_WMINamespaces = &amp; {
       $sb = {
           param ($ns)
           gwmi __NAMESPACE -Namespace $ns -com . |
           % {
               $ns = $_.__NAMESPACE + &quot;\&quot; + $_.Name
               $ns
               &amp; $sb $ns
           }
       }
       &amp; $sb root
    }
    $_WMINamespaces = $_WMINamespaces + &quot;ROOT&quot; | sort
    '$_WMINamespaces was updated...' | Out-Host
    Set-Content -Value $_WMINamespaces -Path $PSHOME\WMINamespaces.txt -Verbose
}
### Get default WMI Namespace...
$_WMIdftNS = $_WMINamespaces -eq (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\WBEM\Scripting).&quot;Default Namespace&quot;

### Generate WMIClasses list...
if ( Test-Path $PSHOME\WMIClasses.txt )
{
    $_WMIClasses =  Import-Clixml $PSHOME\WMIClasses.txt
}
else
{
    $_new = '=(New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) ));'
    $_WMIClasses = iex ('@{&quot;' + [String]::Join( &quot;`&quot;$_new`&quot;&quot;, $_WMINamespaces ) + &quot;`&quot;$_new}&quot;)

    foreach ( $_namespace in $_WMINamespaces )
    {
        foreach ( $_class in gwmi -Namespace $_namespace -List )
        {
            $_WMIClasses.$_namespace.Add($_class.Name)
        }
    $_WMIClasses.$_namespace.Sort()
    }
    '$_WMIClasses was updated...' | Out-Host
    Export-Clixml -InputObject $_WMIClasses -Path $PSHOME\WMIClasses.txt -Verbose
}

[Reflection.Assembly]::LoadWithPartialName( &quot;System.Windows.Forms&quot; ) | Out-Null
$global:_cmdstack = New-Object Collections.Stack
$global:_snapin = $null
$global:_TypeAccelerators = &quot;ADSI&quot;, &quot;Array&quot;, &quot;Bool&quot;, &quot;Byte&quot;, &quot;Char&quot;, &quot;Decimal&quot;, &quot;Double&quot;, &quot;float&quot;, &quot;hashtable&quot;, &quot;int&quot;, &quot;Long&quot;, &quot;PSObject&quot;, &quot;ref&quot;,
                            &quot;Regex&quot;, &quot;ScriptBlock&quot;, &quot;Single&quot;, &quot;String&quot;, &quot;switch&quot;, &quot;Type&quot;, &quot;WMI&quot;, &quot;WMIClass&quot;, &quot;WMISearcher&quot;, &quot;xml&quot;
$global:_cmdline = New-Object Collections.ArrayList

iex (@'
function prompt {
h -Count 1 -OutVariable line |
% { $_.CommandLine.Split(&quot;|&quot;); $_.CommandLine.Split(&quot;;&quot;); $_.CommandLine.Split(&quot;;&quot;); $_.CommandLine.Split(&quot;;|&quot;) } |
Get-Unique | ? { $_ -ne $line.CommandLine -and $_ -notmatch '^\s*$' } |
% { $_.Trim(&quot; &quot;) } |
? { $global:_cmdline -notcontains $_ } | % { Set-CommandLine $_ | Out-Null }
if ($_cmdstack.Count -gt 0) {
    $line = $global:_cmdstack.Pop() -replace '([[\]\(\)+{}?~%])','{$1}'
    [System.Windows.Forms.SendKeys]::SendWait($line)
}
'@ + @&quot;
${function:prompt}
}
&quot;@)

function Write-ClassNames ( $data, $i, $prefix='', $sep='.' )
{
    $preItem = &quot;&quot;
    foreach ( $class in $data -like $_opt )
    {
        $Item = $class.Split($sep)
        if ( $preItem -ne $Item[$i] )
        {
            if ( $i+1 -eq $Item.Count )
            {
                if ( $prefix -eq &quot;[&quot; )
                {
                    $suffix = &quot;]&quot;
                }
                elseif ( $sep -like &quot;[_\]&quot; )
                {
                    $suffix = &quot;&quot;
                }
                else
                {
                    $suffix = &quot; &quot;
                }
            }
            else
            {
                $suffix = &quot;&quot;
            }
            $prefix + $_opt.Substring(0, $_opt.LastIndexOf($sep)+1) + $Item[$i] + $suffix

            $preItem = $Item[$i]
        }
    }
}

function Get-PipeLineObject {

    $i = -2
    $property = $null
    do {
        $str = $line.Split(&quot;|&quot;)
        # extract the command name from the string
        # first split the string into statements and pipeline elements
        # This doesn't handle strings however.
        $_cmdlet = [regex]::Split($str[$i], '[|;=]')[-1]

        # take the first space separated token of the remaining string
        # as the command to look up. Trim any leading or trailing spaces
        # so you don't get leading empty elements.
        $_cmdlet = $_cmdlet.Trim().Split()[0]

        if ( $_cmdlet -eq &quot;?&quot; )
        {
            $_cmdlet = &quot;Where-Object&quot;
        }

        $global:_exp = $_cmdlet

        # now get the info object for it...
        $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

        # loop resolving aliases...
        while ($_cmdlet.CommandType -eq 'alias')
        {
            $_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
        }

        if ( &quot;Select-Object&quot; -eq $_cmdlet )
        {
            if ( $str[$i] -match '\s+-Exp\w*[\s:]+(\w+)' )
            {
                $property = $Matches[1] + &quot;;&quot; + $property
            }
        }

        $i--
    } while ( &quot;Get-Unique&quot;, &quot;Select-Object&quot;, &quot;Sort-Object&quot;, &quot;Tee-Object&quot;, &quot;Where-Object&quot; -contains $_cmdlet )

    if ( $global:_forgci -eq $null )
    {
        $a = @(ls &quot;Alias:\&quot;)[0]
        $e = @(ls &quot;Env:\&quot;)[0]
        $f = @(ls &quot;Function:\&quot;)[0]
        $h = @(ls &quot;HKCU:\&quot;)[0]
        $v = @(ls &quot;Variable:\&quot;)[0]
        $c = @(ls &quot;cert:\&quot;)[0]
        $global:_forgci = gi $PSHOME\powershell.exe |
        Add-Member -Name CommandType -MemberType 'NoteProperty' -Value $f.CommandType -PassThru |
        Add-Member -Name Definition -MemberType 'NoteProperty' -Value $a.Definition -PassThru |
        Add-Member -Name Description -MemberType 'NoteProperty' -Value $a.Description -PassThru |
        Add-Member -Name Key -MemberType 'NoteProperty' -Value $e.Key -PassThru |
        Add-Member -Name Location -MemberType 'NoteProperty' -Value $c.Location -PassThru |
        Add-Member -Name LocationName -MemberType 'NoteProperty' -Value $c.LocationName -PassThru |
        Add-Member -Name Options -MemberType 'NoteProperty' -Value $a.Options -PassThru |
        Add-Member -Name ReferencedCommand -MemberType 'NoteProperty' -Value $a.ReferencedCommand -PassThru |
        Add-Member -Name ResolvedCommand -MemberType 'NoteProperty' -Value $a.ResolvedCommand -PassThru |
        Add-Member -Name ScriptBlock -MemberType 'NoteProperty' -Value $f.ScriptBlock -PassThru |
        Add-Member -Name StoreNames -MemberType 'NoteProperty' -Value $c.StoreNames -PassThru |
        Add-Member -Name SubKeyCount -MemberType 'NoteProperty' -Value $h.SubKeyCount -PassThru |
        Add-Member -Name Value -MemberType 'NoteProperty' -Value $e.Value -PassThru |
        Add-Member -Name ValueCount -MemberType 'NoteProperty' -Value $h.ValueCount -PassThru |
        Add-Member -Name Visibility -MemberType 'NoteProperty' -Value $a.Visibility -PassThru |
        Add-Member -Name Property -MemberType 'NoteProperty' -Value $h.Property -PassThru |
        Add-Member -Name ResolvedCommandName -MemberType 'NoteProperty' -Value $a.ResolvedCommandName -PassThru |
        Add-Member -Name Close -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name CreateSubKey -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name DeleteSubKey -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name DeleteSubKeyTree -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name DeleteValue -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Flush -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetSubKeyNames -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetValue -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetValueKind -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetValueNames -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IsValidValue -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name OpenSubKey -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name SetValue -MemberType 'ScriptMethod' -Value {} -PassThru
    }

    if ( $global:_mix -eq $null )
    {
        $f = gi $PSHOME\powershell.exe
        $t = [type]
        $s = &quot;&quot;
        $global:_mix = `
        Add-Member -InputObject (New-Object PSObject) -Name Mode -MemberType 'NoteProperty' -Value $f.Mode -PassThru |
        Add-Member -Name Assembly -MemberType 'NoteProperty' -Value $t.Assembly -PassThru |
        Add-Member -Name AssemblyQualifiedName -MemberType 'NoteProperty' -Value $t.AssemblyQualifiedName -PassThru |
        Add-Member -Name Attributes -MemberType 'NoteProperty' -Value $f.Attributes -PassThru |
        Add-Member -Name BaseType -MemberType 'NoteProperty' -Value $t.BaseType -PassThru |
        Add-Member -Name ContainsGenericParameters -MemberType 'NoteProperty' -Value $t.ContainsGenericParameters -PassThru |
        Add-Member -Name CreationTime -MemberType 'NoteProperty' -Value $f.CreationTime -PassThru |
        Add-Member -Name CreationTimeUtc -MemberType 'NoteProperty' -Value $f.CreationTimeUtc -PassThru |
        Add-Member -Name DeclaringMethod -MemberType 'NoteProperty' -Value $t.DeclaringMethod -PassThru |
        Add-Member -Name DeclaringType -MemberType 'NoteProperty' -Value $t.DeclaringType -PassThru |
        Add-Member -Name Exists -MemberType 'NoteProperty' -Value $f.Exists -PassThru |
        Add-Member -Name Extension -MemberType 'NoteProperty' -Value $f.Extension -PassThru |
        Add-Member -Name FullName -MemberType 'NoteProperty' -Value $f.FullName -PassThru |
        Add-Member -Name GenericParameterAttributes -MemberType 'NoteProperty' -Value $t.GenericParameterAttributes -PassThru |
        Add-Member -Name GenericParameterPosition -MemberType 'NoteProperty' -Value $t.GenericParameterPosition -PassThru |
        Add-Member -Name GUID -MemberType 'NoteProperty' -Value $t.GUID -PassThru |
        Add-Member -Name HasElementType -MemberType 'NoteProperty' -Value $t.HasElementType -PassThru |
        Add-Member -Name IsAbstract -MemberType 'NoteProperty' -Value $t.IsAbstract -PassThru |
        Add-Member -Name IsAnsiClass -MemberType 'NoteProperty' -Value $t.IsAnsiClass -PassThru |
        Add-Member -Name IsArray -MemberType 'NoteProperty' -Value $t.IsArray -PassThru |
        Add-Member -Name IsAutoClass -MemberType 'NoteProperty' -Value $t.IsAutoClass -PassThru |
        Add-Member -Name IsAutoLayout -MemberType 'NoteProperty' -Value $t.IsAutoLayout -PassThru |
        Add-Member -Name IsByRef -MemberType 'NoteProperty' -Value $t.IsByRef -PassThru |
        Add-Member -Name IsClass -MemberType 'NoteProperty' -Value $t.IsClass -PassThru |
        Add-Member -Name IsCOMObject -MemberType 'NoteProperty' -Value $t.IsCOMObject -PassThru |
        Add-Member -Name IsContextful -MemberType 'NoteProperty' -Value $t.IsContextful -PassThru |
        Add-Member -Name IsEnum -MemberType 'NoteProperty' -Value $t.IsEnum -PassThru |
        Add-Member -Name IsExplicitLayout -MemberType 'NoteProperty' -Value $t.IsExplicitLayout -PassThru |
        Add-Member -Name IsGenericParameter -MemberType 'NoteProperty' -Value $t.IsGenericParameter -PassThru |
        Add-Member -Name IsGenericType -MemberType 'NoteProperty' -Value $t.IsGenericType -PassThru |
        Add-Member -Name IsGenericTypeDefinition -MemberType 'NoteProperty' -Value $t.IsGenericTypeDefinition -PassThru |
        Add-Member -Name IsImport -MemberType 'NoteProperty' -Value $t.IsImport -PassThru |
        Add-Member -Name IsInterface -MemberType 'NoteProperty' -Value $t.IsInterface -PassThru |
        Add-Member -Name IsLayoutSequential -MemberType 'NoteProperty' -Value $t.IsLayoutSequential -PassThru |
        Add-Member -Name IsMarshalByRef -MemberType 'NoteProperty' -Value $t.IsMarshalByRef -PassThru |
        Add-Member -Name IsNested -MemberType 'NoteProperty' -Value $t.IsNested -PassThru |
        Add-Member -Name IsNestedAssembly -MemberType 'NoteProperty' -Value $t.IsNestedAssembly -PassThru |
        Add-Member -Name IsNestedFamANDAssem -MemberType 'NoteProperty' -Value $t.IsNestedFamANDAssem -PassThru |
        Add-Member -Name IsNestedFamily -MemberType 'NoteProperty' -Value $t.IsNestedFamily -PassThru |
        Add-Member -Name IsNestedFamORAssem -MemberType 'NoteProperty' -Value $t.IsNestedFamORAssem -PassThru |
        Add-Member -Name IsNestedPrivate -MemberType 'NoteProperty' -Value $t.IsNestedPrivate -PassThru |
        Add-Member -Name IsNestedPublic -MemberType 'NoteProperty' -Value $t.IsNestedPublic -PassThru |
        Add-Member -Name IsNotPublic -MemberType 'NoteProperty' -Value $t.IsNotPublic -PassThru |
        Add-Member -Name IsPointer -MemberType 'NoteProperty' -Value $t.IsPointer -PassThru |
        Add-Member -Name IsPrimitive -MemberType 'NoteProperty' -Value $t.IsPrimitive -PassThru |
        Add-Member -Name IsPublic -MemberType 'NoteProperty' -Value $t.IsPublic -PassThru |
        Add-Member -Name IsSealed -MemberType 'NoteProperty' -Value $t.IsSealed -PassThru |
        Add-Member -Name IsSerializable -MemberType 'NoteProperty' -Value $t.IsSerializable -PassThru |
        Add-Member -Name IsSpecialName -MemberType 'NoteProperty' -Value $t.IsSpecialName -PassThru |
        Add-Member -Name IsUnicodeClass -MemberType 'NoteProperty' -Value $t.IsUnicodeClass -PassThru |
        Add-Member -Name IsValueType -MemberType 'NoteProperty' -Value $t.IsValueType -PassThru |
        Add-Member -Name IsVisible -MemberType 'NoteProperty' -Value $t.IsVisible -PassThru |
        Add-Member -Name LastAccessTime -MemberType 'NoteProperty' -Value $f.LastAccessTime -PassThru |
        Add-Member -Name LastAccessTimeUtc -MemberType 'NoteProperty' -Value $f.LastAccessTimeUtc -PassThru |
        Add-Member -Name LastWriteTime -MemberType 'NoteProperty' -Value $f.LastWriteTime -PassThru |
        Add-Member -Name LastWriteTimeUtc -MemberType 'NoteProperty' -Value $f.LastWriteTimeUtc -PassThru |
        Add-Member -Name MemberType -MemberType 'NoteProperty' -Value $t.MemberType -PassThru |
        Add-Member -Name MetadataToken -MemberType 'NoteProperty' -Value $t.MetadataToken -PassThru |
        Add-Member -Name Module -MemberType 'NoteProperty' -Value $t.Module -PassThru |
        Add-Member -Name Name -MemberType 'NoteProperty' -Value $t.Name -PassThru |
        Add-Member -Name Namespace -MemberType 'NoteProperty' -Value $t.Namespace -PassThru |
        Add-Member -Name Parent -MemberType 'NoteProperty' -Value $f.Parent -PassThru |
        Add-Member -Name ReflectedType -MemberType 'NoteProperty' -Value $t.ReflectedType -PassThru |
        Add-Member -Name Root -MemberType 'NoteProperty' -Value $f.Root -PassThru |
        Add-Member -Name StructLayoutAttribute -MemberType 'NoteProperty' -Value $t.StructLayoutAttribute -PassThru |
        Add-Member -Name TypeHandle -MemberType 'NoteProperty' -Value $t.TypeHandle -PassThru |
        Add-Member -Name TypeInitializer -MemberType 'NoteProperty' -Value $t.TypeInitializer -PassThru |
        Add-Member -Name UnderlyingSystemType -MemberType 'NoteProperty' -Value $t.UnderlyingSystemType -PassThru |
        Add-Member -Name PSChildName -MemberType 'NoteProperty' -Value $f.PSChildName -PassThru |
        Add-Member -Name PSDrive -MemberType 'NoteProperty' -Value $f.PSDrive -PassThru |
        Add-Member -Name PSIsContainer -MemberType 'NoteProperty' -Value $f.PSIsContainer -PassThru |
        Add-Member -Name PSParentPath -MemberType 'NoteProperty' -Value $f.PSParentPath -PassThru |
        Add-Member -Name PSPath -MemberType 'NoteProperty' -Value $f.PSPath -PassThru |
        Add-Member -Name PSProvider -MemberType 'NoteProperty' -Value $f.PSProvider -PassThru |
        Add-Member -Name BaseName -MemberType 'NoteProperty' -Value $f.BaseName -PassThru |
        Add-Member -Name Clone -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name CompareTo -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Contains -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name CopyTo -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Create -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name CreateObjRef -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name CreateSubdirectory -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Delete -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name EndsWith -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name FindInterfaces -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name FindMembers -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetAccessControl -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetArrayRank -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetConstructor -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetConstructors -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetCustomAttributes -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetDefaultMembers -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetDirectories -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetElementType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetEnumerator -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetEvent -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetEvents -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetField -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetFields -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetFiles -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetFileSystemInfos -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetGenericArguments -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetGenericParameterConstraints -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetGenericTypeDefinition -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetInterface -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetInterfaceMap -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetInterfaces -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetLifetimeService -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetMember -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetMembers -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetMethod -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetMethods -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetNestedType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetNestedTypes -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetObjectData -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetProperties -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetProperty -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name GetTypeCode -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IndexOf -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IndexOfAny -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name InitializeLifetimeService -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Insert -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name InvokeMember -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IsAssignableFrom -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IsDefined -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IsInstanceOfType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IsNormalized -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name IsSubclassOf -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name LastIndexOf -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name LastIndexOfAny -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name MakeArrayType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name MakeByRefType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name MakeGenericType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name MakePointerType -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name MoveTo -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Normalize -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name PadLeft -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name PadRight -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Refresh -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Remove -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Replace -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name SetAccessControl -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Split -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name StartsWith -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Substring -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name ToCharArray -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name ToLower -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name ToLowerInvariant -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name ToUpper -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name ToUpperInvariant -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Trim -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name TrimEnd -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name TrimStart -MemberType 'ScriptMethod' -Value {} -PassThru |
        Add-Member -Name Chars -MemberType 'NoteProperty' -Value $s.Chars -PassThru
    }


    if ( &quot;Add-Member&quot; -eq $_cmdlet )
    {
        $global:_dummy = $null
    }


    if ( &quot;Compare-Object&quot; -eq $_cmdlet )
    {
        $global:_dummy =  (Compare-Object 1 2)[0]
    }


    if ( &quot;ConvertFrom-SecureString&quot; -eq $_cmdlet )
    {
        $global:_dummy = $null
    }


    if ( &quot;ConvertTo-SecureString&quot; -eq $_cmdlet )
    {
        $global:_dummy = convertto-securestring &quot;P@ssW0rD!&quot; -asplaintext -force
    }


    if ( &quot;ForEach-Object&quot; -eq $_cmdlet )
    {
        $global:_dummy = $null
    }


    if ( &quot;Get-Acl&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Acl
    }


    if ( &quot;Get-Alias&quot; -eq $_cmdlet )
    {
        $global:_dummy = (Get-Alias)[0]
    }


    if ( &quot;Get-AuthenticodeSignature&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-AuthenticodeSignature $PSHOME\powershell.exe
    }


    if ( &quot;Get-ChildItem&quot; -eq $_cmdlet )
    {
        $global:_dummy = $global:_forgci
    }


    if ( &quot;Get-Command&quot; -eq $_cmdlet )
    {
        $global:_dummy = @(iex $str[$i+1])[0]
    }


    if ( &quot;Get-Content&quot; -eq $_cmdlet )
    {
        $global:_dummy = (type $PSHOME\profile.ps1)[0]
    }


    if ( &quot;Get-Credential&quot; -eq $_cmdlet )
    {
        $global:_dummy = $null
    }


    if ( &quot;Get-Culture&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Culture
    }


    if ( &quot;Get-Date&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Date
    }


    if ( &quot;Get-Event&quot; -eq $_cmdlet )
    {
        $global:_dummy = (Get-Event)[0]
    }


    if ( &quot;Get-EventLog&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-EventLog Windows` PowerShell -Newest 1
    }


    if ( &quot;Get-ExecutionPolicy&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-ExecutionPolicy
    }


    if ( &quot;Get-Help&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Help Add-Content
    }


    if ( &quot;Get-History&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-History -Count 1
    }


    if ( &quot;Get-Host&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Host
    }


    if ( &quot;Get-Item&quot; -eq $_cmdlet )
    {
        $global:_dummy = $global:_forgci
    }


    if ( &quot;Get-ItemProperty&quot; -eq $_cmdlet )
    {
        $global:_dummy = $null
    }


    if ( &quot;Get-Location&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Location
    }


    if ( &quot;Get-Member&quot; -eq $_cmdlet )
    {
        $global:_dummy = (1|Get-Member)[0]
    }


    if ( &quot;Get-Module&quot; -eq $_cmdlet )
    {
        $global:_dummy = (Get-Module)[0]
    }


    if ( &quot;Get-PfxCertificate&quot; -eq $_cmdlet )
    {
        $global:_dummy = $null
    }


    if ( &quot;Get-Process&quot; -eq $_cmdlet )
    {
        $global:_dummy = ps powershell
    }


    if ( &quot;Get-PSBreakpoint&quot; -eq $_cmdlet )
    {
        $global:_dummy =
        Add-Member -InputObject (New-Object PSObject) -Name Action -MemberType 'NoteProperty' -Value '' -PassThru |
        Add-Member -Name Command -MemberType 'NoteProperty' -Value '' -PassThru |
        Add-Member -Name Enabled -MemberType 'NoteProperty' -Value '' -PassThru |
        Add-Member -Name HitCount -MemberType 'NoteProperty' -Value '' -PassThru |
        Add-Member -Name Id -MemberType 'NoteProperty' -Value '' -PassThru |
        Add-Member -Name Script -MemberType 'NoteProperty' -Value '' -PassThru
    }


    if ( &quot;Get-PSCallStack&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-PSCallStack
    }


    if ( &quot;Get-PSDrive&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-PSDrive Function
    }


    if ( &quot;Get-PSProvider&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-PSProvider FileSystem
    }


    if ( &quot;Get-PSSnapin&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-PSSnapin Microsoft.PowerShell.Core
    }


    if ( &quot;Get-Service&quot; -eq $_cmdlet )
    {
        $global:_dummy = (Get-Service)[0]
    }


    if ( &quot;Get-TraceSource&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-TraceSource AddMember
    }


    if ( &quot;Get-UICulture&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-UICulture
    }


    if ( &quot;Get-Variable&quot; -eq $_cmdlet )
    {
        $global:_dummy = Get-Variable _
    }


    if ( &quot;Get-WmiObject&quot; -eq $_cmdlet )
    {
        $global:_dummy = @(iex $str[$i+1])[0]
    }


    if ( &quot;Group-Object&quot; -eq $_cmdlet )
    {
        $global:_dummy = 1 | group
    }


    if ( &quot;Measure-Command&quot; -eq $_cmdlet )
    {
        $global:_dummy = Measure-Command {}
    }


    if ( &quot;Measure-Object&quot; -eq $_cmdlet )
    {
        $global:_dummy = Measure-Object
    }


    if ( &quot;New-PSDrive&quot; -eq $_cmdlet )
    {
        $global:_dummy =  Get-PSDrive Alias
    }


    if ( &quot;New-TimeSpan&quot; -eq $_cmdlet )
    {
        $global:_dummy = New-TimeSpan
    }


    if ( &quot;Resolve-Path&quot; -eq $_cmdlet )
    {
        $global:_dummy = $PWD
    }


    if ( &quot;Select-String&quot; -eq $_cmdlet )
    {
        $global:_dummy = &quot; &quot; | Select-String &quot; &quot;
    }


    if ( &quot;Set-Date&quot; -eq $_cmdlet )
    {
        $global:_dummy =  Get-Date
    }

    if ( $property -ne $null)
    {
        foreach ( $name in $property.Split(&quot;;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) )
        {
        $global:_dummy = @($global:_dummy.$name)[0]
        }
    }
}

function Set-CommandLine ( [string]$script ) { $global:_cmdline.Add($script) }

function Get-CommandLine ( [string]$name ) {
$name = $name -replace '\?','`?'
$global:_cmdline -like &quot;$name*&quot;
}


function TabExpansion {
            # This is the default function to use for tab expansion. It handles simple
            # member expansion on variables, variable name expansion and parameter completion
            # on commands. It doesn't understand strings so strings containing ; | ( or { may
            # cause expansion to fail.

            param($line, $lastWord)

            &amp; {
                # Helper function to write out the matching set of members. It depends
                # on dynamic scoping to get $_base, _$expression and $_pat
                function Write-Members ($sep='.')
                {

                    # evaluate the expression to get the object to examine...
                    Invoke-Expression ('$_val=' + $_expression)

                    if ( $_expression -match '^\$global:_dummy' )
                    {
                        $temp = $_expression -replace '^\$global:_dummy(.*)','$1'
                        $_expression = '$_' + $temp
                    }


                    $_method = [Management.Automation.PSMemberTypes] `
                        'Method,CodeMethod,ScriptMethod,ParameterizedProperty'

                    if ($sep -eq '.')
                    {
                        $members = 
                            (
                                [Object[]](Get-Member -InputObject $_val.PSextended $_pat) + 
                                [Object[]](Get-Member -InputObject $_val.PSadapted $_pat) + 
                                [Object[]](Get-Member -InputObject $_val.PSbase $_pat)
                            )
                        if ( $_val -is [Hashtable] )
                        {
                            [Microsoft.PowerShell.Commands.MemberDefinition[]]$_keys = $null
                            foreach ( $_name in $_val.Keys )
                            {
                                $_keys += `
                                New-Object Microsoft.PowerShell.Commands.MemberDefinition `
                                [int],$_name,&quot;Property&quot;,0
                            }

                            $members += [Object[]]$_keys | ? { $_.Name -like $_pat }
                        }

                        foreach ($_m in $members | sort membertype,name -Unique)
                            {
                                if ($_m.MemberType -band $_method)
                                {
                                    # Return a method...
                                    $_base + $_expression + $sep + $_m.name + '('
                                }
                                else {
                                    # Return a property...
                                    $_base + $_expression + $sep + $_m.name
                                }
                            }
                        }

                    else
                    {
                    foreach ($_m in Get-Member -Static -InputObject $_val $_pat |
                        Sort-Object membertype,name)
                       {
                           if ($_m.MemberType -band $_method)
                           {
                               # Return a method...
                               $_base + $_expression + $sep + $_m.name + '('
                           }
                           else {
                               # Return a property...
                               $_base + $_expression + $sep + $_m.name
                           }
                        }
                    }
                }


                switch ([int]$line[-1])
                {
                    # Ctrl+D several date/time formats
                    4 {
                        &quot;[DateTime]::Now&quot;
                        [DateTime]::Now
                        [DateTime]::Now.ToString(&quot;yyyyMMdd&quot;)
                        [DateTime]::Now.ToString(&quot;MMddyyyy&quot;)
                        [DateTime]::Now.ToString(&quot;yyyyMMddHHmmss&quot;)
                        [DateTime]::Now.ToString(&quot;MMddyyyyHHmmss&quot;)
                        'd f g m o r t u y'.Split(&quot; &quot;) | % { [DateTime]::Now.ToString($_) }
                        break TabExpansion;
                    }

                    # Ctrl+K put parentheses behind space or semi-coron or pipe operator
                    11 {
                        if ( $line -ne $( &quot;=&quot; + [Char]11 ) )
                        {
                            if ( $line[-2] -eq 11 )
                            {
                                $left = '$' + &quot;(&quot;
                                $line = $line.Substring(0,$line.length-2)
                            }
                            else
                            {
                                $left = &quot;(&quot;
                                $line = $line.Substring(0,$line.length-1)
                            }

                            $global:_ctrlk = @()
                            $l = $line.Length
                            while ( $l -ge 0 )
                            {
                                $i = $line.Substring(0,$l).LastIndexOfAny(&quot; ;|&quot;)
                                $global:_ctrlk += $line.Insert($i+1, $left) + &quot;)&quot;
                                $l = $i
                            }
                            $global:_ctrlk += $line
                            [Windows.Forms.SendKeys]::SendWait(&quot;{Esc}=^K{TAB}&quot;)
                        }
                        else {
                            $global:_ctrlk
                        }
                        break TabExpansion;
                    }

                    # Ctrl+L a part of history commands expansion
                    12 {
                        Get-CommandLine $lastWord.SubString(0, $lastword.Length-1)
                        break TabExpansion;
                    }

                    # Ctrl+P hand-operated pop from command buffer stack
                    16 {
                        $_base = $lastword.SubString(0, $lastword.Length-1)
                        $_buf = $global:_cmdstack.Pop()
                        if ( $_buf.Contains(&quot;'&quot;) )
                        {
                            $line = ($line.SubString(0, $line.Length-1) + $_buf) -replace '([[\]\(\)+{}?~%])','{$1}'
                            [System.Windows.Forms.SendKeys]::SendWait(&quot;{Esc}$line&quot;)
                        }
                        else {
                            $_base + $_buf
                        }
                        break TabExpansion;
                    }

                    # Ctrl+R $Host.UI.RawUI.
                    18 {
                        '$Host.UI.RawUI.'
                        '$Host.UI.RawUI'
                        break TabExpansion;
                    }

                    # Ctrl+V paste clipboard
                    22 {
                        $_base = $lastword.SubString(0, $lastword.Length-1)
                        $global:_clip = New-Object System.Windows.Forms.TextBox
                        $global:_clip.Multiline = $true
                        $global:_clip.Paste()
                        $line = ($line.SubString(0, $line.Length-1) + $global:_clip.Text) -replace '([[\]\(\)+{}?~%])','{$1}'
                        [System.Windows.Forms.SendKeys]::SendWait(&quot;{Esc}$line&quot;)
                        break TabExpansion;
                    }

                    # Ctrl+X cut current line
                    24 {
                        $_clip = new-object System.Windows.Forms.TextBox;
                        $_clip.Multiline = $true;
                        $_clip.Text = $line.SubString(0, $line.Length-1)
                        $_clip.SelectAll()
                        $_clip.Copy()
                        [System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
                        break TabExpansion;
                    }

                    # Ctrl+Z cut last word in current line
                    26 {
                        $line.SubString(0, $line.Length-1) -match '(^(.*\s)([^\s]*)$)|(^[^\s]*$)' | Out-Null
                        $_clip = new-object System.Windows.Forms.TextBox;
                        $_clip.Multiline = $true;
                        $_clip.Text = $Matches[3]
                        $_clip.SelectAll()
                        $_clip.Copy()
                        [System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
                        $line = $Matches[2] -replace '([[\]\(\)+{}?~%])','{$1}'
                        [System.Windows.Forms.SendKeys]::SendWait($line)
                        break TabExpansion;
                    }
                }

                switch ( [int]$line[-2] )
                {

                    # Ctrl+K put character behind space or semi-coron or pipe operator
                    11 {
                        switch ( $line[-1] )
                        {
                            '{' { $right = '}' }
                            '(' { $right = ')' }
                            '[' { $right = ']' }
                        }

                        $left = $line[-1]
                        $delimiter = &quot; ;|&quot;

                        if ( $line[-3] -eq 11 )
                        {
                            if ( $line[-1] -eq '%' -or $line[-1] -eq '?' )
                            {
                                $left = ' ' + $left + ' {'; $right = '}'
                                $delimiter = '|'
                            }
                            else
                            {
                                $left = '$' + $left
                            }
                            $line = $line.Substring(0,$line.length-3)
                        }
                        else
                        {
                            $line = $line.Substring(0,$line.length-2)
                        }

                        $global:_ctrlk = @()
                        $l = $line.Length
                        while ( $l -ge 0 )
                        {
                            $i = $line.Substring(0,$l).LastIndexOfAny($delimiter)
                            $global:_ctrlk += $line.Insert($i+1, $left) + $right
                            $l = $i
                        }
                        $global:_ctrlk += $line
                        [Windows.Forms.SendKeys]::SendWait(&quot;{Esc}=^K{TAB}&quot;)
                        break TabExpansion;
                    }

                    # Ctrl+X cut words with a character after Ctrl+X until the character
                    24 {
                        $line.SubString(0, $line.Length-2) -match &quot;(^(.*$($line[-1]))([^$($line[-1])]*)`$)|(^[^\$($line[-1])]*`$)&quot; | Out-Null
                        $_clip = new-object System.Windows.Forms.TextBox;
                        $_clip.Multiline = $true;
                        $_clip.Text = $Matches[3]
                        $_clip.SelectAll()
                        $_clip.Copy()
                        [System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
                        $line = $Matches[2] -replace '([[\]\(\)+{}?~%])','{$1}'
                        [System.Windows.Forms.SendKeys]::SendWait($line)
                        break TabExpansion;
                    }
                }

                switch -regex ($lastWord)
                {

                    # Handle property and method expansion at '$_'
                    '(^.*)(\$_\.)(\w*)$' {
                        $_base = $matches[1]
                        $_expression = '$global:_dummy'
                        $_pat = $matches[3] + '*'
                        $global:_dummy = $null
                        Get-PipeLineObject
                        if ( $global:_dummy -eq $null )
                        {

                            if ( $global:_exp -match '^\$.*\(.*$' )
                            {
                                $type = ( iex $_exp.Split(&quot;(&quot;)[0] ).OverloadDefinitions[0].Split(&quot; &quot;)[0] -replace '\[[^\[\]]*\]$' -as [type]

                                if ( $_expression -match '^\$global:_dummy' )
                                {
                                    $temp = $_expression -replace '^\$global:_dummy(.*)','$1'
                                    $_expression = '$_' + $temp
                                }

                                foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
                                {
                                   if ($_m.MemberType -eq &quot;Method&quot;)
                                   {
                                       $_base + $_expression + '.' + $_m.name + '('
                                   }
                                   else {
                                       $_base + $_expression + '.' + $_m.name
                                   }
                                }
                                break;
                            }
                            elseif ( $global:_exp -match '^\[.*\:\:.*\(.*$' )
                            {
                                $tname, $mname = $_exp.Split(&quot;:(&quot;, &quot;RemoveEmptyEntries&quot;-as [System.StringSplitOptions])[0,1]
                                $type = @(iex ($tname + '.GetMember(&quot;' + $mname + '&quot;)'))[0].ReturnType.FullName -replace '\[[^\[\]]*\]$' -as [type]

                                if ( $_expression -match '^\$global:_dummy' )
                                {
                                    $temp = $_expression -replace '^\$global:_dummy(.*)','$1'
                                    $_expression = '$_' + $temp
                                }

                                foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
                                {
                                   if ($_m.MemberType -eq &quot;Method&quot;)
                                   {
                                       $_base + $_expression + '.' + $_m.name + '('
                                   }
                                   else {
                                       $_base + $_expression + '.' + $_m.name
                                   }
                                }
                                break;
                            }
                            elseif ( $global:_exp -match '^(\$\w+(\[[0-9,\.]+\])*(\.\w+(\[[0-9,\.]+\])*)*)$' )
                            {
                                $global:_dummy = @(iex $Matches[1])[0]
                            }
                            else
                            {
                                $global:_dummy =  $global:_mix
                            }
                        }

                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at variables...
                    # e.g. $a.b.&lt;tab&gt;
                    '(^.*)(\$(\w|\.)+)\.(\w*)$' {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        [void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
                        $_pat = $matches[4] + '*'
                        if ( $_expression -match '^\$_\.' )
                        {
                            $_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
                        }
                        Write-Members
                        break;
                    }

                    # Handle simple property and method expansion on static members...
                    # e.g. [datetime]::n&lt;tab&gt;
                    '(^.*)(\[(\w|\.)+\])\:\:(\w*)$' {
                        $_base = $matches[1]
                        $_expression = $matches[2]
                        $_pat = $matches[4] + '*'
                        Write-Members '::'
                        break;
                    }

                    # Handle complex property and method expansion on static members
                    # where there are intermediate properties...
                    # e.g. [datetime]::now.d&lt;tab&gt;
                    '(^.*)(\[(\w|\.)+\]\:\:(\w+\.)+)(\w*)$' {
                        $_base = $matches[1]  # everything before the expression
                        $_expression = $matches[2].TrimEnd('.') # expression less trailing '.'
                        $_pat = $matches[5] + '*'  # the member to look for...
                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at variables...
                    # e.g. { 1+1 }.inv&lt;tab&gt;
                    '(^.*})\.(\w*)$' {
                        $_base = $matches[1]
                        $_pat = $matches[2] + '*'
                        foreach ( $_m in {} | Get-Member $_pat | sort membertype,name )
                        {
                            if ($_m.MemberType -eq &quot;Method&quot;)
                            {
                                $_base + '.' + $_m.name + '('
                            }
                            else {
                                $_base + '.' + $_m.name
                            }
                        }
                        break;
                    }

                    # Handle variable name expansion...
                    '(^.*\$)(\w+)$' {
                        $_prefix = $matches[1]
                        $_varName = $matches[2]
                        foreach ($_v in Get-ChildItem ('variable:' + $_varName + '*'))
                        {
                            $_prefix + $_v.name
                        }
                        break;
                    }

                    # Handle item name expansion in variable notation...
                    '(^.*\${)(((\w+):([\\/]?))[^\\/]+([\\/][^\\/]*)*)$' {
                        $_prefix = $matches[1]
                        $_driveName = $matches[3]
                        $_itemName = $matches[2] + &quot;*&quot;
                        Get-ChildItem $_itemName  |
                        % {
                            if ( $matches[5] -and $_.PSProvider.Name -eq &quot;FileSystem&quot; )
                            {
                                $output = $_prefix + $_.FullName
                            }
                            elseif ( $_.PSProvider.Name -eq &quot;FileSystem&quot; -and $matches[6] )
                            {
                                $cd = (Get-Location -PSDrive $matches[4]).Path
                                $output = $_prefix + $_driveName + $_.FullName.Substring($cd.Length+1)
                            }
                            elseif ( $_.PSProvider.Name -eq &quot;FileSystem&quot; )
                            {
                                $cd = (Get-Location -PSDrive $matches[4]).Path
                                $output = $_prefix + $_driveName + $_.FullName.Substring($cd.Length+1)
                            }
                            else
                            {
                                $output = $_prefix + $_driveName + $_.Name
                            }

                            if ( $_.PSIsContainer )
                            {
                                $output
                            }
                            else
                            {
                                $output + &quot;}&quot;
                            }
                        }
                        break;
                    }

                    # Handle PSDrive name expansion in variable notation...
                    '(^.*\${)(\w+)$' {
                        $_prefix = $matches[1]
                        $_driveName = $matches[2] + &quot;*&quot;
                        Get-PSDrive $_driveName | % { $_prefix + $_ + ':' }
                        break;
                    }

                    # Handle env&amp;function drives variable name expansion...
                    '(^.*\$)(.*\:)(\w+)$' {
                        $_prefix = $matches[1]
                        $_drive = $matches[2]
                        $_varName = $matches[3]
                        if ($_drive -eq &quot;env:&quot; -or $_drive -eq &quot;function:&quot;)
                        {
                            foreach ($_v in Get-ChildItem ($_drive + $_varName + '*'))
                            {
                                $_prefix + $_drive + $_v.name
                            }
                        }
                        break;
                    }

                    # Handle array's element property and method expansion
                    # where there are intermediate properties...
                    # e.g. foo[0].n.b&lt;tab&gt;
                    '(^.*)(\$((\w+\.)|(\w+(\[(\w|,)+\])+\.))+)(\w*)$'
                    {
                        $_base = $matches[1]
                        $_expression = $matches[2].TrimEnd('.')
                        $_pat = $Matches[8] + '*'
                        [void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
                        if ( $_expression -match '^\$_\.' )
                        {
                            $_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
                        }
                        Write-Members
                        break;
                    }

                    # Handle property and method expansion rooted at type object...
                    # e.g. [System.Type].a&lt;tab&gt;
                    '(^\[(\w|\.)+\])\.(\w*)$'
                    {
                        if ( $(iex $Matches[1]) -isnot [System.Type] ) { break; }
                        $_expression = $Matches[1]
                        $_pat = $Matches[$matches.Count-1] + '*'
                        Write-Members
                        break;
                    }

                    # Handle complex property and method expansion on type object members
                    # where there are intermediate properties...
                    # e.g. [datetime].Assembly.a&lt;tab&gt;
                    '^(\[(\w|\.)+\]\.(\w+\.)+)(\w*)$' {
                        $_expression = $matches
</code></pre>

</div>

    <footer class="blog-footer">
        <p>&copy; Joel &quot;Jaykul&quot; Bennett 2018</p>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>