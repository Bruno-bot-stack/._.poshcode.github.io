
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="Sign up for PowerShell.Slack.com">
    <meta name="author" content="Timothy A King">
    <title>PowerShell_ISE Profile - PoshCode</title>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" data-tabs="tabs" id="tabs">
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video" data-toggle="tab">Video Feed</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

    

<div class="blog-post">
    <h2 class="blog-post-title">PowerShell_ISE Profile</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2012-04-18</span> by <a class="blog-post-author">Timothy A King</a>
    </p>

    <h1>PowerShell_ISE Profile</h1>
<h3><a href="//scripts/3372.ps1">download</a> - <a href="//scripts/3000.md">parent</a></h3>
<p>http://trac.osgeo.org/proj/) functions.
4<br />
5  Performs cartographic transformations and geodetic computations.
6<br />
7  The Proj class can convert from geographic (longitude,latitude)
8  to native map projection (x,y) coordinates and vice versa, or
9  from one map projection coordinate system directly to another.
10  The module variable pj_list is a dictionary containing all the<br />
11  available projections and their descriptions.
12<br />
13  The Geod class can perform forward and inverse geodetic, or
14  Great Circle, computations.  The forward computation involves
15  determining latitude, longitude and back azimuth of a terminus
16  point given the latitude and longitude of an initial point, plus
17  azimuth and distance. The inverse computation involves
18  determining the forward and back azimuths and distance given the
19  latitudes and longitudes of an initial and terminus point.
20<br />
21  Input coordinates can be given as python arrays, lists/tuples,
22  scalars or numpy/Numeric/numarray arrays. Optimized for objects
23  that support the Python buffer protocol (regular python and
24  numpy array objects).
25<br />
26  Download: http://code.google.com/p/pyproj/downloads/list
27<br />
28  Requirements: python 2.4 or higher.
29<br />
30  Example scripts are in 'test' subdirectory of source distribution.
31  The 'test()' function will run the examples in the docstrings.
32<br />
33  Contact:  Jeffrey Whitaker &lt;jeffrey.s.whitaker@noaa.gov
34<br />
35  copyright (c) 2006 by Jeffrey Whitaker.
36<br />
37  Permission to use, copy, modify, and distribute this software
38  and its documentation for any purpose and without fee is hereby
39  granted, provided that the above copyright notice appear in all
40  copies and that both the copyright notice and this permission
41  notice appear in supporting documentation. THE AUTHOR DISCLAIMS
42  ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
43  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT
44  SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
45  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
46  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
47  NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
48  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. &quot;&quot;&quot;
49<br />
50  from pyproj import _proj
51  from pyproj.geodesic import Geodesic
52  <strong>version</strong> =  _proj.<strong>version</strong>
53  set_datapath =  _proj.set_datapath
54  from array import array
55  import os, math
56  #import numpy as np
57  pj_list={
58  'aea': &quot;Albers Equal Area&quot;,
59  'aeqd': &quot;Azimuthal Equidistant&quot;,
60  'airy': &quot;Airy&quot;,
61  'aitoff': &quot;Aitoff&quot;,
62  'alsk': &quot;Mod. Stererographics of Alaska&quot;,
63  'apian': &quot;Apian Globular I&quot;,
64  'august': &quot;August Epicycloidal&quot;,
65  'bacon': &quot;Bacon Globular&quot;,
66  'bipc': &quot;Bipolar conic of western hemisphere&quot;,
67  'boggs': &quot;Boggs Eumorphic&quot;,
68  'bonne': &quot;Bonne (Werner lat_1=90)&quot;,
69  'cass': &quot;Cassini&quot;,
70  'cc': &quot;Central Cylindrical&quot;,
71  'cea': &quot;Equal Area Cylindrical&quot;,
72  'chamb': &quot;Chamberlin Trimetric&quot;,
73  'collg': &quot;Collignon&quot;,
74  'crast': &quot;Craster Parabolic (Putnins P4)&quot;,
75  'denoy': &quot;Denoyer Semi-Elliptical&quot;,
76  'eck1': &quot;Eckert I&quot;,
77  'eck2': &quot;Eckert II&quot;,
78  'eck3': &quot;Eckert III&quot;,
79  'eck4': &quot;Eckert IV&quot;,
80  'eck5': &quot;Eckert V&quot;,
81  'eck6': &quot;Eckert VI&quot;,
82  'eqc': &quot;Equidistant Cylindrical (Plate Caree)&quot;,
83  'eqdc': &quot;Equidistant Conic&quot;,
84  'etmerc': &quot;Extended Transverse Mercator&quot; ,
85  'euler': &quot;Euler&quot;,
86  'fahey': &quot;Fahey&quot;,
87  'fouc': &quot;Foucaut&quot;,
88  'fouc_s': &quot;Foucaut Sinusoidal&quot;,
89  'gall': &quot;Gall (Gall Stereographic)&quot;,
90  'geocent': &quot;Geocentric&quot;,
91  'geos': &quot;Geostationary Satellite View&quot;,
92  'gins8': &quot;Ginsburg VIII (TsNIIGAiK)&quot;,
93  'gn_sinu': &quot;General Sinusoidal Series&quot;,
94  'gnom': &quot;Gnomonic&quot;,
95  'goode': &quot;Goode Homolosine&quot;,
96  'gs48': &quot;Mod. Stererographics of 48 U.S.&quot;,
97  'gs50': &quot;Mod. Stererographics of 50 U.S.&quot;,
98  'hammer': &quot;Hammer &amp; Eckert-Greifendorff&quot;,
99  'hatano': &quot;Hatano Asymmetrical Equal Area&quot;,
100  'healpix': &quot;HEALPix&quot;,
101  'rhealpix': &quot;rHEALPix&quot;,
102  'igh':  &quot;Interrupted Goode Homolosine&quot;,
103  'imw_p': &quot;Internation Map of the World Polyconic&quot;,
104  'kav5': &quot;Kavraisky V&quot;,
105  'kav7': &quot;Kavraisky VII&quot;,
106  'krovak': &quot;Krovak&quot;,
107  'labrd': &quot;Laborde&quot;,
108  'laea': &quot;Lambert Azimuthal Equal Area&quot;,
109  'lagrng': &quot;Lagrange&quot;,
110  'larr': &quot;Larrivee&quot;,
111  'lask': &quot;Laskowski&quot;,
112  'lonlat': &quot;Lat/long (Geodetic)&quot;,
113  'latlon': &quot;Lat/long (Geodetic alias)&quot;,
114  'latlong': &quot;Lat/long (Geodetic alias)&quot;,
115  'longlat': &quot;Lat/long (Geodetic alias)&quot;,
116  'lcc': &quot;Lambert Conformal Conic&quot;,
117  'lcca': &quot;Lambert Conformal Conic Alternative&quot;,
118  'leac': &quot;Lambert Equal Area Conic&quot;,
119  'lee_os': &quot;Lee Oblated Stereographic&quot;,
120  'loxim': &quot;Loximuthal&quot;,
121  'lsat': &quot;Space oblique for LANDSAT&quot;,
122  'mbt_s': &quot;McBryde-Thomas Flat-Polar Sine&quot;,
123  'mbt_fps': &quot;McBryde-Thomas Flat-Pole Sine (No. 2)&quot;,
124  'mbtfpp': &quot;McBride-Thomas Flat-Polar Parabolic&quot;,
125  'mbtfpq': &quot;McBryde-Thomas Flat-Polar Quartic&quot;,
126  'mbtfps': &quot;McBryde-Thomas Flat-Polar Sinusoidal&quot;,
127  'merc': &quot;Mercator&quot;,
128  'mil_os': &quot;Miller Oblated Stereographic&quot;,
129  'mill': &quot;Miller Cylindrical&quot;,
130  'moll': &quot;Mollweide&quot;,
131  'murd1': &quot;Murdoch I&quot;,
132  'murd2': &quot;Murdoch II&quot;,
133  'murd3': &quot;Murdoch III&quot;,
134  'nell': &quot;Nell&quot;,
135  'nell_h': &quot;Nell-Hammer&quot;,
136  'nicol': &quot;Nicolosi Globular&quot;,
137  'nsper': &quot;Near-sided perspective&quot;,
138  'nzmg': &quot;New Zealand Map Grid&quot;,
139  'ob_tran': &quot;General Oblique Transformation&quot;,
140  'ocea': &quot;Oblique Cylindrical Equal Area&quot;,
141  'oea': &quot;Oblated Equal Area&quot;,
142  'omerc': &quot;Oblique Mercator&quot;,
143  'ortel': &quot;Ortelius Oval&quot;,
144  'ortho': &quot;Orthographic&quot;,
145  'pconic': &quot;Perspective Conic&quot;,
146  'poly': &quot;Polyconic (American)&quot;,
147  'putp1': &quot;Putnins P1&quot;,
148  'putp2': &quot;Putnins P2&quot;,
149  'putp3': &quot;Putnins P3&quot;,
150  'putp3p': &quot;Putnins P3'&quot;,
151  'putp4p': &quot;Putnins P4'&quot;,
152  'putp5': &quot;Putnins P5&quot;,
153  'putp5p': &quot;Putnins P5'&quot;,
154  'putp6': &quot;Putnins P6&quot;,
155  'putp6p': &quot;Putnins P6'&quot;,
156  'qua_aut': &quot;Quartic Authalic&quot;,
157  'robin': &quot;Robinson&quot;,
158  'rouss': &quot;Roussilhe Stereographic&quot;,
159  'rpoly': &quot;Rectangular Polyconic&quot;,
160  'sinu': &quot;Sinusoidal (Sanson-Flamsteed)&quot;,
161  'somerc': &quot;Swiss. Obl. Mercator&quot;,
162  'stere': &quot;Stereographic&quot;,
163  'sterea': &quot;Oblique Stereographic Alternative&quot;,
164  'gstmerc': &quot;Gauss-Schreiber Transverse Mercator (aka Gauss-Laborde Reunion)&quot;,
165  'tcc': &quot;Transverse Central Cylindrical&quot;,
166  'tcea': &quot;Transverse Cylindrical Equal Area&quot;,
167  'tissot': &quot;Tissot Conic&quot;,
168  'tmerc': &quot;Transverse Mercator&quot;,
169  'tpeqd': &quot;Two Point Equidistant&quot;,
170  'tpers': &quot;Tilted perspective&quot;,
171  'ups': &quot;Universal Polar Stereographic&quot;,
172  'urm5': &quot;Urmaev V&quot;,
173  'urmfps': &quot;Urmaev Flat-Polar Sinusoidal&quot;,
174  'utm': &quot;Universal Transverse Mercator (UTM)&quot;,
175  'vandg': &quot;van der Grinten (I)&quot;,
176  'vandg2': &quot;van der Grinten II&quot;,
177  'vandg3': &quot;van der Grinten III&quot;,
178  'vandg4': &quot;van der Grinten IV&quot;,
179  'vitk1': &quot;Vitkovsky I&quot;,
180  'wag1': &quot;Wagner I (Kavraisky VI)&quot;,
181  'wag2': &quot;Wagner II&quot;,
182  'wag3': &quot;Wagner III&quot;,
183  'wag4': &quot;Wagner IV&quot;,
184  'wag5': &quot;Wagner V&quot;,
185  'wag6': &quot;Wagner VI&quot;,
186  'wag7': &quot;Wagner VII&quot;,
187  'weren': &quot;Werenskiold I&quot;,
188  'wink1': &quot;Winkel I&quot;,
189  'wink2': &quot;Winkel II&quot;,
190  'wintri': &quot;Winkel Tripel&quot;}
191<br />
192  pj_ellps={
193  &quot;MERIT&quot;:        {'a':6378137.0,'rf':298.257,'description':&quot;MERIT 1983&quot;},
194  &quot;SGS85&quot;:        {'a':6378136.0,'rf':298.257,'description':&quot;Soviet Geodetic System 85&quot;},
195  &quot;GRS80&quot;:        {'a':6378137.0,'rf':298.257222101,'description':&quot;GRS 1980(IUGG, 1980)&quot;},
196  &quot;IAU76&quot;:        {'a':6378140.0,'rf':298.257,'description':&quot;IAU 1976&quot;},
197  &quot;airy&quot;:         {'a':6377563.396,'b':6356256.910,'description':&quot;Airy 1830&quot;},
198  &quot;APL4.9&quot;:       {'a':6378137.0,'rf':298.25,'description':&quot;Appl. Physics. 1965&quot;},
199  &quot;NWL9D&quot;:        {'a':6378145.0,'rf':298.25,'description':&quot; Naval Weapons Lab., 1965&quot;},
200  &quot;mod_airy&quot;:     {'a':6377340.189,'b':6356034.446,'description':&quot;Modified Airy&quot;},
201  &quot;andrae&quot;:       {'a':6377104.43,'rf':300.0,'description':&quot;Andrae 1876 (Den., Iclnd.)&quot;},
202  &quot;aust_SA&quot;:      {'a':6378160.0,'rf':298.25,'description':&quot;Australian Natl &amp; S. Amer. 1969&quot;},
203  &quot;GRS67&quot;:        {'a':6378160.0,'rf':298.2471674270,'description':&quot;GRS 67(IUGG 1967)&quot;},
204  &quot;bessel&quot;:       {'a':6377397.155,'rf':299.1528128,'description':&quot;Bessel 1841&quot;},
205  &quot;bess_nam&quot;:     {'a':6377483.865,'rf':299.1528128,'description':&quot;Bessel 1841 (Namibia)&quot;},
206  &quot;clrk66&quot;:       {'a':6378206.4,'b':6356583.8,'description':&quot;Clarke 1866&quot;},
207  &quot;clrk80&quot;:       {'a':6378249.145,'rf':293.4663,'description':&quot;Clarke 1880 mod.&quot;},
208  &quot;CPM&quot;:          {'a':6375738.7,'rf':334.29,'description':&quot;Comm. des Poids et Mesures 1799&quot;},
209  &quot;delmbr&quot;:       {'a':6376428.,'rf':311.5,'description':&quot;Delambre 1810 (Belgium)&quot;},
210  &quot;engelis&quot;:      {'a':6378136.05,'rf':298.2566,'description':&quot;Engelis 1985&quot;},
211  &quot;evrst30&quot;:      {'a':6377276.345,'rf':300.8017,'description':&quot;Everest 1830&quot;},
212  &quot;evrst48&quot;:      {'a':6377304.063,'rf':300.8017,'description':&quot;Everest 1948&quot;},
213  &quot;evrst56&quot;:      {'a':6377301.243,'rf':300.8017,'description':&quot;Everest 1956&quot;},
214  &quot;evrst69&quot;:      {'a':6377295.664,'rf':300.8017,'description':&quot;Everest 1969&quot;},
215  &quot;evrstSS&quot;:      {'a':6377298.556,'rf':300.8017,'description':&quot;Everest (Sabah &amp; Sarawak)&quot;},
216  &quot;fschr60&quot;:      {'a':6378166.,'rf':298.3,'description':&quot;Fischer (Mercury Datum) 1960&quot;},
217  &quot;fschr60m&quot;:     {'a':6378155.,'rf':298.3,'description':&quot;Modified Fischer 1960&quot;},
218  &quot;fschr68&quot;:      {'a':6378150.,'rf':298.3,'description':&quot;Fischer 1968&quot;},
219  &quot;helmert&quot;:      {'a':6378200.,'rf':298.3,'description':&quot;Helmert 1906&quot;},
220  &quot;hough&quot;:        {'a':6378270.0,'rf':297.,'description':&quot;Hough&quot;},
221  &quot;intl&quot;:         {'a':6378388.0,'rf':297.,'description':&quot;International 1909 (Hayford)&quot;},
222  &quot;krass&quot;:        {'a':6378245.0,'rf':298.3,'description':&quot;Krassovsky, 1942&quot;},
223  &quot;kaula&quot;:        {'a':6378163.,'rf':298.24,'description':&quot;Kaula 1961&quot;},
224  &quot;lerch&quot;:        {'a':6378139.,'rf':298.257,'description':&quot;Lerch 1979&quot;},
225  &quot;mprts&quot;:        {'a':6397300.,'rf':191.,'description':&quot;Maupertius 1738&quot;},
226  &quot;new_intl&quot;:     {'a':6378157.5,'b':6356772.2,'description':&quot;New International 1967&quot;},
227  &quot;plessis&quot;:      {'a':6376523.,'b':6355863.,'description':&quot;Plessis 1817 (France)&quot;},
228  &quot;SEasia&quot;:       {'a':6378155.0,'b':6356773.3205,'description':&quot;Southeast Asia&quot;},
229  &quot;walbeck&quot;:      {'a':6376896.0,'b':6355834.8467,'description':&quot;Walbeck&quot;},
230  &quot;WGS60&quot;:        {'a':6378165.0,'rf':298.3,'description':&quot;WGS 60&quot;},
231  &quot;WGS66&quot;:        {'a':6378145.0,'rf':298.25,'description':&quot;WGS 66&quot;},
232  &quot;WGS72&quot;:        {'a':6378135.0,'rf':298.26,'description':&quot;WGS 72&quot;},
233  &quot;WGS84&quot;:        {'a':6378137.0,'rf':298.257223563,'description':&quot;WGS 84&quot;},
234  &quot;sphere&quot;:       {'a':6370997.0,'b':6370997.0,'description':&quot;Normal Sphere&quot;},
235  }
236<br />
237  pyproj_datadir = os.sep.join([os.path.dirname(<strong>file</strong>), 'data'])
238  if not os.path.isdir(pyproj_datadir):
239      msg=&quot;proj data directory not found. Expecting it at: %s&quot;%pyproj_datadir
240      raise IOError(msg)
241<br />
242  set_datapath(pyproj_datadir)
243<br />
244 -class Proj(_proj.Proj):</p>
<p>245      &quot;&quot;&quot;
246      performs cartographic transformations (converts from
247      longitude,latitude to native map projection x,y coordinates and
248      vice versa) using proj (http://trac.osgeo.org/proj/).
249<br />
250      A Proj class instance is initialized with proj map projection
251      control parameter key/value pairs. The key/value pairs can
252      either be passed in a dictionary, or as keyword arguments,
253      or as a proj4 string (compatible with the proj command). See
254      http://www.remotesensing.org/geotiff/proj_list for examples of
255      key/value pairs defining different map projections.
256<br />
257      Calling a Proj class instance with the arguments lon, lat will
258      convert lon/lat (in degrees) to x/y native map projection
259      coordinates (in meters).  If optional keyword 'inverse' is True
260      (default is False), the inverse transformation from x/y to
261      lon/lat is performed. If optional keyword 'radians' is True
262      (default is False) lon/lat are interpreted as radians instead of
263      degrees. If optional keyword 'errcheck' is True (default is
264      False) an exception is raised if the transformation is invalid.
265      If errcheck=False and the transformation is invalid, no
266      exception is raised and 1.e30 is returned. If the optional keyword
267      'preserve_units' is True, the units in map projection coordinates
268      are not forced to be meters.
269<br />
270      Works with numpy and regular python array objects, python
271      sequences and scalars.
272      &quot;&quot;&quot;
273<br />
274 -    def <strong>new</strong>(self, projparams=None, preserve_units=False, **kwargs):</p>
<p>275          &quot;&quot;&quot;
276          initialize a Proj class instance.
277<br />
278          Proj4 projection control parameters must either be given in a
279          dictionary 'projparams' or as keyword arguments. See the proj
280          documentation (http://trac.osgeo.org/proj/) for more information
281          about specifying projection parameters.
282<br />
283          Example usage:
284<br />
285          &gt;&gt;&gt; from pyproj import Proj
286          &gt;&gt;&gt; p = Proj(proj='utm',zone=10,ellps='WGS84') # use kwargs
287          &gt;&gt;&gt; x,y = p(-120.108, 34.36116666)
288          &gt;&gt;&gt; 'x=%9.3f y=%11.3f' % (x,y)
289          'x=765975.641 y=3805993.134'
290          &gt;&gt;&gt; 'lon=%8.3f lat=%5.3f' % p(x,y,inverse=True)
291          'lon=-120.108 lat=34.361'
292          &gt;&gt;&gt; # do 3 cities at a time in a tuple (Fresno, LA, SF)
293          &gt;&gt;&gt; lons = (-119.72,-118.40,-122.38)
294          &gt;&gt;&gt; lats = (36.77, 33.93, 37.62 )
295          &gt;&gt;&gt; x,y = p(lons, lats)
296          &gt;&gt;&gt; 'x: %9.3f %9.3f %9.3f' % x
297          'x: 792763.863 925321.537 554714.301'
298          &gt;&gt;&gt; 'y: %9.3f %9.3f %9.3f' % y
299          'y: 4074377.617 3763936.941 4163835.303'
300          &gt;&gt;&gt; lons, lats = p(x, y, inverse=True) # inverse transform
301          &gt;&gt;&gt; 'lons: %8.3f %8.3f %8.3f' % lons
302          'lons: -119.720 -118.400 -122.380'
303          &gt;&gt;&gt; 'lats: %8.3f %8.3f %8.3f' % lats
304          'lats:   36.770   33.930   37.620'
305          &gt;&gt;&gt; p2 = Proj('+proj=utm +zone=10 +ellps=WGS84') # use proj4 string
306          &gt;&gt;&gt; x,y = p2(-120.108, 34.36116666)
307          &gt;&gt;&gt; 'x=%9.3f y=%11.3f' % (x,y)
308          'x=765975.641 y=3805993.134'
309          &gt;&gt;&gt; p = Proj(init=&quot;epsg:32667&quot;)
310          &gt;&gt;&gt; 'x=%12.3f y=%12.3f (meters)' % p(-114.057222, 51.045)
311          'x=-1783486.760 y= 6193833.196 (meters)'
312          &gt;&gt;&gt; p = Proj(&quot;+init=epsg:32667&quot;,preserve_units=True)
313          &gt;&gt;&gt; 'x=%12.3f y=%12.3f (feet)' % p(-114.057222, 51.045)
314          'x=-5851322.810 y=20320934.409 (feet)'
315          &quot;&quot;&quot;
316          # if projparams is None, use kwargs.
317          if projparams is None:
318              if len(kwargs) == 0:
319                  raise RuntimeError('no projection control parameters specified')
320              else:
321                  projstring = _dict2string(kwargs)
322          elif type(projparams) == str:
323              # if projparams is a string, interpret as a proj4 init string.
324              projstring = projparams
325          else: # projparams a dict
326              projstring = _dict2string(projparams)
327          # make sure units are meters if preserve_units is False.
328          if not projstring.count('+units=') and not preserve_units:
329              projstring = '+units=m '+projstring
330          else:
331              kvpairs = []
332              for kvpair in projstring.split():
333                  if kvpair.startswith('+units') and not preserve_units:
334                      k,v = kvpair.split('=')
335                      kvpairs.append(k+'=m ')
336                  else:
337                      kvpairs.append(kvpair+' ')
338              projstring = ''.join(kvpairs)
339          # look for EPSG, replace with epsg (EPSG only works
340          # on case-insensitive filesystems).
341          projstring = projstring.replace('EPSG','epsg')
342          return _proj.Proj.<strong>new</strong>(self, projstring)</p>
<p>343<br />
344 -    def <strong>call</strong>(self, *args, **kw):</p>
<p>345      #,lon,lat,inverse=False,radians=False,errcheck=False):
346          &quot;&quot;&quot;
347          Calling a Proj class instance with the arguments lon, lat will
348          convert lon/lat (in degrees) to x/y native map projection
349          coordinates (in meters).  If optional keyword 'inverse' is True
350          (default is False), the inverse transformation from x/y to
351          lon/lat is performed.  If optional keyword 'radians' is True
352          (default is False) the units of lon/lat are radians instead of
353          degrees. If optional keyword 'errcheck' is True (default is
354          False) an exception is raised if the transformation is invalid.
355          If errcheck=False and the transformation is invalid, no
356          exception is raised and 1.e30 is returned.
357<br />
358          Instead of calling with lon, lat, a single ndarray of
359          shape n,2 may be used, and one of the same shape will
360          be returned; this is more efficient.
361<br />
362          Inputs should be doubles (they will be cast to doubles if they
363          are not, causing a slight performance hit).
364<br />
365          Works with numpy and regular python array objects, python
366          sequences and scalars, but is fastest for array objects.
367          &quot;&quot;&quot;
368          inverse = kw.get('inverse', False)
369          radians = kw.get('radians', False)
370          errcheck = kw.get('errcheck', False)
371          #if len(args) == 1:
372          #    latlon = np.array(args[0], copy=True,
373          #                      order='C', dtype=float, ndmin=2)
374          #    if inverse:
375          #        _proj.Proj._invn(self, latlon, radians=radians, errcheck=errcheck)
376          #    else:
377          #        _proj.Proj._fwdn(self, latlon, radians=radians, errcheck=errcheck)
378          #    return latlon
379          lon, lat = args
380          # process inputs, making copies that support buffer API.
381          inx, xisfloat, xislist, xistuple = _copytobuffer(lon)
382          iny, yisfloat, yislist, yistuple = _copytobuffer(lat)
383          # call proj4 functions. inx and iny modified in place.
384          if inverse:
385              _proj.Proj._inv(self, inx, iny, radians=radians, errcheck=errcheck)
386          else:
387              _proj.Proj._fwd(self, inx, iny, radians=radians, errcheck=errcheck)
388          # if inputs were lists, tuples or floats, convert back.
389          outx = _convertback(xisfloat,xislist,xistuple,inx)
390          outy = _convertback(yisfloat,yislist,xistuple,iny)
391          return outx, outy</p>
<p>392<br />
393 -    def is_latlong(self):</p>
<p>394          &quot;&quot;&quot;returns True if projection in geographic (lon/lat) coordinates&quot;&quot;&quot;
395          return _proj.Proj.is_latlong(self)</p>
<p>396<br />
397 -    def is_geocent(self):</p>
<p>398          &quot;&quot;&quot;returns True if projection in geocentric (x/y) coordinates&quot;&quot;&quot;
399          return _proj.Proj.is_geocent(self)</p>
<p>400<br />
401 -def transform(p1, p2, x, y, z=None, radians=False):</p>
<p>402      &quot;&quot;&quot;
403      x2, y2, z2 = transform(p1, p2, x1, y1, z1, radians=False)
404<br />
405      Transform points between two coordinate systems defined by the
406      Proj instances p1 and p2.
407<br />
408      The points x1,y1,z1 in the coordinate system defined by p1 are
409      transformed to x2,y2,z2 in the coordinate system defined by p2.
410<br />
411      z1 is optional, if it is not set it is assumed to be zero (and
412      only x2 and y2 are returned).
413<br />
414      In addition to converting between cartographic and geographic
415      projection coordinates, this function can take care of datum
416      shifts (which cannot be done using the <strong>call</strong> method of the
417      Proj instances). It also allows for one of the coordinate
418      systems to be geographic (proj = 'latlong').
419<br />
420      If optional keyword 'radians' is True (default is False) and p1
421      is defined in geographic coordinate (pj.is_latlong() is True),
422      x1,y1 is interpreted as radians instead of the default degrees.
423      Similarly, if p2 is defined in geographic coordinates and
424      radians=True, x2, y2 are returned in radians instead of degrees.
425      if p1.is_latlong() and p2.is_latlong() both are False, the
426      radians keyword has no effect.
427<br />
428      x,y and z can be numpy or regular python arrays, python
429      lists/tuples or scalars. Arrays are fastest.  For projections in
430      geocentric coordinates, values of x and y are given in meters.
431      z is always meters.
432<br />
433      Example usage:
434<br />
435      &gt;&gt;&gt; # projection 1: UTM zone 15, grs80 ellipse, NAD83 datum
436      &gt;&gt;&gt; # (defined by epsg code 26915)
437      &gt;&gt;&gt; p1 = Proj(init='epsg:26915')
438      &gt;&gt;&gt; # projection 2: UTM zone 15, clrk66 ellipse, NAD27 datum
439      &gt;&gt;&gt; p2 = Proj(init='epsg:26715')
440      &gt;&gt;&gt; # find x,y of Jefferson City, MO.
441      &gt;&gt;&gt; x1, y1 = p1(-92.199881,38.56694)
442      &gt;&gt;&gt; # transform this point to projection 2 coordinates.
443      &gt;&gt;&gt; x2, y2 = transform(p1,p2,x1,y1)
444      &gt;&gt;&gt; '%9.3f %11.3f' % (x1,y1)
445      '569704.566 4269024.671'
446      &gt;&gt;&gt; '%9.3f %11.3f' % (x2,y2)
447      '569722.342 4268814.027'
448      &gt;&gt;&gt; '%8.3f %5.3f' % p2(x2,y2,inverse=True)
449      ' -92.200 38.567'
450      &gt;&gt;&gt; # process 3 points at a time in a tuple
451      &gt;&gt;&gt; lats = (38.83,39.32,38.75) # Columbia, KC and StL Missouri
452      &gt;&gt;&gt; lons = (-92.22,-94.72,-90.37)
453      &gt;&gt;&gt; x1, y1 = p1(lons,lats)
454      &gt;&gt;&gt; x2, y2 = transform(p1,p2,x1,y1)
455      &gt;&gt;&gt; xy = x1+y1
456      &gt;&gt;&gt; '%9.3f %9.3f %9.3f %11.3f %11.3f %11.3f' % xy
457      '567703.344 351730.944 728553.093 4298200.739 4353698.725 4292319.005'
458      &gt;&gt;&gt; xy = x2+y2
459      &gt;&gt;&gt; '%9.3f %9.3f %9.3f %11.3f %11.3f %11.3f' % xy
460      '567721.149 351747.558 728569.133 4297989.112 4353489.644 4292106.305'
461      &gt;&gt;&gt; lons, lats = p2(x2,y2,inverse=True)
462      &gt;&gt;&gt; xy = lons+lats
463      &gt;&gt;&gt; '%8.3f %8.3f %8.3f %5.3f %5.3f %5.3f' % xy
464      ' -92.220  -94.720  -90.370 38.830 39.320 38.750'
465      &gt;&gt;&gt; # test datum shifting, installation of extra datum grid files.
466      &gt;&gt;&gt; p1 = Proj(proj='latlong',datum='WGS84')
467      &gt;&gt;&gt; x1 = -111.5; y1 = 45.25919444444
468      &gt;&gt;&gt; p2 = Proj(proj=&quot;utm&quot;,zone=10,datum='NAD27')
469      &gt;&gt;&gt; x2, y2 = transform(p1, p2, x1, y1)
470      &gt;&gt;&gt; &quot;%12.3f %12.3f&quot; % (x2,y2)
471      ' 1402285.991  5076292.423'
472      &quot;&quot;&quot;
473      # process inputs, making copies that support buffer API.
474      inx, xisfloat, xislist, xistuple = _copytobuffer(x)
475      iny, yisfloat, yislist, yistuple = _copytobuffer(y)
476      if z is not None:
477          inz, zisfloat, zislist, zistuple = _copytobuffer(z)
478      else:
479          inz = None
480      # call pj_transform.  inx,iny,inz buffers modified in place.
481      _proj._transform(p1,p2,inx,iny,inz,radians)
482      # if inputs were lists, tuples or floats, convert back.
483      outx = _convertback(xisfloat,xislist,xistuple,inx)
484      outy = _convertback(yisfloat,yislist,xistuple,iny)
485      if inz is not None:
486          outz = _convertback(zisfloat,zislist,zistuple,inz)
487          return outx, outy, outz
488      else:
489          return outx, outy</p>
<p>490<br />
491 -def _copytobuffer(x):</p>
<p>492      &quot;&quot;&quot;
493      return a copy of x as an object that supports the python Buffer
494      API (python array if input is float, list or tuple, numpy array
495      if input is a numpy array). returns copyofx, isfloat, islist,
496      istuple (islist is True if input is a list, istuple is true if
497      input is a tuple, isfloat is true if input is a float).
498      &quot;&quot;&quot;
499      # make sure x supports Buffer API and contains doubles.
500      isfloat = False; islist = False; istuple = False
501      # first, if it's a numpy array scalar convert to float
502      # (array scalars don't support buffer API)
503      if hasattr(x,'shape') and x.shape == (): x = float(x)
504      try:
505          # typecast numpy arrays to double.
506          # (this makes a copy - which is crucial
507          #  since buffer is modified in place)
508          x.dtype.char
509          inx = x.astype('d')
510      except:
511          try: # perhaps they are Numeric/numarrays?
512              x.typecode()
513              inx = x.astype('d')
514          except:
515              # perhaps they are regular python arrays?
516              try:
517                  x.typecode
518                  inx = array('d',x)
519              except:
520                  # try to convert to python array
521                  # a list.
522                  if type(x) == list:
523                      inx = array('d',x)
524                      islist = True
525                  # a tuple.
526                  elif type(x) == tuple:
527                      inx = array('d',x)
528                      istuple = True
529                  # a scalar?
530                  else:
531                      try:
532                          x = float(x)
533                          inx = array('d',(x,))
534                          isfloat = True
535                      except:
536                          raise TypeError('input must be an array, list, tuple or scalar')
537      return inx,isfloat,islist,istuple</p>
<p>538<br />
539 -def _convertback(isfloat,islist,istuple,inx):</p>
<p>540      # if inputs were lists, tuples or floats, convert back to original type.
541      if isfloat:
542          return inx[0]
543      elif islist:
544          return inx.tolist()
545      elif istuple:
546          return tuple(inx)
547      else:
548          return inx</p>
<p>549<br />
550 -def _dict2string(projparams):</p>
<p>551      # convert a dict to a proj4 string.
552      pjargs = []
553      for key,value in projparams.items():
554          pjargs.append('+'+key+&quot;=&quot;+str(value)+' ')
555      return ''.join(pjargs)</p>
<p>556<br />
557 -class Geod(object):</p>
<p>558      &quot;&quot;&quot;
559      performs forward and inverse geodetic, or Great Circle,
560      computations.  The forward computation (using the 'fwd' method)
561      involves determining latitude, longitude and back azimuth of a
562      computations.  The forward computation (using the 'fwd' method)
563      involves determining latitude, longitude and back azimuth of a
564      terminus point given the latitude and longitude of an initial
565      point, plus azimuth and distance. The inverse computation (using
566      the 'inv' method) involves determining the forward and back
567      azimuths and distance given the latitudes and longitudes of an
568      initial and terminus point.
569      &quot;&quot;&quot;
570 -    def <strong>init</strong>(self, initstring=None, **kwargs):</p>
<p>571          &quot;&quot;&quot;
572          initialize a Geod class instance.
573<br />
574          Geodetic parameters for specifying the ellipsoid
575          can be given in a dictionary 'initparams', as keyword arguments,<br />
576          or as as proj4 geod initialization string.
577          Following is a list of the ellipsoids that may be defined using the<br />
578          'ellps' keyword (these are stored in the model variable pj_ellps)::
579<br />
580             MERIT a=6378137.0      rf=298.257       MERIT 1983
581             SGS85 a=6378136.0      rf=298.257       Soviet Geodetic System 85
582             GRS80 a=6378137.0      rf=298.257222101 GRS 1980(IUGG, 1980)
583             IAU76 a=6378140.0      rf=298.257       IAU 1976
584             airy a=6377563.396     b=6356256.910    Airy 1830
585             APL4.9 a=6378137.0.    rf=298.25        Appl. Physics. 1965
586             airy a=6377563.396     b=6356256.910    Airy 1830
587             APL4.9 a=6378137.0.    rf=298.25        Appl. Physics. 1965
588             NWL9D a=6378145.0.     rf=298.25        Naval Weapons Lab., 1965
589             mod_airy a=6377340.189 b=6356034.446    Modified Airy
590             andrae a=6377104.43    rf=300.0         Andrae 1876 (Den., Iclnd.)
591             aust_SA a=6378160.0    rf=298.25        Australian Natl &amp; S. Amer. 1969
592             GRS67 a=6378160.0      rf=298.247167427 GRS 67(IUGG 1967)
593             bessel a=6377397.155   rf=299.1528128   Bessel 1841
594             bess_nam a=6377483.865 rf=299.1528128   Bessel 1841 (Namibia)
595             clrk66 a=6378206.4     b=6356583.8      Clarke 1866
596             clrk80 a=6378249.145   rf=293.4663      Clarke 1880 mod.
597             CPM a=6375738.7        rf=334.29        Comm. des Poids et Mesures 1799
598             delmbr a=6376428.      rf=311.5         Delambre 1810 (Belgium)
599             engelis a=6378136.05   rf=298.2566      Engelis 1985
600             evrst30 a=6377276.345  rf=300.8017      Everest 1830
601             evrst48 a=6377304.063  rf=300.8017      Everest 1948
602             evrst56 a=6377301.243  rf=300.8017      Everest 1956
603             evrst69 a=6377295.664  rf=300.8017      Everest 1969
604             evrstSS a=6377298.556  rf=300.8017      Everest (Sabah &amp; Sarawak)
605             fschr60 a=6378166.     rf=298.3         Fischer (Mercury Datum) 1960
606             fschr60m a=6378155.    rf=298.3         Modified Fischer 1960
607             fschr68 a=6378150.     rf=298.3         Fischer 1968
608             helmert a=6378200.     rf=298.3         Helmert 1906
609             hough a=6378270.0      rf=297.          Hough
610             helmert a=6378200.     rf=298.3         Helmert 1906
611             hough a=6378270.0      rf=297.          Hough
612             intl a=6378388.0       rf=297.          International 1909 (Hayford)
613             krass a=6378245.0      rf=298.3         Krassovsky, 1942
614             kaula a=6378163.       rf=298.24        Kaula 1961
615             lerch a=6378139.       rf=298.257       Lerch 1979
616             mprts a=6397300.       rf=191.          Maupertius 1738
617             new_intl a=6378157.5   b=6356772.2      New International 1967
618             plessis a=6376523.     b=6355863.       Plessis 1817 (France)
619             SEasia a=6378155.0     b=6356773.3205   Southeast Asia
620             walbeck a=6376896.0    b=6355834.8467   Walbeck
621             WGS60 a=6378165.0      rf=298.3         WGS 60
622             WGS66 a=6378145.0      rf=298.25        WGS 66
623             WGS72 a=6378135.0      rf=298.26        WGS 72
624             WGS84 a=6378137.0      rf=298.257223563 WGS 84
625             sphere a=6370997.0     b=6370997.0      Normal Sphere (r=6370997)
626<br />
627          The parameters of the ellipsoid may also be set directly using
628          the 'a' (semi-major or equatorial axis radius) keyword, and
629          any one of the following keywords: 'b' (semi-minor,
630          or polar axis radius), 'e' (eccentricity), 'es' (eccentricity
631          squared), 'f' (flattening), or 'rf' (reciprocal flattening).
632<br />
633          See the proj documentation (http://trac.osgeo.org/proj/) for more
634<br />
635          See the proj documentation (http://trac.osgeo.org/proj/) for more
636          information about specifying ellipsoid parameters (specifically,
637          the chapter 'Specifying the Earth's figure' in the main Proj
638          users manual).
639<br />
640          Example usage:
641<br />
642          &gt;&gt;&gt; from pyproj import Geod
643          &gt;&gt;&gt; g = Geod(ellps='clrk66') # Use Clarke 1966 ellipsoid.
644          &gt;&gt;&gt; # specify the lat/lons of some cities.
645          &gt;&gt;&gt; boston_lat = 42.+(15./60.); boston_lon = -71.-(7./60.)
646          &gt;&gt;&gt; portland_lat = 45.+(31./60.); portland_lon = -123.-(41./60.)
647          &gt;&gt;&gt; newyork_lat = 40.+(47./60.); newyork_lon = -73.-(58./60.)
648          &gt;&gt;&gt; london_lat = 51.+(32./60.); london_lon = -(5./60.)
649          &gt;&gt;&gt; # compute forward and back azimuths, plus distance
650          &gt;&gt;&gt; # between Boston and Portland.
651          &gt;&gt;&gt; az12,az21,dist = g.inv(boston_lon,boston_lat,portland_lon,portland_lat)
652          &gt;&gt;&gt; &quot;%7.3f %6.3f %12.3f&quot; % (az12,az21,dist)
653          '-66.531 75.654  4164192.708'
654          &gt;&gt;&gt; # compute latitude, longitude and back azimuth of Portland,
655          &gt;&gt;&gt; # given Boston lat/lon, forward azimuth and distance to Portland.
656          &gt;&gt;&gt; endlon, endlat, backaz = g.fwd(boston_lon, boston_lat, az12, dist)
657          &gt;&gt;&gt; &quot;%6.3f  %6.3f %13.3f&quot; % (endlat,endlon,backaz)
658          '45.517  -123.683        75.654'
659          &gt;&gt;&gt; # compute the azimuths, distances from New York to several
660          &gt;&gt;&gt; # cities (pass a list)
661          &gt;&gt;&gt; lons1 = 3*[newyork_lon]; lats1 = 3*[newyork_lat]
662          &gt;&gt;&gt; lons2 = [boston_lon, portland_lon, london_lon]
663          &gt;&gt;&gt; lats2 = [boston_lat, portland_lat, london_lat]
664          &gt;&gt;&gt; az12,az21,dist = g.inv(lons1,lats1,lons2,lats2)
665          &gt;&gt;&gt; for faz,baz,d in list(zip(az12,az21,dist)): &quot;%7.3f %7.3f %9.3f&quot; % (faz,baz,d)
666          ' 54.663 -123.448 288303.720'
667          '-65.463  79.342 4013037.318'
668          ' 51.254 -71.576 5579916.651'
669          &gt;&gt;&gt; g2 = Geod('+ellps=clrk66') # use proj4 style initialization string
670          &gt;&gt;&gt; az12,az21,dist = g2.inv(boston_lon,boston_lat,portland_lon,portland_lat)
671          &gt;&gt;&gt; &quot;%7.3f %6.3f %12.3f&quot; % (az12,az21,dist)
672          '-66.531 75.654  4164192.708'
673          &quot;&quot;&quot;
674          # if initparams is a proj-type init string,
675          # convert to dict.
676          ellpsd = {}
677          if initstring is not None:
678              for kvpair in initstring.split():
679                  k,v = kvpair.split('=')
680                  k = k.lstrip('+')
681                  if k in ['a','b','rf','f','es','e']:
682                      v = float(v)
683                  ellpsd[k] = v
684          # merge this dict with kwargs dict.
685          kwargs = dict(list(kwargs.items()) + list(ellpsd.items()))
686          self.sphere = False
687          if 'ellps' in kwargs:
688              # ellipse name given, look up in pj_ellps dict
689              ellps_dict = pj_ellps[kwargs['ellps']]
690              a = ellps_dict['a']
691              if ellps_dict['description']=='Normal Sphere':
692                  self.sphere = True
693              if 'b' in ellps_dict:
694                  b = ellps_dict['b']
695                  es = 1. - (b * b) / (a * a)
696                  f = (a - b)/a
697              elif 'rf' in ellps_dict:
698                  f = 1./ellps_dict['rf']
699                  b = a*(1. - f)
700                  es = 1. - (b * b) / (a * a)
701          else:<br />
702              # a (semi-major axis) and one of
703              # b the semi-minor axis
704              # rf the reciprocal flattening
705              # f flattening
706              # es eccentricity squared
707              # must be given.
708              a = kwargs['a']
709              if 'b' in kwargs:
710                  b = kwargs['b']
711                  es = 1. - (b * b) / (a * a)
712                  f = (a - b)/a
713              elif 'rf' in kwargs:
714                  f = 1./kwargs['rf']
715                  b = a*(1. - f)
716                  es = 1. - (b * b) / (a * a)
717              elif 'f' in kwargs:
718                  f = kwargs['f']
719                  b = a*(1. - f)
720                  es = 1. - (b/a)<strong>2
721              elif 'es' in kwargs:
722                  es = kwargs['es']
723                  b = math.sqrt(a</strong>2 - es<em>a**2)
724                  f = (a - b)/a
725              elif 'e' in kwargs:
726                  es = kwargs['e']<strong>2
727                  b = math.sqrt(a</strong>2 - es</em>a**2)
728                  f = (a - b)/a
729              else:
730                  b = a
731                  f = 0.
732                  es = 0.
733                  #msg='ellipse name or a, plus one of f,es,b must be given'
734                  #raise ValueError(msg)
735          if math.fabs(f) &lt; 1.e-8: self.sphere = True
736          self.a = a
737          self.b = b
738          self.f = f
739          self.es = es
740          self.G = Geodesic(self.a, self.f)</p>
<p>741<br />
742 -    def fwd(self, lons, lats, az, dist, radians=False):</p>
<p>743          &quot;&quot;&quot;
744          forward transformation - Returns longitudes, latitudes and back
745          azimuths of terminus points given longitudes (lons) and
746          latitudes (lats) of initial points, plus forward azimuths (az)
747          and distances (dist).
748          latitudes (lats) of initial points, plus forward azimuths (az)
749          and distances (dist).
750<br />
751          Works with numpy and regular python array objects, python
752          sequences and scalars.
753<br />
754          if radians=True, lons/lats and azimuths are radians instead of
755          degrees. Distances are in meters.
756          &quot;&quot;&quot;
757          # process inputs, making copies that support buffer API.
758          inx, xisfloat, xislist, xistuple = _copytobuffer(lons)
759          iny, yisfloat, yislist, yistuple = _copytobuffer(lats)
760          inz, zisfloat, zislist, zistuple = _copytobuffer(az)
761          ind, disfloat, dislist, distuple = _copytobuffer(dist)
762          n = 0
763          zipin = zip(inx,iny,inz,ind)
764          for lon,lat,az,dist in zipin:
765              result = self.G.Direct(lat, lon, az, dist)
766              inx[n] = result['lon2']
767              iny[n] = result['lat2']
768              inz[n] = result['azi2']
769              az = result['azi2']
770              if az &gt; 0:
771                  inz[n] = az-180.
772              elif az &lt; 0:
773                  inz[n] = az+180.
774              else:
775                  inz[n] = az
776              n = n + 1
777          # if inputs were lists, tuples or floats, convert back.
778          outx = _convertback(xisfloat,xislist,xistuple,inx)
779          outy = _convertback(yisfloat,yislist,xistuple,iny)
780          outz = _convertback(zisfloat,zislist,zistuple,inz)
781          outy = _convertback(yisfloat,yislist,xistuple,iny)
782          outz = _convertback(zisfloat,zislist,zistuple,inz)
783          return outx, outy, outz</p>
<p>784<br />
785 -    def inv(self,lons1,lats1,lons2,lats2,radians=False):</p>
<p>786          &quot;&quot;&quot;
787          inverse transformation - Returns forward and back azimuths, plus
788          distances between initial points (specified by lons1, lats1) and
789          terminus points (specified by lons2, lats2).
790<br />
791          Works with numpy and regular python array objects, python
792          sequences and scalars.
793<br />
794          if radians=True, lons/lats and azimuths are radians instead of
795          degrees. Distances are in meters.
796          &quot;&quot;&quot;
797          # process inputs, making copies that support buffer API.
798          inx, xisfloat, xislist, xistuple = _copytobuffer(lons1)
799          iny, yisfloat, yislist, yistuple = _copytobuffer(lats1)
800          inz, zisfloat, zislist, zistuple = _copytobuffer(lons2)
801          ind, disfloat, dislist, distuple = _copytobuffer(lats2)
802          n = 0
803          zipin = zip(inx,iny,inz,ind)
804          for lon1,lat1,lon2,lat2 in zipin:
805              result = self.G.Inverse(lat1, lon1, lat2, lon2)
806              inx[n] = result['azi1']
807              az = result['azi2']
808              if az &gt; 0:
809                  iny[n] = az-180.
810              elif az &lt; 0:
811                  iny[n] = az+180.
812              else:
813                  iny[n] = az
814              inz[n] = result['s12']
815              n = n + 1
816          # if inputs were lists, tuples or floats, convert back.
817          outx = _convertback(xisfloat,xislist,xistuple,inx)
818          outy = _convertback(yisfloat,yislist,xistuple,iny)
819          outz = _convertback(zisfloat,zislist,zistuple,inz)
820          return outx, outy, outz</p>
<p>821<br />
822 -    def npts(self, lon1, lat1, lon2, lat2, npts, radians=False):</p>
<p>823          &quot;&quot;&quot;
824          Given a single initial point and terminus point (specified by
825          python floats lon1,lat1 and lon2,lat2), returns a list of
826          longitude/latitude pairs describing npts equally spaced
827          intermediate points along the geodesic between the initial and
828          terminus points.
829<br />
830          if radians=True, lons/lats are radians instead of degrees.
831<br />
832          Example usage:
833<br />
834          &gt;&gt;&gt; from pyproj import Geod
835          &gt;&gt;&gt; g = Geod(ellps='clrk66') # Use Clarke 1966 ellipsoid.
836          &gt;&gt;&gt; # specify the lat/lons of Boston and Portland.
837          &gt;&gt;&gt; g = Geod(ellps='clrk66') # Use Clarke 1966 ellipsoid.
838          &gt;&gt;&gt; # specify the lat/lons of Boston and Portland.
839          &gt;&gt;&gt; boston_lat = 42.+(15./60.); boston_lon = -71.-(7./60.)
840          &gt;&gt;&gt; portland_lat = 45.+(31./60.); portland_lon = -123.-(41./60.)
841          &gt;&gt;&gt; # find ten equally spaced points between Boston and Portland.
842          &gt;&gt;&gt; lonlats = g.npts(boston_lon,boston_lat,portland_lon,portland_lat,10)
843          &gt;&gt;&gt; for lon,lat in lonlats: '%6.3f  %7.3f' % (lat, lon)
844          '43.528  -75.414'
845          '44.637  -79.883'
846          '45.565  -84.512'
847          '46.299  -89.279'
848          '46.830  -94.156'
849          '47.149  -99.112'
850          '47.251  -104.106'
851          '47.136  -109.100'
852          '46.805  -114.051'
853          '46.262  -118.924'
854          &quot;&quot;&quot;
855          result = self.G.Inverse(lat1, lon1, lat2, lon2)
856          dist = result['s12']
857          az = result['azi1']
858          # distance increment.
859          del_s = dist/(npts+1)
860          # initialize output tuples.
861          del_s = dist/(npts+1)
862          # initialize output tuples.
863          lats = ()
864          lons = ()
865          # loop over intermediate points, compute lat/lons.
866          for i in range(1,npts+1):
867              S = i<em>del_s
868              result = self.G.Direct(lat1, lon1, az, S)
869              if radians:
870                  lats = lats + (_dg2rad</em>result['lat2'],)
871                  lons = lons + (_dg2rad*result['lon2'],)
872              else:
873                  lats = lats + (result['lat2'],)
874                  lons = lons + (result['lon2'],)
875          return list(zip(lons, lats))</p>
<p>876<br />
877 -def test():</p>
<p>878      &quot;&quot;&quot;run the examples in the docstrings using the doctest module&quot;&quot;&quot;
879      import doctest, pyproj
880      doctest.testmod(pyproj,verbose=True)</p>
<p>881<br />
882  if <strong>name</strong> == &quot;<strong>main</strong>&quot;: test()
883</p>
<pre><code class="language-posh">#--------------------------------------------------------------------------------------------------------------
#Convert Untitled1.ps1 to ASCII encoding
$psise.CurrentPowerShellTab.Files | % { 
    # set private field which holds default encoding to ASCII 
    $_.gettype().getfield(&quot;encoding&quot;,&quot;nonpublic,instance&quot;).setvalue($_, [text.encoding]::ascii) 
} 

# watch for changes to the Files collection of the current Tab 
register-objectevent $psise.CurrentPowerShellTab.Files collectionchanged -action { 
    # iterate ISEFile objects 
    $event.sender | % { 
        # set private field which holds default encoding to ASCII 
        $_.gettype().getfield(&quot;encoding&quot;,&quot;nonpublic,instance&quot;).setvalue($_, [text.encoding]::ascii) 
    } 
}
#--------------------------------------------------------------------------------------------------------------
</code></pre>

</div>

    <footer class="blog-footer">
        <p>&copy; Joel &quot;Jaykul&quot; Bennett 2018</p>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>