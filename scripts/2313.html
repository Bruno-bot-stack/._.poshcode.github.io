
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="Joel Bennett">
    <title>Reflection Module - PoshCode</title>

    <link rel="stylesheet" href="/css/superhero.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/highlight/arta.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" id="tabs">
                    <li class="nav-item"><a class="nav-link" href="/">Join Us!</a></li>
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video">Videos</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

	<div class="container">
		<div class="blog-header">
			<h1 class="blog-title">PoshCode</h1>
			<p class="lead blog-description">Community resources for PowerShell coders</p>
		</div>
		<div class="row">
            

<div class="blog-post">
    <h2 class="blog-post-title">Reflection Module</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2010-10-20</span> by <a class="blog-post-author">Joel Bennett</a>
    </p>

    <h3><a href="/scripts/2313.ps1">download Reflection Module.ps1</a> - <a href="/scripts/1711.md">parent</a></h3>
<p>Helpers for working with .Net classes: Get-Constructor, Get-Assembly, Add-Assembly, Get-Type</p>
<p>Now includes the New-ConstructorFunction (formerly in PowerBoots) which depends on the &quot;Autoload Module v1.0&quot;:http://poshcode.org/2312 or newer.</p>
<pre><code class="language-powershell">#requires -version 2.0
#History:
# 1.0  - First public release (March 19, 2010)
# 2.0  - Private Build
#      - Included the Accelerator function inline
#      - Added a few default aliases
# 3.0  - September 3, 2010
#      - Included the New-ConstructorFunction feature (ripped from PowerBoots to serve a more generic and powerful purpose!)
#      - New-ConstructorFunction and Import-ConstructorFunctions depend on the Autoload Module: http://poshcode.org/2312
#      - NOTE: You should really have a Reflection.psd1 with the contents: @{ RequiredModules = @(&quot;Autoload&quot;); GUID=&quot;64b5f609-970f-4e65-b02f-93ccf3e60cbb&quot;; ModuleVersion=&quot;3.0.0.0&quot; }
function Get-Type {
   &lt;#
   .Synopsis
      Gets the types that are currenty loaded in .NET, or gets information about a specific type
   .Description
      Gets information about one or more loaded types, or gets the possible values for an enumerated type or value.
   .Parameter Assembly
      The Assemblies to search for types.
      Can be an actual Assembly object or a regex to pass to Get-Assembly.
   .Parameter TypeName
      The type name(s) to search for (wildcard patterns allowed).
   .Parameter BaseType
      A Base type they should derive from (wildcard patterns allowed).
   .Parameter Enum
      An enumeration to list all of enumeration values for 
   .Parameter Namespace
      A namespace to restrict where we selsect types from (wildcard patterns allowed).
   .Parameter Force
      Causes Private types to be included
   .Example
      Get-Type
       
      Gets all loaded types (takes a VERY long time to print out)
   .Example
      Get-Type -Assembly ([PSObject].Assembly)
       
      Gets types from System.Management.Automation
   .Example
      [Threading.Thread]::CurrentThread.ApartmentState | Get-Type
       
      Gets all of the possible values for the ApartmentState property
   .Example
      [Threading.ApartmentState] | Get-Type
       
      Gets all of the possible values for an apartmentstate
   #&gt;
   [CmdletBinding(DefaultParameterSetName=&quot;Assembly&quot;)]   
   param(
   # The assembly to collect types from
   [Parameter(ValueFromPipeline=$true)]
   [PsObject[]]$Assembly
,
   # The type names to return from
   [Parameter(Mandatory=$false)]
   [String[]]$TypeName
,
   # The type names to return from
   [Parameter(Mandatory=$false)]
   [String[]]$Namespace
,
   # A Base Type they should derive from 
   [Parameter(Mandatory=$false)]
   [String[]]$BaseType
,
   # The enumerated value to get all of the possibilties of
   [Parameter(ParameterSetName=&quot;Enum&quot;, ValueFromPipeline=$true)]
   [PSObject]$Enum
, 
   [Parameter()][Alias(&quot;Private&quot;,&quot;ShowPrivate&quot;)]
   [Switch]$Force
   )

   process {
      if($psCmdlet.ParameterSetName -eq 'Enum') {
         if($Enum -is [Enum]) {
            [Enum]::GetValues($enum.GetType())
         } elseif($Enum -is [Type] -and $Enum.IsEnum) {
            [Enum]::GetValues($enum)
         } else {
            throw &quot;Specified Enum is neither an enum value nor an enumerable type&quot;
         }
      }
      else {
         if($Assembly -as [Reflection.Assembly[]]) { 
            ## This is what we expected, move along
         } elseif($Assembly -as [String[]]) {
            $Assembly = Get-Assembly $Assembly
         } elseif(!$Assembly) {
            $Assembly = [AppDomain]::CurrentDomain.GetAssemblies()
         }
           
         :asm foreach ($asm in $assembly) {
            Write-Verbose &quot;Testing Types from Assembly: $($asm.Location)&quot;
            if ($asm) { 
               $asm.GetTypes() | Where {
                  ( $Force -or $_.IsPublic ) -AND
                  ( !$Namespace -or $( foreach($n in $Namespace) { $_.Namespace -like $n  } ) ) -AND
                  ( !$TypeName -or $( foreach($n in $TypeName) { $_.Name -like $n -or $_.FullName -like $n } ) -contains $True ) -AND
                  ( !$BaseType -or $( foreach($n in $BaseType) { $_.BaseType -like $n } ) -contains $True )
               }
            }
         }
      }
   }
}

function Add-Assembly {
#.Synopsis
#  Load assemblies 
#.Description
#  Load assemblies from a folder
#.Parameter Path
#  Specifies a path to one or more locations. Wildcards are permitted. The default location is the current directory (.).
#.Parameter Passthru
#  Returns System.Runtime objects that represent the types that were added. By default, this cmdlet does not generate any output.
#  Aliased to -Types
#.Parameter Recurse
#  Gets the items in the specified locations and in all child items of the locations.
# 
#  Recurse works only when the path points to a container that has child items, such as C:\Windows or C:\Windows\*, and not when it points to items that do not have child items, such as C:\Windows\*.dll
[CmdletBinding()]
param(
   [Parameter(ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true, Position=0)]
   [Alias(&quot;PSPath&quot;)]
   [string[]]$Path = &quot;.&quot;
,
   [Alias(&quot;Types&quot;)]
   [Switch]$Passthru
,
   [Switch]$Recurse
)
process {
   foreach($file in Get-ChildItem $Path -Filter *.dll -Recurse:$Recurse) {
      Add-Type -Path $file.FullName -Passthru:$Passthru | Where { $_.IsPublic }
   }
}
}

function Get-Assembly {
&lt;#
.Synopsis 
   Get a list of assemblies available in the runspace
.Description
   Returns AssemblyInfo for all the assemblies available in the current AppDomain, optionally filtered by partial name match
.Parameter Name
   A regex to filter the returned assemblies. This is matched against the .FullName or Location (path) of the assembly.
#&gt;
[CmdletBinding()]
param(
   [Parameter(ValueFromPipeline=$true, Position=0)]
   [string[]]$Name = ''
)
process {
   [appdomain]::CurrentDomain.GetAssemblies() | Where {  $(foreach($n in $Name){$_.FullName -match $n -or $_.Location -match $n }) -contains $True }
}
}

function Get-Constructor {
&lt;#
.Synopsis 
   Returns RuntimeConstructorInfo for the (public) constructor methods of the specified Type.
.Description
   Get the RuntimeConstructorInfo for a type and add members &quot;Syntax,&quot; &quot;SimpleSyntax,&quot; and &quot;Definition&quot; to each one containing the syntax information that can use to call that constructor.
.Parameter Type
   The type to get the constructor for
.Parameter Force
   Force inclusion of Private and Static constructors which are hidden by default.
.Parameter NoWarn
   Serves as the replacement for the broken -WarningAction. If specified, no warnings will be written for types without public constructors.
.Example
   Get-Constructor System.IO.FileInfo
   
   Description
   -----------
   Gets all the information about the single constructor for a FileInfo object. 
.Example
   Get-Type System.IO.*info mscorlib | Get-Constructor -NoWarn | Select Syntax
   
   Description
   -----------
   Displays the constructor syntax for all of the *Info objects in the System.IO namespace. 
   Using -NoWarn supresses the warning about System.IO.FileSystemInfo not having constructors.
  
.Example
   $path = $pwd
   $driveName = $pwd.Drive
   $fileName = &quot;$Profile&quot;
   Get-Type System.IO.*info mscorlib | Get-Constructor -NoWarn | ForEach-Object { Invoke-Expression $_.Syntax }
   
   Description
   -----------
   Finds and invokes the constructors for DirectoryInfo, DriveInfo, and FileInfo.
   Note that we pre-set the parameters for the constructors, otherwise they would fail with null arguments, so this example isn't really very practical.


#&gt;
[CmdletBinding()]
param( 
   [Parameter(Mandatory=$true, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$true, Position=0)]
   [Alias(&quot;ParameterType&quot;)]
   [Type]$Type
,  [Switch]$Force 
,  [Switch]$NoWarn
)
   process { 
      $type.GetConstructors() | Where-Object { $Force -or $_.IsPublic -and -not $_.IsStatic } -OutVariable ctor | Select *,
         @{ name = &quot;TypeName&quot;; expression = { $_.ReflectedType.FullName } },
         @{ name = &quot;Definition&quot;;
            expression = {Get-MemberSignature $_ -Simple}
         },
         @{ name = &quot;Syntax&quot;;
            expression = {Get-MemberSignature $_ -Simple}
         },
         @{ name = &quot;SafeSyntax&quot;;
            expression = {Get-MemberSignature $_}
         }
      if(!$ctor -and !$NoWarn) { Write-Warning &quot;There are no public constructors for $($type.FullName)&quot; }
   }
}

function Get-Method {
&lt;#
.Synopsis 
   Returns MethodInfo for the (public) constructor methods of the specified Type.
.Description
   Get the MethodInfo for a type and add members &quot;Syntax,&quot; &quot;SimpleSyntax,&quot; and &quot;Definition&quot; to each one containing the syntax information that can use to call that constructor.
.Parameter Type
   The type to get methods on
.Parameter Name
   The name(s) of the method(s) you want to retrieve (Accepts Wildcard Patterns)
.Parameter Force
   Force inclusion of Private methods and property accessors which are hidden by default.

#&gt;
[CmdletBinding(DefaultParameterSetName=&quot;Type&quot;)]
param( 
   [Parameter(ParameterSetName=&quot;Type&quot;, Mandatory=$true, ValueFromPipeline=$True, ValueFromPipelineByPropertyName=$true, Position=0)]
   [Type]$Type
,
   [Parameter(Mandatory=$false, ValueFromPipelineByPropertyName=$true, Position=1)]
   [String[]]$Name =&quot;*&quot;
,  [Switch]$Definition
,  [Switch]$Force 
)
   process { 
      foreach($method in 
         $type.GetMethods() + $type.GetConstructors() | Where-Object { $Force -or $_.IsPublic } | 
         # Hide the Property accessor methods
         Where-Object { $Force -or !$_.IsSpecialName -or $_.Name -notmatch &quot;^get_|^set_&quot; } |
         Where-Object { $( foreach($n in $Name) { $_.Name -like $n } ) -contains $True } )
      {
         $method |
         Add-Member NoteProperty TypeName   -Value $($method.ReflectedType.FullName     ) -Passthru |
         Add-Member NoteProperty Definition -Value $(Get-MemberSignature $method -Simple) -Passthru |
         Add-Member AliasProperty Syntax Definition -Passthru |
         #Add-Member NoteProperty Syntax     -Value $(Get-MemberSignature $method -Simple) -Passthru |
         Add-Member NoteProperty SafeSyntax -Value $(Get-MemberSignature $method        ) -Passthru
      }
   }
}

function Get-MemberSignature {
[CmdletBinding()]
param(
   [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
   [System.Reflection.MethodBase]$MethodBase,
   [Switch]$Simple
)
process {
   $parameters = $(
      foreach($param in $MethodBase.GetParameters()) {
         # Write-Host $param.ParameterType.FullName.TrimEnd('&amp;'), $param.Name -fore cyan
      
         if($param.ParameterType.Name.EndsWith('&amp;')) { $ref = '[ref]' } else { $ref = '' }
         if($param.ParameterType.IsArray) { $array = ',' } else { $array = '' }
         if($Simple) { 
            '{0} {1}' -f $parm.ParameterType.FullName, $param.Name
         } else {
            '{0}({1}[{2}]${3})' -f $ref, $array, $param.ParameterType.FullName.TrimEnd('&amp;'), $param.Name
         }
      }
   )
   
   if($MethodBase.IsConstructor) {
      &quot;New-Object $($MethodBase.ReflectedType.FullName) $($parameters -join ', ')&quot;
   } elseif($Simple) {
      &quot;$($MethodBase.ReturnType.FullName) $($MethodBase.Name)($($parameters -join ', '))&quot;
   } elseif($MethodBase.IsStatic) {
      &quot;[$($MethodBase.ReturnType.FullName)] [$($MethodBase.ReflectedType.FullName)]::$($MethodBase.Name)($($parameters -join ', '))&quot;
   } else {
      &quot;[$($MethodBase.ReturnType.FullName)] `$$($MethodBase.ReflectedType.Name)Object.$($MethodBase.Name)($($parameters -join ', '))&quot;
   }
}
}

function Read-Choice {
[CmdletBinding()]
param(
   [Parameter(Mandatory=$true, ValueFromRemainingArguments=$true)]
   [hashtable[]]$Choices
,
   [Parameter(Mandatory=$False)]
   [string]$Caption = &quot;Please choose!&quot;
,  
   [Parameter(Mandatory=$False)]
   [string]$Message = &quot;Choose one of the following options:&quot;
,  
   [Parameter(Mandatory=$False)]
   [int[]]$Default  = 0
,  
   [Switch]$MultipleChoice
,
   [Switch]$Passthru
)
begin {
   [System.Collections.DictionaryEntry[]]$choices = $choices | % { $_.GetEnumerator() }
}
process {
   $Descriptions = [System.Management.Automation.Host.ChoiceDescription[]]( $(
                     foreach($choice in $choices) {
                        New-Object System.Management.Automation.Host.ChoiceDescription $choice.Key,$choice.Value
                     } 
                   ) )

   if(!$MultipleChoice) { [int]$Default = $Default[0] }

   [int[]]$Answer = $Host.UI.PromptForChoice($Caption,$Message,$Descriptions,$Default)

   if($Passthru) {
      Write-Verbose &quot;$Answer&quot;
      Write-Output  $Descriptions[$Answer]
   } else {
      Write-Output $Answer
   }
}
}

function Get-Argument {
param(
   [Type]$Target
,  [String]$Method
,  $Arguments
)
end {
trap {
   write-error $_
   break
}
   Write-Verbose &quot;Get $Method Method on $($Target.FullName):&quot;
   $MethodBase = Get-Method $target $Method
   Write-Verbose $($MethodBase | Out-String)
   if(@($MethodBase).Count -gt 1) {
      $i = 0
      $i = Read-Choice -Choices $(foreach($mb in $MethodBase) { @{ &quot;$($mb.SafeSyntax) &amp;$($i = $i+1;$i)`b`n&quot; =  $mb.SafeSyntax } }) -Default ($MethodBase.Count-1) -Caption &quot;Choose a Method.&quot; -Message &quot;Please choose which method overload to invoke:&quot;
      [System.Reflection.MethodBase]$MethodBase = $MethodBase[$i]
   }

   ForEach($parameter in $MethodBase.GetParameters()) {
      $found = $false
      For($a =0;$a -lt $Arguments.Count;$a++) {
         if($argument[$a] -as $parameter.ParameterType) {
            Write-Output $argument[$a]
            if($a -gt 0 -and $a -lt $Arguments.Count) {
               $Arguments = $Arguments | Select -First ($a-1) -Last ($Arguments.Count -$a)
            } elseif($a -eq 0) {
               $Arguments = $Arguments | Select -Last ($Arguments.Count - 1)
            } else { # a -eq count
               $Arguments = $Arguments | Select -First ($Arguments.Count - 1)
            }
            $found = $true
            break
         }
      }
      if(!$Found) {
         $userInput = Read-Host &quot;Please enter a [$($parameter.ParameterType.FullName)] value for $($parameter.Name)&quot;
         if($userInput -match '^{.*}$' -and !($userInput -as $parameter.ParameterType)) {
            Write-Output ((Invoke-Expression $userInput) -as $parameter.ParameterType)
         } else {
             Write-Output ($userInput -as $parameter.ParameterType)
         }
      }
   }
}
}

function Invoke-Member {
[CmdletBinding()]
param(        
   [parameter(position=0, valuefrompipeline=$true, mandatory=$true)]
   [allownull()]
   [allowemptystring()]
   $InputObject
,
   [parameter(position=1, mandatory=$true)]
   [validatenotnullorempty()]
   $Method
,
   [parameter(valuefromremainingarguments=$true)]
   [allowemptycollection()]
   [object[]]$Arguments
,
   [parameter()]
   [switch]$Static
)
#  begin {
   #  if(!(get-member SafeSyntax -input $method -type Property)){
      #  if(get-member Name -inpup $Method -Type Property) {
         #  $Method = Get-Method $InputObject $Method.Name
      #  } else {
         #  $Method = Get-Method $InputObject $Method
      #  }
   #  }
   #  $SafeSyntax = [ScriptBlock]::Create( $Method.SafeSyntax )
#  }
process {
   #  if ($InputObject) 
   #  {
      #  if ($InputObject | Get-Member $Method -static:$static) 
      #  {

         if ($InputObject -is [type]) {
             $target = $InputObject
         } else {
             $target = $InputObject.GetType()
         }
      
         if($Method -match &quot;ctor|constructor&quot;) {
            $Method = &quot;.ctor&quot;
            [System.Reflection.BindingFlags]$flags = &quot;CreateInstance&quot;
            $InputObject = $Null
         } else {
            [System.Reflection.BindingFlags]$flags = &quot;IgnoreCase,Public,InvokeMethod&quot;
            if($Static) { $flags += &quot;Static&quot; } else { $flags += &quot;Instance&quot; }
         }
         
            
         [Object[]]$Parameters = Get-Argument $target $Method $Arguments
         
         Write-Verbose &quot;$($Parameters | %{ '[' + $_.GetType().FullName + ']' + $_ })&quot;
            
         try {
            Write-Verbose &quot;Invoking $Method on [$target]$InputObject with $flags and $Parameters&quot;
            Write-Verbose &quot;[$($target.FullName)].InvokeMember('$Method', '$flags', `$null, '$InputObject', ([object[]]($(($Parameters | %{ '[' + $_.GetType().FullName + ']''' + $_ + ''''}) -join', '))))&quot;
             $target.InvokeMember($Method, $flags, $null, $InputObject, $Parameters)
         } catch {
             if ($_.Exception.Innerexception -is [MissingMethodException]) {
                 write-warning &quot;Method argument count (or type) mismatch.&quot;
             }
         }
      #  } else {
         #  write-warning &quot;Method $Method not found.&quot;
      #  }
   #  }
}
}

function Invoke-Generic {
#.Synopsis
#  Invoke Generic method definitions via reflection:
[CmdletBinding()]
param( 
   [Parameter(Position=0,Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
   [Alias('On','Type')]
   $InputObject
,
   [Parameter(Position=1,ValueFromPipelineByPropertyName=$true)]
   [Alias('Named')]
   [string]$MethodName
,
   [Parameter(Position=2)]
   [Alias('Returns')]
   [Type]$ReturnType
, 
   [Parameter(Position=3, ValueFromPipelineByPropertyName=$true)]
   [Type[]]$ArgumentTypes
, 
   [Parameter(Position=4, ValueFromRemainingArguments=$true, ValueFromPipelineByPropertyName=$true)]
   [Object[]]$WithArgs
)
process {
   $Type = $InputObject -as [Type]
   if(!$Type) { $Type = $InputObject.GetType() }
   
   if($WithArgs) {
      if(!$ArgumentTypes) {
         [Type[]]$ArgumentTypes = $withArgs | % { $_.GetType() }   
      }
      [Object[]]$Arguments = $withArgs | %{ $_.PSObject.BaseObject }

      $Type.GetMethod($MethodName, $ArgumentTypes).MakeGenericMethod($returnType).Invoke( $on, $Arguments )
   } else {
      [Type[]]$ArgumentTypes = New-Object Type[] 0
      $Type.GetMethod($MethodName, $ArgumentTypes).MakeGenericMethod($returnType).Invoke( $on )
   }
   
} }

# get a reference to the Type   
$xlr8r = [type]::gettype(&quot;System.Management.Automation.TypeAccelerators&quot;)  

function Import-Namespace {
[CmdletBinding()]
param(
   [Parameter(ValueFromPipeline=$true)]
   [string]$Namespace
,  
   [Switch]$Force
)
   Get-Type -Namespace $Namespace -Force:$Force | Add-Accelerator
}

function Add-Accelerator {
&lt;#
   .Synopsis
      Add a type accelerator to the current session
   .Description
      The Add-Accelerator function allows you to add a simple type accelerator (like [regex]) for a longer type (like [System.Text.RegularExpressions.Regex]).
   .Example
      Add-Accelerator list System.Collections.Generic.List``1
      $list = New-Object list[string]
      
      Creates an accelerator for the generic List[T] collection type, and then creates a list of strings.
   .Example
      Add-Accelerator &quot;List T&quot;, &quot;GList&quot; System.Collections.Generic.List``1
      $list = New-Object &quot;list t[string]&quot;
      
      Creates two accelerators for the Generic List[T] collection type.
   .Parameter Accelerator
      The short form accelerator should be just the name you want to use (without square brackets).
   .Parameter Type
      The type you want the accelerator to accelerate (without square brackets)
   .Notes
      When specifying multiple values for a parameter, use commas to separate the values. 
      For example, &quot;-Accelerator string, regex&quot;.
      
      PowerShell requires arguments that are &quot;types&quot; to NOT have the square bracket type notation, because of the way the parsing engine works.  You can either just type in the type as System.Int64, or you can put parentheses around it to help the parser out: ([System.Int64])

      Also see the help for Get-Accelerator and Remove-Accelerator
   .Link
      http://huddledmasses.org/powershell-2-ctp3-custom-accelerators-finally/
      
#&gt;
[CmdletBinding()]
param(
   [Parameter(Position=0,ValueFromPipelineByPropertyName=$true)]
   [Alias(&quot;Key&quot;,&quot;Name&quot;)]
   [string[]]$Accelerator
,
   [Parameter(Position=1,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)]
   [Alias(&quot;Value&quot;,&quot;FullName&quot;)]
   [type]$Type
)
process {
   # add a user-defined accelerator  
   foreach($a in $Accelerator) { 
      $xlr8r::Add( $a, $Type) 
      trap [System.Management.Automation.MethodInvocationException] {
         if($xlr8r::get.keys -contains $a) {
            if($xlr8r::get[$a] -ne $Type) {
               Write-Error &quot;Cannot add accelerator [$a] for [$($Type.FullName)]`n                  [$a] is already defined as [$($xlr8r::get[$a].FullName)]&quot;
            }
            Continue;
         } 
         throw
      }
   }
}
}

function Get-Accelerator {
&lt;#
   .Synopsis
      Get one or more type accelerator definitions
   .Description
      The Get-Accelerator function allows you to look up the type accelerators (like [regex]) defined on your system by their short form or by type
   .Example
      Get-Accelerator System.String
      
      Returns the KeyValue pair for the [System.String] accelerator(s)
   .Example
      Get-Accelerator ps*,wmi*
      
      Returns the KeyValue pairs for the matching accelerator definition(s)
   .Parameter Accelerator
      One or more short form accelerators to search for (Accept wildcard characters).
   .Parameter Type
      One or more types to search for.
   .Notes
      When specifying multiple values for a parameter, use commas to separate the values. 
      For example, &quot;-Accelerator string, regex&quot;.
      
      Also see the help for Add-Accelerator and Remove-Accelerator
   .Link
      http://huddledmasses.org/powershell-2-ctp3-custom-accelerators-finally/
#&gt;
[CmdletBinding(DefaultParameterSetName=&quot;ByType&quot;)]
param(
   [Parameter(Position=0, ParameterSetName=&quot;ByAccelerator&quot;, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
   [Alias(&quot;Key&quot;,&quot;Name&quot;)]
   [string[]]$Accelerator
,
   [Parameter(Position=0, ParameterSetName=&quot;ByType&quot;, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
   [Alias(&quot;Value&quot;,&quot;FullName&quot;)]
   [type[]]$Type
)
process {
   # add a user-defined accelerator  
   switch($PSCmdlet.ParameterSetName) {
      &quot;ByAccelerator&quot; { 
         $xlr8r::get.GetEnumerator() | % {
            foreach($a in $Accelerator) {
               if($_.Key -like $a) { $_ }
            }
         }
         break
      }
      &quot;ByType&quot; { 
         if($Type -and $Type.Count) {
            $xlr8r::get.GetEnumerator() | ? { $Type -contains $_.Value }
         }
         else {
            $xlr8r::get.GetEnumerator() | %{ $_ }
         }
         break
      }
   }
}
}

function Remove-Accelerator {
&lt;#
   .Synopsis
      Remove a type accelerator from the current session
   .Description
      The Remove-Accelerator function allows you to remove a simple type accelerator (like [regex]) from the current session. You can pass one or more accelerators, and even wildcards, but you should be aware that you can remove even the built-in accelerators.
      
   .Example
      Remove-Accelerator int
      Add-Accelerator int Int64
      
      Removes the &quot;int&quot; accelerator for Int32 and adds a new one for Int64. I can't recommend doing this, but it's pretty cool that it works:
      
      So now, &quot;$(([int]3.4).GetType().FullName)&quot; would return &quot;System.Int64&quot;
   .Example
      Get-Accelerator System.Single | Remove-Accelerator
      
      Removes both of the default accelerators for System.Single: [float] and [single]
   .Example
      Get-Accelerator System.Single | Remove-Accelerator -WhatIf
      
      Demonstrates that Remove-Accelerator supports -Confirm and -Whatif. Will Print:
         What if: Removes the alias [float] for type [System.Single]
         What if: Removes the alias [single] for type [System.Single]
   .Parameter Accelerator
      The short form accelerator that you want to remove (Accept wildcard characters).
   .Notes
      When specifying multiple values for a parameter, use commas to separate the values. 
      For example, &quot;-Accel string, regex&quot;.
      
      Also see the help for Add-Accelerator and Get-Accelerator
   .Link
      http://huddledmasses.org/powershell-2-ctp3-custom-accelerators-finally/
#&gt;
[CmdletBinding(SupportsShouldProcess=$true)]
param(
   [Parameter(Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
   [Alias(&quot;Key&quot;,&quot;FullName&quot;)]
   [string[]]$Accelerator
)
process {
   foreach($a in $Accelerator) {
      foreach($key in $xlr8r::Get.Keys -like $a) { 
         if($PSCmdlet.ShouldProcess( &quot;Removes the alias [$($Key)] for type [$($xlr8r::Get[$key].FullName)]&quot;,
                                     &quot;Remove the alias [$($Key)] for type [$($xlr8r::Get[$key].FullName)]?&quot;,
                                     &quot;Removing Type Accelerator&quot; )) {
            # remove a user-defined accelerator
            $xlr8r::remove($key)   
         }
      }
   }
}
}



###############################################################################
##### Imported from PowerBoots

$Script:CodeGenContentProperties = 'Content','Child','Children','Frames','Items','Pages','Blocks','Inlines','GradientStops','Source','DataPoints', 'Series', 'VisualTree'
$DependencyProperties = @{}
if(Test-Path $PSScriptRoot\DependencyPropertyCache.xml) {
	#$DependencyProperties = [System.Windows.Markup.XamlReader]::Parse( (gc $PSScriptRoot\DependencyPropertyCache.xml) )
	$DependencyProperties = Import-CliXml  $PSScriptRoot\DependencyPropertyCache.xml 
}

function Get-ReflectionModule { $executioncontext.sessionstate.module }

function Set-ObjectProperties {
[CmdletBinding()]
param( $Parameters, [ref]$DObject )

   if($DObject.Value -is [System.ComponentModel.ISupportInitialize]) { $DObject.Value.BeginInit() }

   if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host; Write-Host &quot;&gt;&gt;&gt;&gt; $($Dobject.Value.GetType().FullName)&quot; -fore Black -back White }
   foreach ($param in $Parameters) {
      if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;Processing Param: $($param|Out-String )&quot; }
      ## INGORE DEPENDENCY PROPERTIES FOR NOW :)
      if($param.Key -eq &quot;DependencyProps&quot;) {
      ## HANDLE EVENTS ....
      }
      elseif ($param.Key.StartsWith(&quot;On_&quot;)) {
         $EventName = $param.Key.SubString(3)
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;Event handler $($param.Key) Type: $(@($param.Value)[0].GetType().FullName)&quot; }
         $sb = $param.Value -as [ScriptBlock]
         if(!$sb) {
            $sb = (Get-Command $param.Value -CommandType Function,ExternalScript).ScriptBlock
         }
         $Dobject.Value.&quot;Add_$EventName&quot;.Invoke( $sb );
         # $Dobject.Value.&quot;Add_$EventName&quot;.Invoke( ($sb.GetNewClosure()) );
         
         # $Dobject.Value.&quot;Add_$EventName&quot;.Invoke( $PSCmdlet.MyInvocation.MyCommand.Module.NewBoundScriptBlock( $sb.GetNewClosure() ) );
         
         
      } ## HANDLE PROPERTIES ....
      else { 
         try {
            ## TODO: File a BUG because Write-DEBUG and Write-VERBOSE die here.
            if($DebugPreference -ne &quot;SilentlyContinue&quot;) {
               Write-Host &quot;Setting $($param.Key) of $($Dobject.Value.GetType().Name) to $($param.Value.GetType().FullName): $($param.Value)&quot; -fore Gray
            }
            if(@(foreach($sb in $param.Value) { $sb -is [ScriptBlock] }) -contains $true) {
               $Values = @()
               foreach($sb in $param.Value) {
                  $Values += &amp; (Get-ReflectionModule) $sb
               }
            } else {
               $Values = $param.Value
            }

            if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host ([System.Windows.Markup.XamlWriter]::Save( $Dobject.Value )) -foreground green }
            if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host ([System.Windows.Markup.XamlWriter]::Save( @($Values)[0] )) -foreground green }
            
            Set-Property $Dobject $Param.Key $Values

            if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host ([System.Windows.Markup.XamlWriter]::Save( $Dobject.Value )) -foreground magenta }
      
            if($DebugPreference -ne &quot;SilentlyContinue&quot;) {
               if( $Dobject.Value.$($param.Key) -ne $null ) {
                  Write-Host $Dobject.Value.$($param.Key).GetType().FullName -fore Green
               }
            }
         }
         catch [Exception]
         {
            Write-Host &quot;COUGHT AN EXCEPTION&quot; -fore Red
            Write-Host $_ -fore Red
            Write-Host $this -fore DarkRed
         }
      }

      while($DependencyProps) {
         $name, $value, $DependencyProps = $DependencyProps
         $name = ([string]@($name)[0]).Trim(&quot;-&quot;)
         if($name -and $value) {
            Set-DependencyProperty -Element $Dobject.Value -Property $name -Value $Value
         }
      }
   }
   if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;&lt;&lt;&lt;&lt; $($Dobject.Value.GetType().FullName)&quot; -fore Black -back White; Write-Host }
   
   if($DObject.Value -is [System.ComponentModel.ISupportInitialize]) { $DObject.Value.EndInit() }

}

function Set-Property {
PARAM([ref]$TheObject, $Name, $Values)
   $DObject = $TheObject.Value
   
   if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host ([System.Windows.Markup.XamlWriter]::Save( $DObject )) -foreground DarkMagenta }
   if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host ([System.Windows.Markup.XamlWriter]::Save( @($Values)[0] )) -foreground DarkMagenta }

   $PropertyType = $DObject.GetType().GetProperty($Name).PropertyType
   if('System.Windows.FrameworkElementFactory' -as [Type] -and $PropertyType -eq [System.Windows.FrameworkElementFactory] -and $DObject -is [System.Windows.FrameworkTemplate]) {
      if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;Loading a FrameworkElementFactory&quot; -foreground Green}
      
      # [Xml]$Template = [PoshWpf.XamlHelper]::ConvertToXaml( $DObject )
      # [Xml]$Content = [PoshWpf.XamlHelper]::ConvertToXaml( (@($Values)[0]) )
      # In .Net 3.5 the recommended way to programmatically create a template is to load XAML from a string or a memory stream using the Load method of the XamlReader class.
      [Xml]$Template = [System.Windows.Markup.XamlWriter]::Save( $DObject )
      [Xml]$Content = [System.Windows.Markup.XamlWriter]::Save( (@($Values)[0]) )

      $Template.DocumentElement.PrependChild( $Template.ImportNode($Content.DocumentElement, $true) ) | Out-Null
     
      $TheObject.Value = [System.Windows.Markup.XamlReader]::Parse( $Template.get_OuterXml() )
   }
   elseif('System.Windows.Data.Binding' -as [Type] -and @($Values)[0] -is [System.Windows.Data.Binding] -and !$PropertyType.IsAssignableFrom([System.Windows.Data.BindingBase])) {
      $Binding = @($Values)[0];
      if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;$($DObject.GetType())::$Name is $PropertyType and the value is a Binding: $Binding&quot; -fore Cyan}

      if(!$Binding.Source -and !$Binding.ElementName) {
         $Binding.Source = $DObject.DataContext
      }
      if($DependencyProperties.ContainsKey($Name)) {
         $field = @($DependencyProperties.$Name.Keys | Where { $DObject -is $_ -and $PropertyType -eq ([type]$DependencyProperties.$Name.$_.PropertyType)})[0] #  -or -like &quot;*$Class&quot; -and ($Param1.Value -as ([type]$_.PropertyType)
         if($field) { 
            if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;$($field)&quot; -fore Blue }
            if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;Binding: ($field)::`&quot;$($DependencyProperties.$Name.$field.Name)`&quot; to $Binding&quot; -fore Blue}
            
            $DObject.SetBinding( ([type]$field)::&quot;$($DependencyProperties.$Name.$field.Name)&quot;, $Binding ) | Out-Null
         } else {
            throw &quot;Couldn't figure out $( @($DependencyProperties.$Name.Keys) -join ', ' )&quot;
         }
      } else {
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { 
            Write-Host &quot;But $($DObject.GetType())::${Name}Property is not a Dependency Property, so it probably can't be bound?&quot; -fore Cyan
         }
         try {
            
            $DObject.SetBinding( ($DObject.GetType()::&quot;${Name}Property&quot;), $Binding ) | Out-Null
            
            # $DObject.Add_Loaded( {
            #    $this.SetBinding( ($this.GetType())::ItemsSourceProperty,  (Binding -Source $this.DataContext) )
            # } )
               
            if($DebugPreference -ne &quot;SilentlyContinue&quot;) { 
               Write-Host ([System.Windows.Markup.XamlWriter]::Save( $Dobject )) -foreground yellow
            }
         } catch {
            Write-Host &quot;Nope, was not able to set it.&quot; -fore Red
            Write-Host $_ -fore Red
            Write-Host $this -fore DarkRed
         }
      }
   }
   elseif($PropertyType -ne [Object] -and $PropertyType.IsAssignableFrom( [System.Collections.IEnumerable] ) -and ($DObject.$($Name) -eq $null)) {
      if($Values -is [System.Collections.IEnumerable]) {
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;$Name is $PropertyType which is IEnumerable, and the value is too!&quot; -fore Cyan }
         $DObject.$($Name) = $Values
      } else { 
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;$Name is $PropertyType which is IEnumerable, but the value is not.&quot; -fore Cyan }
         $DObject.$($Name) = new-object &quot;System.Collections.ObjectModel.ObservableCollection[$(@($Values)[0].GetType().FullName)]&quot;
         $DObject.$($Name).Add($Values)
      }
   }
   elseif($DObject.$($Name) -is [System.Collections.IList]) {
      foreach ($value in @($Values)) {
         try {
            $null = $DObject.$($Name).Add($value)
         }
         catch
         {
            # Write-Host &quot;CAUGHT array problem&quot; -fore Red
            if($_.Exception.Message -match &quot;Invalid cast from 'System.String' to 'System.Windows.UIElement'.&quot;) {
               $null = $DObject.$($Name).Add( (New-System.Windows.Controls.TextBlock $value) )
            } else {
               Write-Error $_.Exception
            throw
            }
         }
      }
   }
   else {
      ## If they pass an array of 1 when we only want one, we just use the first value
      if($Values -is [System.Collections.IList] -and $Values.Count -eq 1) {
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;Value is an IList ($($Values.GetType().FullName))&quot; -fore Cyan}
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;But we'll just use the first ($($Values[0].GetType().FullName))&quot; -fore Cyan}
         
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host ([System.Windows.Markup.XamlWriter]::Save( $Values[0] )) -foreground White}
         try {
            $DObject.$($Name) = $Values[0]
         }
         catch [Exception]
         {
            # Write-Host &quot;CAUGHT collection value problem&quot; -fore Red
            if($_.Exception.Message -match &quot;Invalid cast from 'System.String' to 'System.Windows.UIElement'.&quot;) {
               $null = $DObject.$($Name).Add( (TextBlock $Values[0]) )
            }else { 
               throw
            }
         }
      }
      else ## If they pass an array when we only want one, we try to use it, and failing that, cast it to strings
      {
         if($DebugPreference -ne &quot;SilentlyContinue&quot;) { Write-Host &quot;Value is just $Values&quot; -fore Cyan}
         try {
            $DObject.$($Name) = $Values
         } catch [Exception]
         {
            # Write-Host &quot;CAUGHT value problem&quot; -fore Red
            if($_.Exception.Message -match &quot;Invalid cast from 'System.String' to 'System.Windows.UIElement'.&quot;) {
               $null = $DObject.$($Name).Add( (TextBlock $values) )
            }else { 
               throw
            }
         }
      }
   }
}

function Set-DependencyProperty {
[CmdletBinding()]
PARAM(
   [Parameter(Position=0,Mandatory=$true)]
   $Property
,
   [Parameter(Mandatory=$true,ValueFromPipeline=$true)]
   $Element
,
   [Parameter()]
   [Switch]$Passthru
)

DYNAMICPARAM {
   $paramDictionary = new-object System.Management.Automation.RuntimeDefinedParameterDictionary
   $Param1 = new-object System.Management.Automation.RuntimeDefinedParameter
   $Param1.Name = &quot;Value&quot;
   # $Param1.Attributes.Add( (New-ParameterAttribute -Position 1) )
   $Param1.Attributes.Add( (New-Object System.Management.Automation.ParameterAttribute -Property @{ Position = 1 }) )   

   if( $Property ) {
      if($Property.GetType() -eq ([System.Windows.DependencyProperty]) -or
         $Property.GetType().IsSubclassOf(([System.Windows.DependencyProperty]))) 
      {
         $Param1.ParameterType = $Property.PropertyType
      } 
      elseif($Property -is [string] -and $Property.Contains(&quot;.&quot;)) {
         $Class,$Property = $Property.Split(&quot;.&quot;)
         if($DependencyProperties.ContainsKey($Property)){
            $type = $DependencyProperties.$Property.Keys -like &quot;*$Class&quot;
            if($type) { 
               $Param1.ParameterType = [type]@($DependencyProperties.$Property.$type)[0].PropertyType
            }
         }

      } elseif($DependencyProperties.ContainsKey($Property)){
         if($Element) {
            if($DependencyProperties.$Property.ContainsKey( $element.GetType().FullName )) { 
               $Param1.ParameterType = [type]$DependencyProperties.$Property.($element.GetType().FullName).PropertyType
            }
         } else {
            $Param1.ParameterType = [type]$DependencyProperties.$Property.Values[0].PropertyType
         }
      }
      else 
      {
         $Param1.ParameterType = [PSObject]
      }
   }
   else 
   {
      $Param1.ParameterType = [PSObject]
   }
   $paramDictionary.Add(&quot;Value&quot;, $Param1)
   return $paramDictionary
}
PROCESS {   
   trap { 
      Write-Host &quot;ERROR Setting Dependency Property&quot; -Fore Red
      Write-Host &quot;Trying to set $Property to $($Param1.Value)&quot; -Fore Red
      continue
   }
   if($Property.GetType() -eq ([System.Windows.DependencyProperty]) -or
      $Property.GetType().IsSubclassOf(([System.Windows.DependencyProperty]))
   ){
      trap { 
         Write-Host &quot;ERROR Setting Dependency Property&quot; -Fore Red
         Write-Host &quot;Trying to set $($Property.FullName) to $($Param1.Value)&quot; -Fore Red
         continue
      }
      $Element.SetValue($Property, ($Param1.Value -as $Property.PropertyType))
   } 
	else {
      if(&quot;$Property&quot;.Contains(&quot;.&quot;)) {
         $Class,$Property = &quot;$Property&quot;.Split(&quot;.&quot;)
      }
         
      if( $DependencyProperties.ContainsKey(&quot;$Property&quot; ) ) {
         $fields = @( $DependencyProperties.$Property.Keys -like &quot;*$Class&quot; | ? { $Param1.Value -as ([type]$DependencyProperties.$Property.$_.PropertyType) } )
			if($fields.Count -eq 0 ) { 
            $fields = @($DependencyProperties.$Property.Keys -like &quot;*$Class&quot; )
         }			
         if($fields.Count) {
            $success = $false
            foreach($field in $fields) {
               trap { 
                  Write-Host &quot;ERROR Setting Dependency Property&quot; -Fore Red
                  Write-Host &quot;Trying to set $($field)::$($DependencyProperties.$Property.$field.Name) to $($Param1.Value) -as $($DependencyProperties.$Property.$field.PropertyType)&quot; -Fore Red
                  continue
               }
               $Element.SetValue( ([type]$field)::&quot;$($DependencyProperties.$Property.$field.Name)&quot;, ($Param1.Value -as ([type]$DependencyProperties.$Property.$field.PropertyType)))
               if($?) { $success = $true; break }
            }
				
            if(!$success) { 
					throw &quot;food&quot; 
				}				
         } else {
            Write-Host &quot;Couldn't find the right property: $Class.$Property on $( $Element.GetType().Name ) of type $( $Param1.Value.GetType().FullName )&quot; -Fore Red      
         }
		}
		else {
         Write-Host &quot;Unknown Dependency Property Key: $Property on $($Element.GetType().Name)&quot; -Fore Red      
      }
   }
	
   if( $Passthru ) { $Element }
}
}

function Add-ConstructorFunction {
&lt;#
.Synopsis
   Add support for a new class by creating the dynamic constructor function(s).
.Description
   Creates a New-Namespace.Type function for each type passed in, as well as a short form &quot;Type&quot; alias.

   Exposes all of the properties and events of the type as perameters to the function. 

   NOTE: The Type MUST have a default parameterless constructor.
.Parameter Assembly
	The Assembly you want to generate constructors for. All public types within it will be generated if possible.
.Parameter Type
   The type you want to create a constructor function for.  It must have a default parameterless constructor.
.Example
   Add-ConstructorFunction System.Windows.Controls.Button
   
   Creates a new function for the Button control.

.Example
   [Reflection.Assembly]::LoadWithPartialName( &quot;PresentationFramework&quot; ).GetTypes() | Add-ConstructorFunction

   Will create constructor functions for all the WPF components in the PresentationFramework assembly.  Note that you could also load that assembly using GetAssembly( &quot;System.Windows.Controls.Button&quot; ) or Load( &quot;PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&quot; )

.Example
   Add-ConstructorFunction -Assembly PresentationFramework

   Will create constructor functions for all the WPF components in the PresentationFramework assembly.

.Links 
   http://HuddledMasses.org/powerboots
.ReturnValue
   The name(s) of the function(s) created -- so you can export them, if necessary.
.Notes
 AUTHOR:    Joel Bennett http://HuddledMasses.org
 LASTEDIT:  2009-01-13 16:35:23
#&gt;
[CmdletBinding(DefaultParameterSetName=&quot;FromType&quot;)]
PARAM(
   [Parameter(Position=0,ValueFromPipeline=$true,ParameterSetName=&quot;FromType&quot;,Mandatory=$true)]
   [type[]]$type
,
   [Alias(&quot;FullName&quot;)]
   [Parameter(Position=0,ValueFromPipelineByPropertyName=$true,ParameterSetName=&quot;FromAssembly&quot;,Mandatory=$true)]
   [string[]]$Assembly
,
   [Parameter()]
	[string]$Path = &quot;$PSScriptRoot\Types_Generated&quot;
,
   [switch]$Force
,
   [switch]$ShortAliases
,
   [Switch]$Quiet
)
BEGIN {
   [Type[]]$Empty=@()
   if(!(Test-Path $Path)) {   
      MkDir $Path
   }
   $ErrorList = @()
}
END {
   #Set-Content -Literal $PSScriptRoot\DependencyPropertyCache.xml -Value ([System.Windows.Markup.XamlWriter]::Save( $DependencyProperties ))
	Export-CliXml -Path $PSScriptRoot\DependencyPropertyCache.xml -InputObject $DependencyProperties
	
   if($ErrorList.Count) { Write-Warning &quot;Some New-* functions not aliased.&quot; }
   $ErrorList | Write-Error
}
PROCESS {
   if($PSCmdlet.ParameterSetName -eq &quot;FromAssembly&quot;) {
      [type[]]$type = @()
      foreach($lib in $Assembly) {
         $asm =  $null
         trap { continue }
         if(Test-Path $lib) {
            $asm =  [Reflection.Assembly]::LoadFrom( (Convert-Path (Resolve-Path $lib -EA &quot;SilentlyContinue&quot;) -EA &quot;SilentlyContinue&quot;) )
         }
         if(!$asm) {
            ## BUGBUG: LoadWithPartialName is &quot;Obsolete&quot; -- but it still works in 2.0/3.5
            $asm =  [Reflection.Assembly]::LoadWithPartialName( $lib )
         }
         if($asm) {
            $type += $asm.GetTypes() | ?{ $_.IsPublic    -and !$_.IsEnum      -and 
                                         !$_.IsAbstract  -and !$_.IsInterface -and 
                                          $_.GetConstructor( &quot;Instance,Public&quot;, $Null, $Empty, @() )}
         } else {
            Write-Error &quot;Can't find the assembly $lib, please check your spelling and try again&quot;
         }
      }
   }
   
   foreach($T in $type) {
      $TypeName = $T.FullName
      $ScriptPath = Join-Path $Path &quot;New-$TypeName.ps1&quot;
      Write-Verbose $TypeName

      ## Collect all dependency properties ....
      $T.GetFields() |
         Where-Object { $_.FieldType -eq [System.Windows.DependencyProperty] } |
         ForEach-Object { 
            [string]$Field = $_.DeclaringType::&quot;$($_.Name)&quot;.Name
            [string]$TypeName = $_.DeclaringType.FullName
          
            if(!$DependencyProperties.ContainsKey( $Field )) {
               $DependencyProperties.$Field = @{}
            }
            
            $DependencyProperties.$Field.$TypeName = @{ 
               Name         = [string]$_.Name
               PropertyType = [string]$_.DeclaringType::&quot;$($_.Name)&quot;.PropertyType.FullName
            }
         }
            
		if(!( Test-Path $ScriptPath ) -OR $Force) {
         $Pipelineable = @();
         ## Get (or generate) a set of parameters based on the the Type Name
         $PropertyNames = New-Object System.Text.StringBuilder &quot;@(&quot;

         $Parameters = New-Object System.Text.StringBuilder &quot;[CmdletBinding(DefaultParameterSetName='Default')]`nPARAM(`n&quot;
		 
         ## Add all properties
         $Properties = $T.GetProperties(&quot;Public,Instance,FlattenHierarchy&quot;) | 
            Where-Object { $_.CanWrite -Or $_.PropertyType.GetInterface([System.Collections.IList]) }
			
         $Properties = ($T.GetEvents(&quot;Public,Instance,FlattenHierarchy&quot;) + $Properties) | Sort-Object Name -Unique

         foreach ($p in $Properties) {
            $null = $PropertyNames.AppendFormat(&quot;,'{0}'&quot;,$p.Name)
            switch( $p.MemberType ) {
               Event {
                  $null = $PropertyNames.AppendFormat(&quot;,'{0}__'&quot;,$p.Name)
                  $null = $Parameters.AppendFormat(@'
	[Parameter()]
	[PSObject]${{On_{0}}}
,
'@, $p.Name)
               }
               Property {
                  if($p.Name -match &quot;^$($CodeGenContentProperties -Join '$|^')`$&quot;) {
                     $null = $Parameters.AppendFormat(@'
	[Parameter(Position=1,ValueFromPipeline=$true)]
	[Object[]]${{{0}}}
,
'@, $p.Name)
                     $Pipelineable += @(Add-Member -in $p.Name -Type NoteProperty -Name &quot;IsCollection&quot; -Value $($p.PropertyType.GetInterface([System.Collections.IList]) -ne $null) -Passthru)
                  } 
                  elseif($p.PropertyType -eq [System.Boolean]) 
                  {
                     $null = $Parameters.AppendFormat(@'
	[Parameter()]
	[Switch]${{{0}}}
,
'@, $p.Name)
                  }
                  else 
                  {
                     $null = $Parameters.AppendFormat(@'
	[Parameter()]
	[Object[]]${{{0}}}
,
'@, $p.Name)
                  }
               }
            }
         }
		$null = $Parameters.Append('	[Parameter(ValueFromRemainingArguments=$true)]
	[string[]]$DependencyProps
)')
		$null = $PropertyNames.Remove(2,1).Append(')')
			
      $collectable = [bool]$(@(foreach($p in @($Pipelineable)){$p.IsCollection}) -contains $true)
      $ofs = &quot;`n&quot;;

$function = $(
&quot;
if(!( '$TypeName' -as [Type] )) {
$(
   if( $T.Assembly.GlobalAssemblyCache ) {
&quot;  `$null = [Reflection.Assembly]::Load( '$($T.Assembly.FullName)' ) &quot;
   } else {
&quot;  `$null = [Reflection.Assembly]::LoadFrom( '$($T.Assembly.Location)' ) &quot;
   }
)
}
## if(`$ExecutionContext.SessionState.Module.Guid -ne (Get-ReflectionModule).Guid) {
## 	Write-Warning `&quot;$($T.Name) not invoked in ReflectionModule context. Attempting to reinvoke.`&quot;
##    # `$scriptParam = `$PSBoundParameters
##    # return iex `&quot;&amp; (Get-ReflectionModule) '`$(`$MyInvocation.MyCommand.Path)' ```@PSBoundParameters`&quot;
## }
Write-Verbose &quot;&quot;$($T.Name) in module `$(`$executioncontext.sessionstate.module) context!&quot;&quot;


function New-$TypeName {
&lt;#
.Synopsis
   Create a new $($T.Name) object
.Description
   Generates a new $TypeName object, and allows setting all of it's properties.
   (From the $($T.Assembly.GetName().Name) assembly v$($T.Assembly.GetName().Version))
.Notes
 GENERATOR : $((Get-ReflectionModule).Name) v$((Get-ReflectionModule).Version) by Joel Bennett http://HuddledMasses.org
 GENERATED : $(Get-Date)
 ASSEMBLY  : $($T.Assembly.FullName)
 FULLPATH  : $($T.Assembly.Location)
#&gt;
 
$Parameters
BEGIN {
   `$DObject = New-Object $TypeName
   `$All = $PropertyNames
}
PROCESS {
&quot;
if(!$collectable) {
&quot;
   # The content of $TypeName is not a collection
   # So if we're in a pipeline, make a new $($T.Name) each time
   if(`$_) { 
      `$DObject = New-Object $TypeName
   }
&quot;
}
@'
foreach($key in @($PSBoundParameters.Keys) | where { $PSBoundParameters[$_] -is [ScriptBlock] }) {
   $PSBoundParameters[$key] = $PSBoundParameters[$key].GetNewClosure()
}
Set-ObjectProperties @($PSBoundParameters.GetEnumerator() | Where { [Array]::BinarySearch($All,($_.Key -replace &quot;^On_(.*)&quot;,'$1__')) -ge 0 } ) ([ref]$DObject)
'@

if(!$collectable) {
@'
   Microsoft.PowerShell.Utility\Write-Output $DObject
} #Process
'@
   } else {
@'
} #Process
END {
   Microsoft.PowerShell.Utility\Write-Output $DObject
}
'@
   }
@&quot;
}
                                                                        
## New-$TypeName `@PSBoundParameters
&quot;@
)

         Set-Content -Path $ScriptPath -Value $Function
      }

      # Note: set the aliases global for now, because it's too late to export them
		# E.g.: New-Button = New-System.Windows.Controls.Button
		Set-Alias -Name &quot;New-$($T.Name)&quot; &quot;New-$TypeName&quot; -ErrorAction SilentlyContinue -ErrorVariable +ErrorList -Scope Global -Passthru:(!$Quiet)
		if($ShortAliases) {
		# E.g.: Button = New-System.Windows.Controls.Button
			Set-Alias -Name $T.Name &quot;New-$TypeName&quot; -ErrorAction SilentlyContinue -ErrorVariable +ErrorList -Scope Global -Passthru:(!$Quiet)
		}
		
      New-AutoLoad -Name $ScriptPath -Alias &quot;New-$TypeName&quot;
   }                                                         
}#PROCESS
}

function Import-ConstructorFunctions {
#.Synopsis
#  Autoload pre-generated constructor functions and generate aliases for them.
#.Description
#  Parses the New-* scripts in the specified path, and uses the Autoload module to pre-load them as commands and set up aliases for them, without parsing them into memory.
#.Parameter Path
#  The path to a folder with functions to preload
param(
   [Parameter()]
   [Alias(&quot;PSPath&quot;)]
	[string[]]$Path = &quot;$PSScriptRoot\Types_Generated&quot;
)
end {
	$Paths = $(foreach($p in $Path) { Join-Path $p &quot;New-*.ps1&quot; })
	Write-Verbose &quot;Importing Constructors from: `n`t$($Paths -join &quot;`n`t&quot;)&quot;

	foreach($script in Get-ChildItem $Paths -ErrorAction 0) {
		$TypeName = $script.Name -replace 'New-(.*).ps1','$1'
      $ShortName = ($TypeName -split '\.')[-1]
      Write-Verbose &quot;Importing constructor for type: $TypeName ($ShortName)&quot;
		
      # Note: set the aliases global for now, because it's too late to export them
		# E.g.: New-Button = New-System.Windows.Controls.Button
		Set-Alias -Name &quot;New-$ShortName&quot; &quot;New-$TypeName&quot; -ErrorAction SilentlyContinue -ErrorVariable +ErrorList -Scope Global -Passthru:(!$Quiet)
		if($ShortAliases) {
		# E.g.: Button = New-System.Windows.Controls.Button
			Set-Alias -Name $ShortName &quot;New-$TypeName&quot; -ErrorAction SilentlyContinue -ErrorVariable +ErrorList -Scope Global -Passthru:(!$Quiet)
		}

		New-Autoload -Name $Script.FullName -Alias &quot;New-$TypeName&quot;
		# Write-Host -fore yellow $(Get-Command &quot;New-$TypeName&quot; | Out-String)
		Get-Command &quot;New-$TypeName&quot;
	}
}
}

###############################################################################


Add-Accelerator list System.Collections.Generic.List``1
Add-Accelerator dictionary System.Collections.Generic.Dictionary``2

Set-Alias aasm Add-Assembly -Option AllScope
Set-Alias gt Get-Type -Option AllScope
Set-Alias gasm Get-Assembly -Option AllScope
Set-Alias gctor Get-Constructor -Option AllScope
Set-Alias gax Get-Accelerator -Option AllScope
Set-Alias aax Add-Accelerator -Option AllScope
Set-Alias rax Remove-Accelerator -Option AllScope

Export-ModuleMember -Function * -Alias *
# SIG # Begin signature block
# MIIIDQYJKoZIhvcNAQcCoIIH/jCCB/oCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUOPmSsbNp7OA8QrGW9LDLkUk4
# Ni+gggUrMIIFJzCCBA+gAwIBAgIQKQm90jYWUDdv7EgFkuELajANBgkqhkiG9w0B
# AQUFADCBlTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0
# IExha2UgQ2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYD
# VQQLExhodHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHTAbBgNVBAMTFFVUTi1VU0VS
# Rmlyc3QtT2JqZWN0MB4XDTEwMDUxNDAwMDAwMFoXDTExMDUxNDIzNTk1OVowgZUx
# CzAJBgNVBAYTAlVTMQ4wDAYDVQQRDAUwNjg1MDEUMBIGA1UECAwLQ29ubmVjdGlj
# dXQxEDAOBgNVBAcMB05vcndhbGsxFjAUBgNVBAkMDTQ1IEdsb3ZlciBBdmUxGjAY
# BgNVBAoMEVhlcm94IENvcnBvcmF0aW9uMRowGAYDVQQDDBFYZXJveCBDb3Jwb3Jh
# dGlvbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMfUdxwiuWDb8zId
# KuMg/jw0HndEcIsP5Mebw56t3+Rb5g4QGMBoa8a/N8EKbj3BnBQDJiY5Z2DGjf1P
# n27g2shrDaNT1MygjYfLDntYzNKMJk4EjbBOlR5QBXPM0ODJDROg53yHcvVaXSMl
# 498SBhXVSzPmgprBJ8FDL00o1IIAAhYUN3vNCKPBXsPETsKtnezfzBg7lOjzmljC
# mEOoBGT1g2NrYTq3XqNo8UbbDR8KYq5G101Vl0jZEnLGdQFyh8EWpeEeksv7V+YD
# /i/iXMSG8HiHY7vl+x8mtBCf0MYxd8u1IWif0kGgkaJeTCVwh1isMrjiUnpWX2NX
# +3PeTmsCAwEAAaOCAW8wggFrMB8GA1UdIwQYMBaAFNrtZHQUnBQ8q92Zqb1bKE2L
# PMnYMB0GA1UdDgQWBBTK0OAaUIi5wvnE8JonXlTXKWENvTAOBgNVHQ8BAf8EBAMC
# B4AwDAYDVR0TAQH/BAIwADATBgNVHSUEDDAKBggrBgEFBQcDAzARBglghkgBhvhC
# AQEEBAMCBBAwRgYDVR0gBD8wPTA7BgwrBgEEAbIxAQIBAwIwKzApBggrBgEFBQcC
# ARYdaHR0cHM6Ly9zZWN1cmUuY29tb2RvLm5ldC9DUFMwQgYDVR0fBDswOTA3oDWg
# M4YxaHR0cDovL2NybC51c2VydHJ1c3QuY29tL1VUTi1VU0VSRmlyc3QtT2JqZWN0
# LmNybDA0BggrBgEFBQcBAQQoMCYwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmNv
# bW9kb2NhLmNvbTAhBgNVHREEGjAYgRZKb2VsLkJlbm5ldHRAWGVyb3guY29tMA0G
# CSqGSIb3DQEBBQUAA4IBAQAEss8yuj+rZvx2UFAgkz/DueB8gwqUTzFbw2prxqee
# zdCEbnrsGQMNdPMJ6v9g36MRdvAOXqAYnf1RdjNp5L4NlUvEZkcvQUTF90Gh7OA4
# rC4+BjH8BA++qTfg8fgNx0T+MnQuWrMcoLR5ttJaWOGpcppcptdWwMNJ0X6R2WY7
# bBPwa/CdV0CIGRRjtASbGQEadlWoc1wOfR+d3rENDg5FPTAIdeRVIeA6a1ZYDCYb
# 32UxoNGArb70TCpV/mTWeJhZmrPFoJvT+Lx8ttp1bH2/nq6BDAIvu0VGgKGxN4bA
# T3WE6MuMS2fTc1F8PCGO3DAeA9Onks3Ufuy16RhHqeNcMYICTDCCAkgCAQEwgaow
# gZUxCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJVVDEXMBUGA1UEBxMOU2FsdCBMYWtl
# IENpdHkxHjAcBgNVBAoTFVRoZSBVU0VSVFJVU1QgTmV0d29yazEhMB8GA1UECxMY
# aHR0cDovL3d3dy51c2VydHJ1c3QuY29tMR0wGwYDVQQDExRVVE4tVVNFUkZpcnN0
# LU9iamVjdAIQKQm90jYWUDdv7EgFkuELajAJBgUrDgMCGgUAoHgwGAYKKwYBBAGC
# NwIBDDEKMAigAoAAoQKAADAZBgkqhkiG9w0BCQMxDAYKKwYBBAGCNwIBBDAcBgor
# BgEEAYI3AgELMQ4wDAYKKwYBBAGCNwIBFTAjBgkqhkiG9w0BCQQxFgQUT5+I/cl2
# XCMwrqk7nr22uBFwAuwwDQYJKoZIhvcNAQEBBQAEggEAX0OJXKRNvY/GKPVbMj1Q
# V0UYJdKTM17Oca5Bvbj0BTcwbuoToM4mAH8s8ZJrZldIfcIdVsr89SQ+s9UwhE5W
# 1FsBl3smgVWjc8o9j3LTi/BssTOg2pgFaMwdR4GRmUgQjznAXFb3Np0FoB+RieAN
# IR6XXYoVSfMRg1Qa5M7MIy84ww4oGDE8ssBlterqR9VOSSKiHYvlbDHO9cVH1FJ3
# 8ulz1RPl2BA3iwDK6J0w74FNTXILJE85OEXAcxXwGPlgvtOqKFOpNf1/ji1iE9iO
# kysIFde1Amdq5Qx6nDNYkvWYj59vBH0SgcvJj5k2EieQEecraca10q95BE+oXmaK
# 1Q==
# SIG # End signature block

</code></pre>

</div>
			<!-- sidebar? -->
		</div>
		<hr>
		<footer class="blog-footer">
			<p>Generated by Joel &quot;Jaykul&quot; Bennett - 2018</p>
		</footer>
	</div> <!-- /container -->

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>
    <script src="/js/vendor/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>