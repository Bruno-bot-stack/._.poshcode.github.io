
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="foobar">
    <title>TabExpansion for V2CTP3 - PoshCode</title>

    <link rel="stylesheet" href="/css/superhero.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/highlight/arta.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" id="tabs">
                    <li class="nav-item"><a class="nav-link" href="/">Join Us!</a></li>
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video">Videos</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

	<div class="container">
		<div class="blog-header">
			<h1 class="blog-title">PoshCode</h1>
			<p class="lead blog-description">Community resources for PowerShell coders</p>
		</div>
		<div class="row">
            

<div class="blog-post">
    <h2 class="blog-post-title">TabExpansion for V2CTP3</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2009-02-04</span> by <a class="blog-post-author">foobar</a>
    </p>

    <h3><a href="/scripts/847.ps1">download TabExpansion for V2CTP3.ps1</a> - <a href="/scripts/814.md">parent</a></h3>
<p>Ported TabExpansion from V2CTP2 to V2CTP3 and extended. Please dot souce this script file.</p>
<h1>Fixed [Hashtable] variable properties expansion</h1>
<pre><code class="language-powershell">## Tab-Completion
#################
## For V2CTP3.
## This won't work on V1 and V2CTP and V2CTP2.
## Please dot souce this script file.
## In first loading, it may take a several minutes, in order to generate ProgIDs and TypeNames list.
## 
## What this can do is:
##
## [datetime]::n&lt;tab&gt;
## [datetime]::now.d&lt;tab&gt;
## $a = New-Object &quot;Int32[,]&quot; 2,3; $b = &quot;PowerShell&quot;,&quot;PowerShell&quot;
## $c = [ref]$a; $d = [ref]$b,$c
## $d[0].V&lt;tab&gt;[0][0].Get&lt;tab&gt;
## $d[1].V&lt;tab&gt;[0,0].tos&lt;tab&gt;
## $function:a&lt;tab&gt;
## $env:a&lt;tab&gt;
## [System.Type].a&lt;tab&gt;
## [datetime].Assembly.a&lt;tab&gt;
## ).a&lt;tab&gt; # shows System.Type properties and methods...

## #native command name expansion
## fsu&lt;tab&gt;

## #command option name expansion (for fsutil ipconfig net powershell only)
## fsutil &lt;tab&gt;
## ipconfig &lt;tab&gt;
## net &lt;tab&gt;
## powershell &lt;tab&gt;

## #TypeNames and Type accelerators expansion
## [Dec&lt;tab&gt;
## [system.Man&lt;tab&gt;.auto&lt;tab&gt;.p&lt;tab&gt;
## New-Object -TypeName IO.Dir&lt;tab&gt;
## New-Object System.win&lt;tab&gt;.for&lt;tab&gt;.bu&lt;tab&gt;

## #ProgIDs expansion
## New-Object -Com shel&lt;tab&gt;

## #Enum option expansion
## Set-ExecutionPolicy &lt;tab&gt;
## Set-ExecutionPolicy All&lt;tab&gt;
## Set-ExcusionPolisy -ex &lt;tab&gt;
## Get-TraceSource Inte&lt;tab&gt;
## iex -Errora &lt;tab&gt; -wa Sil&lt;tab&gt;

## #WmiClasses expansion
## Get-WmiObject -class Win32_&lt;tab&gt;
## gwmi __Instance&lt;tab&gt;

## #Encoding expansion
## [Out-File | Export-CSV | Select-String | Export-Clixml] -enc &lt;tab&gt;
## [Add-Content | Get-Content | Set-Content} -Encoding Big&lt;tab&gt;

## #PSProvider name expansion
## [Get-Location | Get-PSDrive | Get-PSProvider | New-PSDrive | Remove-PSDrive] -PSProvider &lt;tab&gt;
## Get-PSProvider &lt;tab&gt;
## pwd -psp al&lt;tab&gt;

## #PSDrive name expansion
## [Get-PSDrive | New-PSDrive | Remove-PSDrive] [-Name] &lt;tab&gt;
## Get-PSDrive &lt;tab&gt;
## pwd -psd &lt;tab&gt;

## #PSSnapin name expansion
## [Add-PSSnapin | Get-PSSnapin | Remove-PSSnapin ] [-Name] &lt;tab&gt;
## Get-Command -PSSnapin &lt;tab&gt;
## Remove-PSSnapin &lt;tab&gt;
## Get-PSSnapin M&lt;tab&gt;

## #Eventlog name and expansion
## Get-Eventlog -Log &lt;tab&gt;
## Get-Eventlog w&lt;tab&gt;

## #Eventlog's entrytype expansion
## Get-EventLog -EntryType &lt;tab&gt;
## Get-EventLog -EntryType Er&lt;tab&gt;
## Get-EventLog -Ent &lt;tab&gt;

## #Service name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-Name] &lt;tab&gt;
## New-Service -DependsOn &lt;tab&gt;
## New-Service -Dep e&lt;tab&gt;
## Get-Service -n &lt;tab&gt;
## Get-Service &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;
## gsv &lt;tab&gt;

## #Service display name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-DisplayName] &lt;tab&gt;
## Get-Service -Dis &lt;tab&gt;
## gsv -Dis &lt;tab&gt;,w&lt;tab&gt;,b&lt;tab&gt;

## #Cmdlet and Topic name expansion
## Get-Help [-Name] about_&lt;tab&gt;
## Get-Help &lt;tab&gt;

## #Category name expansion
## Get-Help -Category c&lt;tab&gt;,&lt;tab&gt;

## #Command name expansion
## Get-Command [-Name] &lt;tab&gt;
## Get-Command -Name &lt;tab&gt;
## gcm a&lt;tab&gt;,&lt;tab&gt;

## #Scope expansion
## [Clear-Variable | Export-Alias | Get-Alias | Get-PSDrive | Get-Variable | Import-Alias
## New-Alias | New-PSDrive | New-Variable | Remove-Variable | Set-Alias | Set-Variable] -Scope &lt;tab&gt;
## Clear-Variable -Scope G&lt;tab&gt;
## Set-Alias  -s &lt;tab&gt;

## #Process name expansion
## [Get-Process | Stop-Process] [-Name] &lt;tab&gt;
## Stop-Process -Name &lt;tab&gt;
## Stop-Process -N pow&lt;tab&gt;
## Get-Process &lt;tab&gt;
## ps power&lt;tab&gt;

## #Trace sources expansion
## [Trace-Command | Get-TraceSource | Set-TraceSource] [-Name] &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;

## #Trace -ListenerOption expansion
## [Set-TraceSource | Trace-Command] -ListenerOption &lt;tab&gt;
## Set-TraceSource -Lis &lt;tab&gt;,n&lt;tab&gt;

## #Trace -Option expansion
## [Set-TraceSource | Trace-Command] -Option &lt;tab&gt;
## Set-TraceSource -op &lt;tab&gt;,con&lt;tab&gt;

## #ItemType expansion
## New-Item -Item &lt;tab&gt;
## ni -ItemType d&lt;tab&gt;

## #ErrorAction and WarningAction option expansion
## CMDLET [-ErrorAction | -WarningAction] &lt;tab&gt;
## CMDLET -Errora s&lt;tab&gt;
## CMDLET -ea con&lt;tab&gt;
## CMDLET -wa &lt;tab&gt;

## #Continuous expansion with comma when parameter can treat multiple option
## # if there are spaces, occur display bug in the line
## # if strings contains '$' or '-', not work
## Get-Command -CommandType &lt;tab&gt;,&lt;tab&gt;&lt;tab&gt;,cm&lt;tab&gt;
## pwd -psp &lt;tab&gt;,f&lt;tab&gt;,va&lt;tab&gt;
## Get-EventLog -EntryType &lt;tab&gt;,i&lt;tab&gt;,s&lt;tab&gt;

## #Enum expansion in method call expression
## # this needs one or more spaces after left parenthesis or comma
## $str = &quot;day   night&quot;
## $str.Split( &quot; &quot;,&lt;space&gt;rem&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; ) &lt;Enter&gt; ERROR
## $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as&lt;space&gt;&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions] ) &lt;Enter&gt; Success
## $type = [System.Type]
## $type.GetMembers(&lt;space&gt;Def&lt;tab&gt;
## [IO.Directory]::GetFiles( &quot;C:\&quot;, &quot;*&quot;,&lt;space&gt;All&lt;tab&gt;
## # this can do continuous enum expansion with comma and no spaces
## $type.GetMembers( &quot;IgnoreCase&lt;comma&gt;Dec&lt;tab&gt;&lt;comma&gt;In&lt;tab&gt;&quot;
## [IO.Directory]::GetAccessControl( &quot;C:\&quot;,&lt;space&gt;au&lt;tab&gt;&lt;comma&gt;ac&lt;tab&gt;&lt;comma&gt;G&lt;tab&gt;

## #Better '$_.' expansion when cmdlet output objects or method return objects
## ls |group { $_.Cr&lt;tab&gt;.Tost&lt;tab&gt;&quot;y&quot;)} | tee -var foo| ? { $_.G&lt;tab&gt;.c&lt;tab&gt; -gt 5 } | % { md $_.N&lt;tab&gt; ; copy $_.G&lt;tab&gt; $_.N&lt;tab&gt;  }
## [IO.DriveInfo]::GetDrives() | ? { $_.A&lt;tab&gt; -gt 1GB }
## $Host.UI.RawUI.GetBufferContents($rect) | % { $str += $_.c&lt;tab&gt; }
## gcm Add-Content |select -exp Par&lt;tab&gt;| select -ExpandProperty Par&lt;tab&gt; | ? { $_.Par&lt;tab&gt;.N&lt;tab&gt; -eq &quot;string&quot; }
## $data = Get-Process
## $data[2,4,5]  | % { $_.&lt;tab&gt;
## #when Get-PipeLineObject failed, '$_.' shows methods and properties name of FileInfo and String and Type

## #Property name expansion by -Property parameter
## [ Format-List | Format-Custom | Format-Table | Format-Wide | Compare-Object |
##  ConvertTo-Html | Measure-Object | Select-Object | Group-Object | Sort-Object ] [-Property] &lt;tab&gt;
## Select-Object -ExcludeProperty &lt;tab&gt;
## Select-Object -ExpandProperty &lt;tab&gt;
## gcm Get-Acl|select -exp Par&lt;tab&gt;
## ps |group na&lt;tab&gt;
## ls | ft A&lt;tab&gt;,M&lt;tab&gt;,L&lt;tab&gt;

## #Hashtable key expansion in the variable name and '.&lt;tab&gt;'
## Get-Process | Get-Unique | % { $hash += @{$_.ProcessName=$_} }
## $hash.pow&lt;tab&gt;.pro&lt;tab&gt;

## #Parameter expansion for function, filter and script
## man -f&lt;tab&gt;
## 'param([System.StringSplitOptions]$foo,[System.Management.Automation.ActionPreference]$bar,[System.Management.Automation.CommandTypes]$baz) {}' &gt; foobar.ps1
## .\foobar.ps1 -&lt;tab&gt; -b&lt;tab&gt;

## #Enum expansion for function, filter and scripts
## # this can do continuous enum expansion with comma and no spaces
## .\foobar.ps1 -foo rem&lt;tab&gt; -bar &lt;tab&gt;&lt;comma&gt;c&lt;tab&gt;&lt;comma&gt;sc&lt;tab&gt; -ea silent&lt;tab&gt; -wa con&lt;tab&gt;

## #Enum expansion for assignment expression
## #needs space(s) after '=' and comma
## #strongly-typed with -as operator and space(s)
## $ErrorActionPreference =&lt;space&gt;&lt;tab&gt;
## $cmdtypes = New-Object System.Management.Automation.CommandTypes[] 3
## $cmdtypes =&lt;space&gt;&lt;tab&gt;&lt;comma&gt;&lt;space&gt;func&lt;tab&gt;&lt;comma&gt;&lt;space&gt;cmd&lt;tab&gt; -as&lt;space&gt;&lt;tab&gt;

## #Path expansion with variable and '\' or '/'
## $PWD\../../&lt;tab&gt;\&lt;tab&gt;
## &quot;$env:SystemDrive/pro&lt;tab&gt;/&lt;tab&gt;

## #Operator expansion which starts with '-'
## &quot;Power&quot;,&quot;Shell&quot; -m&lt;tab&gt; &quot;Power&quot; -r&lt;tab&gt; '(Pow)(er)','$1d$2'
## 1..9 -co&lt;tab&gt; 5

## #Keyword expansion
## fu&lt;tab&gt; test { p&lt;tab&gt; $foo, $bar ) b&lt;tab&gt; &quot;foo&quot; } pr&lt;tab&gt; $_ } en&lt;tab&gt; &quot;$bar&quot; } }

## #Variable name expansion (only global scope)
## [Clear-Variable | Get-Variable | New-Variable | Remove-Variable | Set-Variable] [-Name] &lt;tab&gt;
## [Cmdlet | Function | Filter | ExternalScript] -ErrorVariable &lt;tab&gt;
## [Cmdlet | Function | Filter | ExternalScript] -OutVariable &lt;tab&gt;
## Tee-Object -Variable &lt;tab&gt;
##  gv pro&lt;tab&gt;,&lt;tab&gt;
##  Remove-Variable -Name out&lt;tab&gt;,&lt;tab&gt;,ps&lt;tab&gt;
##  ... | ... | tee -v &lt;tab&gt;

## #Alias name expansion
## [Get-Alias | New-Alias | Set-Alias] [-Name] &lt;tab&gt;
## Export-Alias -Name &lt;tab&gt;
##  Get-Alias i&lt;tab&gt;,e&lt;tab&gt;,a&lt;tab&gt;
##  epal -n for&lt;tab&gt;

## #Property name expansion with -groupBy parameter
## [Format-List | Format-Custom | Format-Table | Format-Wide] -groupBy &lt;tab&gt;
##  ps | ft -g &lt;tab&gt;
##  gcm | Format-Wide -GroupBy Par&lt;tab&gt;

## #Type accelerators expansion with no charactors
##  [&lt;tab&gt;
##  New-Object -typename &lt;tab&gt;
##  New-Object &lt;tab&gt;

## # File glob expansion with '@'
##  ls *.txt@&lt;tab&gt;
##  ls file.txt, foo1.txt, 'bar``[1``].txt', 'foo bar .txt'	# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter *.txt						# 2 &lt;tab&gt; refactoring 
##  ls *.txt							# 3 &lt;tab&gt; (or 1 &lt;tab&gt; &amp; 1 &lt;shift&gt;+&lt;tab&gt;) return original glob pattern

## This can also use '^'(hat) or '~'(tilde) for Excluding
##  ls &lt;hat&gt;*.txt@&lt;tab&gt;
##  ls foo.ps1, 'bar``[1``].xml'		# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter * -Excluding *.txt		# 2 &lt;tab&gt; refactoring 
##  *.txt&lt;tilde&gt;foo*&lt;tilde&gt;bar*@&lt;tab&gt;
##  ls file.txt					# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter *.txt -Excluding foo*, bar*	# 2 &lt;tab&gt; refactoring 

## # Ported history expansion from V2CTP3 TabExpansion with '#' ( #&lt;pattern&gt; or #&lt;id&gt; )
##  ls * -Filter * -Excluding foo*, bar*&lt;Enter&gt;
##  #ls&lt;tab&gt;
##  #1&lt;tab&gt;

## # Command buffer stack with ';'(semicolon)
##  ls * -Filter * -Excluding foo*, bar*&lt;semicolon&gt;&lt;tab&gt; # push command1
##  echo &quot;PowerShell&quot;&lt;semicolon&gt;&lt;tab&gt; # push command2
##  get-process&lt;semicolon&gt;&lt;tab&gt; # push command3
##  {COMMAND}&lt;Enter&gt; # execute another command 
##  get-process # Auto pop command3 from stack by LIFO
## This can also hand-operated pop with ';,'(semicolon&amp;comma) or ';:'(semicolon&amp;colon)
##  get-process; &lt;semicolon&gt;&lt;comma&gt;&lt;tab&gt;
##  get-process; echo &quot;PowerShell&quot; # pop command2 from stack by LIFO

## # Function name expansion after 'function' or 'filter' keywords
## function cl&lt;tab&gt;

### Generate ProgIDs list...
if ( Test-Path $PSHOME\ProgIDs.txt )
{
$_reader = New-Object IO.StreamReader $PSHOME\ProgIDs.txt
$_ProgID = $_reader.ReadToEnd().Split(&quot;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
$_reader.Close()
Remove-Variable _reader
}
else
{
$_HKCR = [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\&quot;)
$_ProgID = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
foreach ( $_subkey in $_HKCR.GetSubKeyNames() )
{
foreach ( $_i in [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\$_subkey\ProgID&quot;) )
{
if ($_i -ne $null)
{
$_ProgID.Add($_i.GetValue(&quot;&quot;))
}
}
}
'$_ProgID was updated...' | Out-Host
$_ProgID = $_ProgID|sort -Unique

Set-Content -Value $_ProgID -Path $PSHOME\ProgIDs.txt -Verbose
}

### Generate TypeNames list...

if ( Test-Path $PSHOME\TypeNames.txt )
{
$_reader = New-Object IO.StreamReader $PSHOME\TypeNames.txt
$_TypeNames = $_reader.ReadToEnd().Split(&quot;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
$_reader.Close()
Remove-Variable _reader
}
else
{
$_TypeNames = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
foreach ( $_asm in [AppDomain]::CurrentDomain.GetAssemblies() )
{
foreach ( $_type in $_asm.GetTypes() )
{
$_TypeNames.Add($_type.FullName)
}
}
'$_TypeNames was updated...' | Out-Host
$_TypeNames = $_TypeNames | sort -Unique

Set-Content -Value $_TypeNames -Path $PSHOME\TypeNames.txt -Verbose
}

if ( Test-Path $PSHOME\TypeNames_System.txt )
{
$_reader = New-Object IO.StreamReader $PSHOME\TypeNames_System.txt
$_TypeNames_System = $_reader.ReadToEnd().Split(&quot;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
$_reader.Close()
Remove-Variable _reader
}
else
{
$_TypeNames_System = $_TypeNames -like &quot;System.*&quot; -replace '^System\.'
'$_TypeNames_System was updated...' | Out-Host
Set-Content -Value $_TypeNames_System -Path $PSHOME\TypeNames_System.txt -Verbose
}

### Generate WMIClasses list...
if ( Test-Path $PSHOME\WMIClasses.txt )
{
$_reader = New-Object IO.StreamReader $PSHOME\WMIClasses.txt
$_WMIClasses = $_reader.ReadToEnd().Split(&quot;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
$_reader.Close()
Remove-Variable _reader
}
else
{
$_WMIClasses = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
foreach ( $_class in gwmi -List )
{
$_WMIClasses.Add($_class.Name)
}
$_WMIClasses = $_WMIClasses | sort -Unique
'$_WMIClasses was updated...' | Out-Host
Set-Content -Value $_WMIClasses -Path $PSHOME\WMIClasses.txt -Verbose
}

[Reflection.Assembly]::LoadWithPartialName( &quot;System.Windows.Forms&quot; ) | Out-Null
$global:_cmdstack = New-Object Collections.Stack
$global:_snapin = $null
$global:_TypeAccelerators = [type]::gettype(&quot;System.Management.Automation.TypeAccelerators&quot;)::get.keys | sort

iex (@'
function prompt {
if ($_cmdstack.Count -gt 0) {
$line = $global:_cmdstack.Pop() -replace '([[\]\(\)+{}?~%])','{$1}'
[System.Windows.Forms.SendKeys]::SendWait($line)
}
'@ + @&quot;
${function:prompt}
}
&quot;@)

function Write-ClassNames ( $data, $i, $prefix='', $sep='.' )
{
$preItem = &quot;&quot;
foreach ( $class in $data -like $_opt )
{
$Item = $class.Split($sep)
if ( $preItem -ne $Item[$i] )
{
if ( $i+1 -eq $Item.Count )
{
if ( $prefix -eq &quot;[&quot; )
{
$suffix = &quot;]&quot;
}
elseif ( $sep -eq &quot;_&quot; )
{
$suffix = &quot;&quot;
}
else
{
$suffix = &quot; &quot;
}
}
else
{
$suffix = &quot;&quot;
}
$prefix + $_opt.Substring(0, $_opt.LastIndexOf($sep)+1) + $Item[$i] + $suffix

$preItem = $Item[$i]
}
}
}

function Get-PipeLineObject {

$i = -2
$property = $null
do {
$str = $line.Split(&quot;|&quot;)
# extract the command name from the string
# first split the string into statements and pipeline elements
# This doesn't handle strings however.
$_cmdlet = [regex]::Split($str[$i], '[|;=]')[-1]

# take the first space separated token of the remaining string
# as the command to look up. Trim any leading or trailing spaces
# so you don't get leading empty elements.
$_cmdlet = $_cmdlet.Trim().Split()[0]

if ( $_cmdlet -eq &quot;?&quot; )
{
$_cmdlet = &quot;Where-Object&quot;
}

$global:_exp = $_cmdlet

# now get the info object for it...
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

# loop resolving aliases...
while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
}

if ( &quot;Select-Object&quot; -eq $_cmdlet )
{
if ( $str[$i] -match '\s+-Exp\w*[\s:]+(\w+)' )
{
$property = $Matches[1] + &quot;;&quot; + $property
}
}

$i--
} while ( &quot;Get-Unique&quot;, &quot;Select-Object&quot;, &quot;Sort-Object&quot;, &quot;Tee-Object&quot;, &quot;Where-Object&quot; -contains $_cmdlet )

if ( $global:_forgci -eq $null )
{
$a = @(ls &quot;Alias:\&quot;)[0]
$e = @(ls &quot;Env:\&quot;)[0]
$f = @(ls &quot;Function:\&quot;)[0]
$h = @(ls &quot;HKCU:\&quot;)[0]
$v = @(ls &quot;Variable:\&quot;)[0]
$c = @(ls &quot;cert:\&quot;)[0]
$global:_forgci = gi $PSHOME\powershell.exe |
Add-Member -Name CommandType -MemberType 'NoteProperty' -Value $f.CommandType -PassThru |
Add-Member -Name Definition -MemberType 'NoteProperty' -Value $a.Definition -PassThru |
Add-Member -Name Description -MemberType 'NoteProperty' -Value $a.Description -PassThru |
Add-Member -Name Key -MemberType 'NoteProperty' -Value $e.Key -PassThru |
Add-Member -Name Location -MemberType 'NoteProperty' -Value $c.Location -PassThru |
Add-Member -Name LocationName -MemberType 'NoteProperty' -Value $c.LocationName -PassThru |
Add-Member -Name Options -MemberType 'NoteProperty' -Value $a.Options -PassThru |
Add-Member -Name ReferencedCommand -MemberType 'NoteProperty' -Value $a.ReferencedCommand -PassThru |
Add-Member -Name ResolvedCommand -MemberType 'NoteProperty' -Value $a.ResolvedCommand -PassThru |
Add-Member -Name ScriptBlock -MemberType 'NoteProperty' -Value $f.ScriptBlock -PassThru |
Add-Member -Name StoreNames -MemberType 'NoteProperty' -Value $c.StoreNames -PassThru |
Add-Member -Name SubKeyCount -MemberType 'NoteProperty' -Value $h.SubKeyCount -PassThru |
Add-Member -Name Value -MemberType 'NoteProperty' -Value $e.Value -PassThru |
Add-Member -Name ValueCount -MemberType 'NoteProperty' -Value $h.ValueCount -PassThru |
Add-Member -Name Visibility -MemberType 'NoteProperty' -Value $a.Visibility -PassThru |
Add-Member -Name Property -MemberType 'NoteProperty' -Value $h.Property -PassThru |
Add-Member -Name ResolvedCommandName -MemberType 'NoteProperty' -Value $a.ResolvedCommandName -PassThru |
Add-Member -Name Close -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name CreateSubKey -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name DeleteSubKey -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name DeleteSubKeyTree -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name DeleteValue -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Flush -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetSubKeyNames -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetValue -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetValueKind -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetValueNames -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IsValidValue -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name OpenSubKey -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name SetValue -MemberType 'ScriptMethod' -Value {} -PassThru
}

if ( $global:_mix -eq $null )
{
$f = gi $PSHOME\powershell.exe
$t = [type]
$s = &quot;&quot;
$global:_mix = `
Add-Member -InputObject (New-Object PSObject) -Name Mode -MemberType 'NoteProperty' -Value $f.Mode -PassThru |
Add-Member -Name Assembly -MemberType 'NoteProperty' -Value $t.Assembly -PassThru |
Add-Member -Name AssemblyQualifiedName -MemberType 'NoteProperty' -Value $t.AssemblyQualifiedName -PassThru |
Add-Member -Name Attributes -MemberType 'NoteProperty' -Value $f.Attributes -PassThru |
Add-Member -Name BaseType -MemberType 'NoteProperty' -Value $t.BaseType -PassThru |
Add-Member -Name ContainsGenericParameters -MemberType 'NoteProperty' -Value $t.ContainsGenericParameters -PassThru |
Add-Member -Name CreationTime -MemberType 'NoteProperty' -Value $f.CreationTime -PassThru |
Add-Member -Name CreationTimeUtc -MemberType 'NoteProperty' -Value $f.CreationTimeUtc -PassThru |
Add-Member -Name DeclaringMethod -MemberType 'NoteProperty' -Value $t.DeclaringMethod -PassThru |
Add-Member -Name DeclaringType -MemberType 'NoteProperty' -Value $t.DeclaringType -PassThru |
Add-Member -Name Exists -MemberType 'NoteProperty' -Value $f.Exists -PassThru |
Add-Member -Name Extension -MemberType 'NoteProperty' -Value $f.Extension -PassThru |
Add-Member -Name FullName -MemberType 'NoteProperty' -Value $f.FullName -PassThru |
Add-Member -Name GenericParameterAttributes -MemberType 'NoteProperty' -Value $t.GenericParameterAttributes -PassThru |
Add-Member -Name GenericParameterPosition -MemberType 'NoteProperty' -Value $t.GenericParameterPosition -PassThru |
Add-Member -Name GUID -MemberType 'NoteProperty' -Value $t.GUID -PassThru |
Add-Member -Name HasElementType -MemberType 'NoteProperty' -Value $t.HasElementType -PassThru |
Add-Member -Name IsAbstract -MemberType 'NoteProperty' -Value $t.IsAbstract -PassThru |
Add-Member -Name IsAnsiClass -MemberType 'NoteProperty' -Value $t.IsAnsiClass -PassThru |
Add-Member -Name IsArray -MemberType 'NoteProperty' -Value $t.IsArray -PassThru |
Add-Member -Name IsAutoClass -MemberType 'NoteProperty' -Value $t.IsAutoClass -PassThru |
Add-Member -Name IsAutoLayout -MemberType 'NoteProperty' -Value $t.IsAutoLayout -PassThru |
Add-Member -Name IsByRef -MemberType 'NoteProperty' -Value $t.IsByRef -PassThru |
Add-Member -Name IsClass -MemberType 'NoteProperty' -Value $t.IsClass -PassThru |
Add-Member -Name IsCOMObject -MemberType 'NoteProperty' -Value $t.IsCOMObject -PassThru |
Add-Member -Name IsContextful -MemberType 'NoteProperty' -Value $t.IsContextful -PassThru |
Add-Member -Name IsEnum -MemberType 'NoteProperty' -Value $t.IsEnum -PassThru |
Add-Member -Name IsExplicitLayout -MemberType 'NoteProperty' -Value $t.IsExplicitLayout -PassThru |
Add-Member -Name IsGenericParameter -MemberType 'NoteProperty' -Value $t.IsGenericParameter -PassThru |
Add-Member -Name IsGenericType -MemberType 'NoteProperty' -Value $t.IsGenericType -PassThru |
Add-Member -Name IsGenericTypeDefinition -MemberType 'NoteProperty' -Value $t.IsGenericTypeDefinition -PassThru |
Add-Member -Name IsImport -MemberType 'NoteProperty' -Value $t.IsImport -PassThru |
Add-Member -Name IsInterface -MemberType 'NoteProperty' -Value $t.IsInterface -PassThru |
Add-Member -Name IsLayoutSequential -MemberType 'NoteProperty' -Value $t.IsLayoutSequential -PassThru |
Add-Member -Name IsMarshalByRef -MemberType 'NoteProperty' -Value $t.IsMarshalByRef -PassThru |
Add-Member -Name IsNested -MemberType 'NoteProperty' -Value $t.IsNested -PassThru |
Add-Member -Name IsNestedAssembly -MemberType 'NoteProperty' -Value $t.IsNestedAssembly -PassThru |
Add-Member -Name IsNestedFamANDAssem -MemberType 'NoteProperty' -Value $t.IsNestedFamANDAssem -PassThru |
Add-Member -Name IsNestedFamily -MemberType 'NoteProperty' -Value $t.IsNestedFamily -PassThru |
Add-Member -Name IsNestedFamORAssem -MemberType 'NoteProperty' -Value $t.IsNestedFamORAssem -PassThru |
Add-Member -Name IsNestedPrivate -MemberType 'NoteProperty' -Value $t.IsNestedPrivate -PassThru |
Add-Member -Name IsNestedPublic -MemberType 'NoteProperty' -Value $t.IsNestedPublic -PassThru |
Add-Member -Name IsNotPublic -MemberType 'NoteProperty' -Value $t.IsNotPublic -PassThru |
Add-Member -Name IsPointer -MemberType 'NoteProperty' -Value $t.IsPointer -PassThru |
Add-Member -Name IsPrimitive -MemberType 'NoteProperty' -Value $t.IsPrimitive -PassThru |
Add-Member -Name IsPublic -MemberType 'NoteProperty' -Value $t.IsPublic -PassThru |
Add-Member -Name IsSealed -MemberType 'NoteProperty' -Value $t.IsSealed -PassThru |
Add-Member -Name IsSerializable -MemberType 'NoteProperty' -Value $t.IsSerializable -PassThru |
Add-Member -Name IsSpecialName -MemberType 'NoteProperty' -Value $t.IsSpecialName -PassThru |
Add-Member -Name IsUnicodeClass -MemberType 'NoteProperty' -Value $t.IsUnicodeClass -PassThru |
Add-Member -Name IsValueType -MemberType 'NoteProperty' -Value $t.IsValueType -PassThru |
Add-Member -Name IsVisible -MemberType 'NoteProperty' -Value $t.IsVisible -PassThru |
Add-Member -Name LastAccessTime -MemberType 'NoteProperty' -Value $f.LastAccessTime -PassThru |
Add-Member -Name LastAccessTimeUtc -MemberType 'NoteProperty' -Value $f.LastAccessTimeUtc -PassThru |
Add-Member -Name LastWriteTime -MemberType 'NoteProperty' -Value $f.LastWriteTime -PassThru |
Add-Member -Name LastWriteTimeUtc -MemberType 'NoteProperty' -Value $f.LastWriteTimeUtc -PassThru |
Add-Member -Name MemberType -MemberType 'NoteProperty' -Value $t.MemberType -PassThru |
Add-Member -Name MetadataToken -MemberType 'NoteProperty' -Value $t.MetadataToken -PassThru |
Add-Member -Name Module -MemberType 'NoteProperty' -Value $t.Module -PassThru |
Add-Member -Name Name -MemberType 'NoteProperty' -Value $t.Name -PassThru |
Add-Member -Name Namespace -MemberType 'NoteProperty' -Value $t.Namespace -PassThru |
Add-Member -Name Parent -MemberType 'NoteProperty' -Value $f.Parent -PassThru |
Add-Member -Name ReflectedType -MemberType 'NoteProperty' -Value $t.ReflectedType -PassThru |
Add-Member -Name Root -MemberType 'NoteProperty' -Value $f.Root -PassThru |
Add-Member -Name StructLayoutAttribute -MemberType 'NoteProperty' -Value $t.StructLayoutAttribute -PassThru |
Add-Member -Name TypeHandle -MemberType 'NoteProperty' -Value $t.TypeHandle -PassThru |
Add-Member -Name TypeInitializer -MemberType 'NoteProperty' -Value $t.TypeInitializer -PassThru |
Add-Member -Name UnderlyingSystemType -MemberType 'NoteProperty' -Value $t.UnderlyingSystemType -PassThru |
Add-Member -Name PSChildName -MemberType 'NoteProperty' -Value $f.PSChildName -PassThru |
Add-Member -Name PSDrive -MemberType 'NoteProperty' -Value $f.PSDrive -PassThru |
Add-Member -Name PSIsContainer -MemberType 'NoteProperty' -Value $f.PSIsContainer -PassThru |
Add-Member -Name PSParentPath -MemberType 'NoteProperty' -Value $f.PSParentPath -PassThru |
Add-Member -Name PSPath -MemberType 'NoteProperty' -Value $f.PSPath -PassThru |
Add-Member -Name PSProvider -MemberType 'NoteProperty' -Value $f.PSProvider -PassThru |
Add-Member -Name BaseName -MemberType 'NoteProperty' -Value $f.BaseName -PassThru |
Add-Member -Name Clone -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name CompareTo -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Contains -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name CopyTo -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Create -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name CreateObjRef -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name CreateSubdirectory -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Delete -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name EndsWith -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name FindInterfaces -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name FindMembers -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetAccessControl -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetArrayRank -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetConstructor -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetConstructors -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetCustomAttributes -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetDefaultMembers -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetDirectories -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetElementType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetEnumerator -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetEvent -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetEvents -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetField -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetFields -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetFiles -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetFileSystemInfos -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetGenericArguments -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetGenericParameterConstraints -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetGenericTypeDefinition -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetInterface -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetInterfaceMap -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetInterfaces -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetLifetimeService -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetMember -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetMembers -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetMethod -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetMethods -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetNestedType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetNestedTypes -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetObjectData -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetProperties -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetProperty -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name GetTypeCode -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IndexOf -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IndexOfAny -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name InitializeLifetimeService -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Insert -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name InvokeMember -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IsAssignableFrom -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IsDefined -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IsInstanceOfType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IsNormalized -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name IsSubclassOf -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name LastIndexOf -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name LastIndexOfAny -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name MakeArrayType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name MakeByRefType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name MakeGenericType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name MakePointerType -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name MoveTo -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Normalize -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name PadLeft -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name PadRight -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Refresh -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Remove -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Replace -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name SetAccessControl -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Split -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name StartsWith -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Substring -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name ToCharArray -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name ToLower -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name ToLowerInvariant -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name ToUpper -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name ToUpperInvariant -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Trim -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name TrimEnd -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name TrimStart -MemberType 'ScriptMethod' -Value {} -PassThru |
Add-Member -Name Chars -MemberType 'NoteProperty' -Value $s.Chars -PassThru
}


if ( &quot;Add-Member&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Compare-Object&quot; -eq $_cmdlet )
{
$global:_dummy =  (Compare-Object 1 2)[0]
}


if ( &quot;ConvertFrom-SecureString&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;ConvertTo-SecureString&quot; -eq $_cmdlet )
{
$global:_dummy = convertto-securestring &quot;P@ssW0rD!&quot; -asplaintext -force
}


if ( &quot;ForEach-Object&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Acl&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Acl
}


if ( &quot;Get-Alias&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Alias)[0]
}


if ( &quot;Get-AuthenticodeSignature&quot; -eq $_cmdlet )
{
$global:_dummy = Get-AuthenticodeSignature $PSHOME\powershell.exe
}


if ( &quot;Get-ChildItem&quot; -eq $_cmdlet )
{
$global:_dummy = $global:_forgci
}


if ( &quot;Get-Command&quot; -eq $_cmdlet )
{
$global:_dummy = @(iex $str[$i+1])[0]
}


if ( &quot;Get-Content&quot; -eq $_cmdlet )
{
$global:_dummy = (type $PSHOME\profile.ps1)[0]
}


if ( &quot;Get-Credential&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Culture&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Culture
}


if ( &quot;Get-Date&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Date
}


if ( &quot;Get-Event&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Event)[0]
}


if ( &quot;Get-EventLog&quot; -eq $_cmdlet )
{
$global:_dummy = @(iex $str[$i+1])[0]
}


if ( &quot;Get-ExecutionPolicy&quot; -eq $_cmdlet )
{
$global:_dummy = Get-ExecutionPolicy
}


if ( &quot;Get-Help&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Help Add-Content
}


if ( &quot;Get-History&quot; -eq $_cmdlet )
{
$global:_dummy = Get-History -Count 1
}


if ( &quot;Get-Host&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Host
}


if ( &quot;Get-Item&quot; -eq $_cmdlet )
{
$global:_dummy = $global:_forgci
}


if ( &quot;Get-ItemProperty&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Location&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Location
}


if ( &quot;Get-Member&quot; -eq $_cmdlet )
{
$global:_dummy = (1|Get-Member)[0]
}


if ( &quot;Get-Module&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Module)[0]
}


if ( &quot;Get-PfxCertificate&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Process&quot; -eq $_cmdlet )
{
$global:_dummy = ps powershell
}


if ( &quot;Get-PSBreakpoint&quot; -eq $_cmdlet )
{
$global:_dummy =
Add-Member -InputObject (New-Object PSObject) -Name Action -MemberType 'NoteProperty' -Value '' -PassThru |
Add-Member -Name Command -MemberType 'NoteProperty' -Value '' -PassThru |
Add-Member -Name Enabled -MemberType 'NoteProperty' -Value '' -PassThru |
Add-Member -Name HitCount -MemberType 'NoteProperty' -Value '' -PassThru |
Add-Member -Name Id -MemberType 'NoteProperty' -Value '' -PassThru |
Add-Member -Name Script -MemberType 'NoteProperty' -Value '' -PassThru
}


if ( &quot;Get-PSCallStack&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSCallStack
}


if ( &quot;Get-PSDrive&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSDrive Function
}


if ( &quot;Get-PSProvider&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSProvider FileSystem
}


if ( &quot;Get-PSSnapin&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSSnapin Microsoft.PowerShell.Core
}


if ( &quot;Get-Service&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Service)[0]
}


if ( &quot;Get-TraceSource&quot; -eq $_cmdlet )
{
$global:_dummy = Get-TraceSource AddMember
}


if ( &quot;Get-UICulture&quot; -eq $_cmdlet )
{
$global:_dummy = Get-UICulture
}


if ( &quot;Get-Variable&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Variable _
}


if ( &quot;Get-WmiObject&quot; -eq $_cmdlet )
{
$global:_dummy = @(iex $str[$i+1])[0]
}


if ( &quot;Group-Object&quot; -eq $_cmdlet )
{
$global:_dummy = 1 | group
}


if ( &quot;Measure-Command&quot; -eq $_cmdlet )
{
$global:_dummy = Measure-Command {}
}


if ( &quot;Measure-Object&quot; -eq $_cmdlet )
{
$global:_dummy = Measure-Object
}


if ( &quot;New-PSDrive&quot; -eq $_cmdlet )
{
$global:_dummy =  Get-PSDrive Alias
}


if ( &quot;New-TimeSpan&quot; -eq $_cmdlet )
{
$global:_dummy = New-TimeSpan
}


if ( &quot;Resolve-Path&quot; -eq $_cmdlet )
{
$global:_dummy = $PWD
}


if ( &quot;Select-String&quot; -eq $_cmdlet )
{
$global:_dummy = &quot; &quot; | Select-String &quot; &quot;
}


if ( &quot;Set-Date&quot; -eq $_cmdlet )
{
$global:_dummy =  Get-Date
}

if ( $property -ne $null)
{
foreach ( $name in $property.Split(&quot;;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) )
{
$global:_dummy = @($global:_dummy.$name)[0]
}
}
}


function TabExpansion {

param($line, $lastWord)

&amp; {

function Write-Members ($sep='.')
{

Invoke-Expression ('$_val=' + $_expression)

if ( $_expression -match '^\$global:_dummy' )
{
$temp = $_expression -replace '^\$global:_dummy(.*)','$1'
$_expression = '$_' + $temp
}

$_method = [Management.Automation.PSMemberTypes] `
'Method,CodeMethod,ScriptMethod,ParameterizedProperty'
if ($sep -eq '.')
{
$params = @{view = 'extended','adapted','base'}
}
else
{
$params = @{static=$true}
}

if ( $_val -is [Hashtable] )
{
[Object[]]$_keys = $null
foreach ( $_name in $_val.Keys )
{
$_keys += `
New-Object Microsoft.PowerShell.Commands.MemberDefinition `
[int],$_name,&quot;Property&quot;,0
}
}

if ( $_keys -ne $null )
{
$_members = [Object[]](Get-Member @params -InputObject $_val $_pat) + ($_keys | ? {$_.name -like $_pat})
} else {
$_members = (Get-Member @params -InputObject $_val $_pat)
}

foreach ($_m in $_members | Sort-Object membertype,name)
{
if ($_m.MemberType -band $_method)
{
# Return a method...
$_base + $_expression + $sep + $_m.name + '('
}
else {
# Return a property...
$_base + $_expression + $sep + $_m.name
}
}
}
$host.UI.RawUI.WindowTitle = &quot;Windows PowerShell V2 (CTP2)&quot; + $lastword

switch -regex ($lastWord)
{
# Handle property and method expansion at '$_'
'(^.*)(\$_\.)(\w*)$' {
$_base = $matches[1]
$_expression = '$global:_dummy'
$_pat = $matches[3] + '*'
$global:_dummy = $null
Get-PipeLineObject
if ( $global:_dummy -eq $null )
{

if ( $global:_exp -match '^\$.*\(.*$' )
{
$type = ( iex $global:_exp.Split(&quot;(&quot;)[0] ).OverloadDefinitions[0].Split(&quot; &quot;)[0] -replace '\[[^\[\]]*\]$' -as [type]

if ( $_expression -match '^\$global:_dummy' )
{
$temp = $_expression -replace '^\$global:_dummy(.*)','$1'
$_expression = '$_' + $temp
}

foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
{
if ($_m.MemberType -eq &quot;Method&quot;)
{
$_base + $_expression + '.' + $_m.name + '('
}
else {
$_base + $_expression + '.' + $_m.name
}
}
break;
}
elseif ( $global:_exp -match '^\[.*\:\:.*\(.*$' )
{
$tname, $mname = $_exp.Split(&quot;:(&quot;, &quot;RemoveEmptyEntries&quot;-as [System.StringSplitOptions])[0,1]
$type = @(iex ($tname + '.GetMember(&quot;' + $mname + '&quot;)'))[0].ReturnType.FullName -replace '\[[^\[\]]*\]$' -as [type]

if ( $_expression -match '^\$global:_dummy' )
{
$temp = $_expression -replace '^\$global:_dummy(.*)','$1'
$_expression = '$_' + $temp
}

foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
{
if ($_m.MemberType -eq &quot;Method&quot;)
{
$_base + $_expression + '.' + $_m.name + '('
}
else {
$_base + $_expression + '.' + $_m.name
}
}
break;
}
elseif ( $global:_exp -match '^(\$\w+(\[[0-9,\.]+\])*(\.\w+(\[[0-9,\.]+\])*)*)$' )
{
$global:_dummy = @(iex $Matches[1])[0]
}
else
{
$global:_dummy =  $global:_mix
}
}

Write-Members
break;
}

# Handle property and method expansion rooted at variables...
# e.g. $a.b.&lt;tab&gt;
'(^.*)(\$(\w|\.)+)\.(\w*)$' {
$_base = $matches[1]
$_expression = $matches[2]
$_pat = $matches[4] + '*'
[void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
if ( $_expression -match '^\$_\.' )
{
$_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
}
Write-Members
break;
}

# Handle simple property and method expansion on static members...
# e.g. [datetime]::n&lt;tab&gt;
'(^.*)(\[(\w|\.)+\])\:\:(\w*)$' {
$_base = $matches[1]
$_expression = $matches[2]
$_pat = $matches[4] + '*'
Write-Members '::'
break;
}

# Handle complex property and method expansion on static members
# where there are intermediate properties...
# e.g. [datetime]::now.d&lt;tab&gt;
'(^.*)(\[(\w|\.)+\]\:\:(\w+\.)+)(\w*)$' {
$_base = $matches[1]  # everything before the expression
$_expression = $matches[2].TrimEnd('.') # expression less trailing '.'
$_pat = $matches[5] + '*'  # the member to look for...
Write-Members
break;
}

# Handle variable name expansion...
'(^.*\$)(\w+)$' {
$_prefix = $matches[1]
$_varName = $matches[2]
foreach ($_v in Get-ChildItem ('variable:' + $_varName + '*'))
{
$_prefix + $_v.name
}
break;
}

# Handle env&amp;function drives variable name expansion...
'(^.*\$)(.*\:)(\w+)$' {
$_prefix = $matches[1]
$_drive = $matches[2]
$_varName = $matches[3]
if ($_drive -eq &quot;env:&quot; -or $_drive -eq &quot;function:&quot;)
{
foreach ($_v in Get-ChildItem ($_drive + $_varName + '*'))
{
$_prefix + $_drive + $_v.name
}
}
break;
}

# Handle array's element property and method expansion
# where there are intermediate properties...
# e.g. foo[0].n.b&lt;tab&gt;
'(^.*)(\$((\w+\.)|(\w+(\[(\w|,)+\])+\.))+)(\w*)$'
{
$_base = $matches[1]
$_expression = $matches[2].TrimEnd('.')
$_pat = $Matches[8] + '*'
[void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
if ( $_expression -match '^\$_\.' )
{
$_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
}
Write-Members
break;
}

# Handle property and method expansion rooted at type object...
# e.g. [System.Type].a&lt;tab&gt;
'(^\[(\w|\.)+\])\.(\w*)$'
{
if ( $(iex $Matches[1]) -isnot [System.Type] ) { break; }
$_expression = $Matches[1]
$_pat = $Matches[$matches.Count-1] + '*'
Write-Members
break;
}

# Handle complex property and method expansion on type object members
# where there are intermediate properties...
# e.g. [datetime].Assembly.a&lt;tab&gt;
'^(\[(\w|\.)+\]\.(\w+\.)+)(\w*)$' {
$_expression = $matches[1].TrimEnd('.') # expression less trailing '.'
$_pat = $matches[4] + '*'  # the member to look for...
if ( $(iex $_expression) -eq $null ) { break; }
Write-Members
break;
}

# Handle property and method expansion rooted at close parenthes...
# e.g. (123).a&lt;tab&gt;
'^(.*)\)((\w|\.)*)\.(\w*)$' {
$_base = $Matches[1] + &quot;)&quot;
if ( $matches[3] -eq $null) { $_expression = '[System.Type]' }
else { $_expression = '[System.Type]' + $Matches[2] }
$_pat = $matches[4] + '*'
iex &quot;$_expression | Get-Member $_pat | sort MemberType,Name&quot; |
% {
if ( $_.MemberType -like &quot;*Method*&quot; -or $_.MemberType -like &quot;*Parameterized*&quot; ) { $parenthes = &quot;(&quot; }
if ( $Matches[2] -eq &quot;&quot; ) { $_base + &quot;.&quot; + $_.Name + $parenthes }
else { $_base + $Matches[2] + &quot;.&quot; + $_.Name + $parenthes }
}
break;
}


# Handle .NET type name expansion ...
# e.g. [Microsoft.PowerShell.Com&lt;tab&gt;
'^\[((\w+\.?)*)$' {
$_opt = $matches[1] + '*'
if ( $_opt -eq &quot;*&quot; )
{
$_TypeAccelerators -like $_opt -replace '^(.*)$', '[$1]'
}
else
{
$_TypeAccelerators -like $_opt -replace '^(.*)$', '[$1]'
Write-ClassNames $_TypeNames_System ($_opt.Split(&quot;.&quot;).Count-1) '['
Write-ClassNames $_TypeNames ($_opt.Split(&quot;.&quot;).Count-1) '['
}
break;
}

# Handle file/directory name which contains $env: variable
# e.g.  $env:windir\&lt;tab&gt;
'^\$(env:)?\w+([\\/][^\\/]*)*$' {
$path = iex ('&quot;' + $Matches[0] + '&quot;')
if ( $Matches[2].Length -gt 1 )
{
$parent = Split-Path $path -Parent
$leaf = (Split-Path $path -Leaf) + '*'
}
else
{
$parent = $path
$leaf = '*'
}
if ( Test-Path $parent )
{
$i = $Matches[0].LastIndexOfAny(&quot;/\&quot;)
$_base = $Matches[0].Substring(0,$i+1)
[IO.Directory]::GetFileSystemEntries( $parent, $leaf ) | % { $_base + ($_.Split(&quot;\/&quot;)[-1] -replace '([\$\s&amp;])','`$1' -replace '([[\]])', '````$1') }
}
}

# Handle file glob expansion ...
# e.g. *.txt~about*@&lt;tab&gt;
'^(\^?([^~]+))(~(.*))*@$' {
if ( $Matches[1] -notlike &quot;^*&quot; )
{
$include = $Matches[2] -replace '``','`'
if ( $Matches[3] )
{
$exclude = $Matches[3].Split(&quot;~&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) -replace '``','`'
}
}
else
{
$include = &quot;*&quot;
$exclude = $Matches[2] -replace '``','`'
}
$fse = [IO.Directory]::GetFileSystemEntries($PWD)
$fse = $fse -replace '.*[\\/]([^/\\]*)$','$1'
% -in ($fse -like $include) { $fse = $_; $exclude | % { $fse = $fse -notlike $_ } }
$fse = $fse -replace '^.*\s.*$', (&quot;'`$0'&quot;)
$fse = $fse -replace '([\[\]])', '``$1' -replace '^.*([\[\]]).*$', (&quot;'`$0'&quot;)
$fse = $fse -replace &quot;''&quot;, &quot;'&quot;
$OFS = &quot;, &quot;; &quot;$fse&quot;
$OFS = &quot;, &quot;; &quot;* -Filter $include &quot; + $(if($exclude){&quot;-Exclude $exclude&quot;})
$Matches[0].Substring(0, $Matches[0].Length-1)
break;
}

# Handle command buffer stack...
'(.*);(.?)$' {
$_base = $Matches[1]
if ( $Matches[2] -eq &quot;:&quot; -or $Matches[2] -eq &quot;,&quot; )
{
if ( $_cmdstack.Count -gt 0 )
{
$_base + $global:_cmdstack.Pop()
}
else
{
&quot;&quot;
}
}
elseif ( $Matches[2] -eq &quot;&quot; )
{
$global:_cmdstack.Push($line.SubString(0,$line.Length-1))
[System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
}
}

# Do completion on parameters...
'^-([\w0-9]*)' {
$_pat = $matches[1] + '*'

# extract the command name from the string
# first split the string into statements and pipeline elements
# This doesn't handle strings however.
$_command = [regex]::Split($line, '[|;=]')[-1]

#  Extract the trailing unclosed block e.g. ls | foreach { cp
if ($_command -match '\{([^\{\}]*)$')
{
$_command = $matches[1]
}

# Extract the longest unclosed parenthetical expression...
if ($_command -match '\(([^()]*)$')
{
$_command = $matches[1]
}

# take the first space separated token of the remaining string
# as the command to look up. Trim any leading or trailing spaces
# so you don't get leading empty elements.
$_command = $_command.Trim().Split()[0]

# now get the info object for it...
$_command = @(Get-Command -type 'Cmdlet,Alias,Function,Filter,ExternalScript' $_command)[0]

# loop resolving aliases...
while ($_command.CommandType -eq 'alias')
{
$_command = @(Get-Command -type 'Cmdlet,Alias,Function,Filter,ExternalScript' $_command.Definition)[0]
}

if ( $_command -ne $null )
{
# expand the parameter sets and emit the matching elements
foreach ($_n in $_command.Parameters.Keys | sort)
{
if ($_n -like $_pat) { '-' + $_n }
}
}
else
{
&quot;-and&quot;, &quot;-as&quot;, &quot;-band&quot;, &quot;-bnot&quot;, &quot;-bor&quot;, &quot;-bxor&quot;, &quot;-ccontains&quot;, &quot;-ceq&quot;, &quot;-cge&quot;, &quot;-cgt&quot;, &quot;-cle&quot;, &quot;-clike&quot;, &quot;-clt&quot;,
&quot;-cmatch&quot;, &quot;-cne&quot;, &quot;-cnotcontains&quot;, &quot;-cnotlike&quot;, &quot;-cnotmatch&quot;, &quot;-contains&quot;, &quot;-creplace&quot;, &quot;-csplit&quot;, &quot;-eq&quot;, &quot;-f&quot;, &quot;-ge&quot;,
&quot;-gt&quot;, &quot;-icontains&quot;, &quot;-ieq&quot;, &quot;-ige&quot;, &quot;-igt&quot;, &quot;-ile&quot;, &quot;-ilike&quot;, &quot;-ilt&quot;, &quot;-imatch&quot;, &quot;-ine&quot;, &quot;-inotcontains&quot;, &quot;-inotlike&quot;,
&quot;-inotmatch&quot;, &quot;-ireplace&quot;, &quot;-is&quot;, &quot;-isnot&quot;, &quot;-isplit&quot;, &quot;-join&quot;, &quot;-le&quot;, &quot;-like&quot;, &quot;-lt&quot;, &quot;-match&quot;, &quot;-ne&quot;, &quot;-not&quot;, &quot;-notcontains&quot;, 
&quot;-notlike&quot;, &quot;-notmatch&quot;, &quot;-or&quot;, &quot;-replace&quot;, &quot;-split&quot;, &quot;-xor&quot; -like &quot;-$_pat&quot;
}
break;
}

# Tab complete against history either #&lt;pattern&gt; or #&lt;id&gt;
'^#(\w*)' {
$_pattern = $matches[1]
if ($_pattern -match '^[0-9]+$')
{
Get-History -ea SilentlyContinue -Id $_pattern | Foreach { $_.CommandLine } 
}
else
{
$_pattern = '*' + $_pattern + '*'
Get-History | Sort-Object -Descending Id| Foreach { $_.CommandLine } | where { $_ -like $_pattern }
}
break;
}

# try to find a matching command...
default {

$lastex =  [regex]::Split($line, '[|;]')[-1]
if ( $lastex -match '^\s*(\$\w+(\[[0-9,]+\])*(\.\w+(\[[0-9,]+\])*)*)\s*=\s+((&quot;\w+&quot;\s*,\s+)*)&quot;\w+&quot;\s*-as\s+$' )
{
if ( $Matches[6] -ne $nul )
{
$brackets = &quot;[]&quot;
}
'['+ $global:_enum + $brackets + ']'
break;
}


if ( $lastex -match '^\s*(\$\w+(\[[0-9,]+\])*(\.\w+(\[[0-9,]+\])*)*)\s*=\s+((&quot;\w+&quot;\s*,\s+)*)\s*(\w*)$' )
{
$_pat = $Matches[7] + '*'

$_type = @(iex $Matches[1])[0].GetType()
if ( $_type.IsEnum )
{
$global:_enum = $_type.FullName
[Enum]::GetValues($_type) -like $_pat -replace '^(.*)$','&quot;$1&quot;'
break;
}
}


$lastex =  [regex]::Split($line, '[|;=]')[-1]
if ($lastex  -match '[[$].*\w+\(.*-as\s*$')
{
'['+ $global:_enum + ']'
}
elseif ( $lastex -match '([[$].*(\w+))\((.*)$' )
{
$_method = $Matches[1]

if ( $Matches[3] -match &quot;(.*)((`&quot;|')(\w+,)+(\w*))$&quot; )
{
$continuous = $true
$_opt =  $Matches[5] + '*'
$_base =  $Matches[2].TrimStart('&quot;') -replace '(.*,)\w+$','$1'
$position = $Matches[1].Split(&quot;,&quot;).Length
}
else
{
$continuous = $false
$_opt = ($Matches[3].Split(',')[-1] -replace '^\s*','') + &quot;*&quot;
$position = $Matches[3].Split(&quot;,&quot;).Length
}

if ( ($_mdefs = iex ($_method + &quot;.OverloadDefinitions&quot;)) -eq $null )
{
$tname, $mname = $_method.Split(&quot;:&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
$_mdefs = iex ($tname + '.GetMember(&quot;' + $mname + '&quot;) | % { $_.ToString() }')
}

foreach ( $def in $_mdefs )
{
[void] ($def -match '\((.*)\)')
foreach ( $param in [regex]::Split($Matches[1], ', ')[$position-1] )
{
if ($param -eq $null -or $param -eq &quot;&quot;)
{
continue;
}
$type = $param.split()[0]

if ( $type -like '*`[*' -or $type -eq &quot;Params&quot; -or $type -eq &quot;&quot; )
{
continue;
}
$fullname  = @($_typenames -like &quot;*$type*&quot;)
foreach ( $name in $fullname )
{
if ( $continuous -eq $true -and ( $name  -as [System.Type] ).IsEnum )
{
$output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$',($_base + '$1')
$output | sort
}
elseif ( ( $name  -as [System.Type] ).IsEnum ) 
{
$global:_enum = $name
$output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$','&quot;$1&quot;'
$output | sort
}
}
}
}
if ( $output -ne $null )
{
break;
}
}

if ( $line -match '(function|filter)\s+(\w*)$')
{
$_pat = 'function:\' + $Matches[2] + '*'
Get-ChildItem $_pat| % { $_.Name }
break;
}

if ( $line[-1] -eq &quot; &quot; )
{
$_cmdlet = $line.TrimEnd(&quot; &quot;).Split(&quot; |(;={&quot;)[-1]

# now get the info object for it...
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

# loop resolving aliases...
while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
}

if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
{
&quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; | sort
break;
}

if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
{
Get-TraceSource | % { $_.Name } | sort -Unique
break;
}

if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
{
$_TypeAccelerators
break;
}

if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
{
$_WMIClasses
break;
}

if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
{
Get-Process | % { $_.Name } | sort
break;
}

if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
{
if ( $global:_snapin -ne $null )
{
$global:_snapin
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin
break;
}
}

if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; )
{
Get-PSDrive | sort
break;
}

if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
{
Get-EventLog -List | % { $_base + ($_.Log -replace '\s','` ') }
break;
}

if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
{
Get-Help -Category all | % { $_.Name } | sort -Unique
break;
}

if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
&quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
-contains $_cmdlet.Name )
{
Get-Service | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
{
Get-Command -CommandType All | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
&quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
-contains $_cmdlet.Name )
{
Get-PipeLineObject
$_dummy | gm -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Clear-Variable&quot;, &quot;Get-Variable&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Variable&quot; -contains $_cmdlet.Name )
{
Get-Variable -Scope Global | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Alias&quot;, &quot;New-Alias&quot;, &quot;Set-Alias&quot; -contains $_cmdlet.Name )
{
Get-Alias | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}
}


if ( $line[-1] -eq &quot; &quot; )
{
$_cmdlet = [regex]::Split($line, '[|;=]')[-1]

if ($_cmdlet -match '\{([^\{\}]*)$')
{
$_cmdlet = $matches[1]
}

if ($_cmdlet -match '\(([^()]*)$')
{
$_cmdlet = $matches[1]
}

$_cmdlet = $_cmdlet.Trim().Split()[0]

$_cmdlet = @(Get-Command -type 'Application' $_cmdlet)[0]

if ( $_cmdlet.Name -eq &quot;powershell.exe&quot; )
{
&quot;-PSConsoleFile&quot;, &quot;-Version&quot;, &quot;-NoLogo&quot;, &quot;-NoExit&quot;, &quot;-Sta&quot;, &quot;-NoProfile&quot;, &quot;-NonInteractive&quot;,
&quot;-InputFormat&quot;, &quot;-OutputFormat&quot;, &quot;-EncodedCommand&quot;, &quot;-File&quot;, &quot;-Command&quot; | sort
break;
}
if ( $_cmdlet.Name -eq &quot;fsutil.exe&quot; )
{
&quot;behavior query&quot;, &quot;behavior set&quot;, &quot;dirty query&quot;, &quot;dirty set&quot;, 
&quot;file findbysid&quot;, &quot;file queryallocranges&quot;, &quot;file setshortname&quot;, &quot;file setvaliddata&quot;, &quot;file setzerodata&quot;, &quot;file createnew&quot;, 
&quot;fsinfo drives&quot;, &quot;fsinfo drivetype&quot;, &quot;fsinfo volumeinfo&quot;, &quot;fsinfo ntfsinfo&quot;, &quot;fsinfo statistics&quot;, 
&quot;hardlink create&quot;, &quot;objectid query&quot;, &quot;objectid set&quot;, &quot;objectid delete&quot;, &quot;objectid create&quot;,
&quot;quota disable&quot;, &quot;quota track&quot;, &quot;quota enforce&quot;, &quot;quota violations&quot;, &quot;quota modify&quot;, &quot;quota query&quot;,
&quot;reparsepoint query&quot;, &quot;reparsepoint delete&quot;, &quot;sparse setflag&quot;, &quot;sparse queryflag&quot;, &quot;sparse queryrange&quot;, &quot;sparse setrange&quot;,
&quot;usn createjournal&quot;, &quot;usn deletejournal&quot;, &quot;usn enumdata&quot;, &quot;usn queryjournal&quot;, &quot;usn readdata&quot;, &quot;volume dismount&quot;, &quot;volume diskfree&quot; | sort
break;
}
if ( $_cmdlet.Name -eq &quot;net.exe&quot; )
{
&quot;ACCOUNTS &quot;, &quot; COMPUTER &quot;, &quot; CONFIG &quot;, &quot; CONTINUE &quot;, &quot; FILE &quot;, &quot; GROUP &quot;, &quot; HELP &quot;, 
&quot;HELPMSG &quot;, &quot; LOCALGROUP &quot;, &quot; NAME &quot;, &quot; PAUSE &quot;, &quot; PRINT &quot;, &quot; SEND &quot;, &quot; SESSION &quot;, 
&quot;SHARE &quot;, &quot; START &quot;, &quot; STATISTICS &quot;, &quot; STOP &quot;, &quot; TIME &quot;, &quot; USE &quot;, &quot; USER &quot;, &quot; VIEW&quot; | sort
break;
}
if ( $_cmdlet.Name -eq &quot;ipconfig.exe&quot; )
{
&quot;/?&quot;, &quot;/all&quot;, &quot;/renew&quot;, &quot;/release&quot;, &quot;/flushdns&quot;, &quot;/displaydns&quot;,
&quot;/registerdns&quot;, &quot;/showclassid&quot;, &quot;/setclassid&quot;
break;
}
}

if ( $line -match '\w+\s+(\w+(\.|[^\s\.])*)$' )
{
$_cmdlet = $line.TrimEnd(&quot; &quot;).Split(&quot; |(;={&quot;)[-2]

$_opt = $Matches[1].Split(&quot; ,&quot;)[-1] + '*'
$_base = $Matches[1].Substring(0,$Matches[1].Length-$Matches[1].Split(&quot; ,&quot;)[-1].length)

$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
}

if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
{
&quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; -like $_opt | sort
break;
}

if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
{
Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
{
$_TypeAccelerators -like $_opt
Write-ClassNames $_TypeNames_System ($_opt.Split(&quot;.&quot;).Count-1)
Write-ClassNames $_TypeNames ($_opt.Split(&quot;.&quot;).Count-1)
break;
}

if ( $_cmdlet.Name -like &quot;*WMI*&quot; )
{
Write-ClassNames $_WMIClasses ($_opt.Split(&quot;_&quot;).Count-1) -sep '_'
break;
}

if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
{
Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
{
if ( $global:_snapin -ne $null )
{
$global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
break;
}
}

if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; )
{
Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-PSProvider&quot; -eq $_cmdlet.Name )
{
Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}


if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
{
Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
break;
}

if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
{
Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
break;
}

if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
&quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
-contains $_cmdlet.Name )
{
Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
{
Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
&quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
-contains $_cmdlet.Name )
{

Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Clear-Variable&quot;, &quot;Get-Variable&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Variable&quot; -contains $_cmdlet.Name )
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Alias&quot;, &quot;New-Alias&quot;, &quot;Set-Alias&quot; -contains $_cmdlet.Name )
{
Get-Alias -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}
}

if ( $line -match '(-(\w+))\s+([^-]*$)' )
{

$_param = $matches[2] + '*'
$_opt = $Matches[3].Split(&quot; ,&quot;)[-1] + '*'
$_base = $Matches[3].Substring(0,$Matches[3].Length-$Matches[3].Split(&quot; ,&quot;)[-1].length)

$_cmdlet = [regex]::Split($line, '[|;=]')[-1]

if ($_cmdlet -match '\{([^\{\}]*)$')
{
$_cmdlet = $matches[1]
}

if ($_cmdlet -match '\(([^()]*)$')
{
$_cmdlet = $matches[1]
}

$_cmdlet = $_cmdlet.Trim().Split()[0]

$_cmdlet = @(Get-Command -type 'Cmdlet,Alias,Function,Filter,ExternalScript' $_cmdlet)[0]

while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'Cmdlet,Alias,Function,Filter,ExternalScript' $_cmdlet.Definition)[0]
}

if ( $_param.TrimEnd(&quot;*&quot;) -eq &quot;ea&quot; -or $_param.TrimEnd(&quot;*&quot;) -eq &quot;wa&quot; )
{
&quot;SilentlyContinue&quot;, &quot;Stop&quot;, &quot;Continue&quot;, &quot;Inquire&quot; |
? { $_ -like $_opt } | sort -Unique
break;
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot; -contains $_cmdlet.Name `
-and &quot;groupBy&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_.Name }
break;
}

if ( $_param.TrimEnd(&quot;*&quot;) -eq &quot;ev&quot; -or $_param.TrimEnd(&quot;*&quot;) -eq &quot;ov&quot; -or
&quot;ErrorVariable&quot; -like $_param -or &quot;OutVariable&quot; -like $_param)
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort
break;
}

if ( &quot;Tee-Object&quot; -eq $_cmdlet.Name -and &quot;Variable&quot; -like $_param )
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort
break;
}

if ( &quot;Clear-Variable&quot;, &quot;Get-Variable&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Variable&quot; -contains $_cmdlet.Name `
-and &quot;Name&quot; -like $_param)
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Export-Alias&quot;, &quot;Get-Alias&quot;, &quot;New-Alias&quot;, &quot;Set-Alias&quot; -contains $_cmdlet.Name `
-and &quot;Name&quot; -like $_param)
{
Get-Alias -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Out-File&quot;,&quot;Export-CSV&quot;,&quot;Select-String&quot;,&quot;Export-Clixml&quot; -contains $_cmdlet.Name `
-and &quot;Encoding&quot; -like $_param)
{
&quot;Unicode&quot;,  &quot;UTF7&quot;, &quot;UTF8&quot;, &quot;ASCII&quot;, &quot;UTF32&quot;, &quot;BigEndianUnicode&quot;, &quot;Default&quot;, &quot;OEM&quot; |
? { $_ -like $_opt } | sort -Unique
break;
}

if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name `
-and &quot;Name&quot; -like $_param)
{
Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;New-Object&quot; -like $_cmdlet.Name )
{
if ( &quot;ComObject&quot; -like $_param )
{
$_ProgID -like $_opt | % { $_ -replace '\s','` ' }
break;
}

if ( &quot;TypeName&quot; -like $_param )
{
if ( $_opt -eq &quot;*&quot; )
{
$_TypeAccelerators -like $_opt
}
else
{
$_TypeAccelerators -like $_opt
Write-ClassNames $_TypeNames_System ($_opt.Split(&quot;.&quot;).Count-1)
Write-ClassNames $_TypeNames ($_opt.Split(&quot;.&quot;).Count-1)
}
break;
}
}

if ( &quot;New-Item&quot; -eq $_cmdlet.Name )
{
if ( &quot;ItemType&quot; -like $_param )
{
&quot;directory&quot;, &quot;file&quot; -like $_opt
break;
}
}

if ( &quot;Get-Location&quot;, &quot;Get-PSDrive&quot;, &quot;Get-PSProvider&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name `
-and &quot;PSProvider&quot; -like $_param )
{
Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort  | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Location&quot; -eq $_cmdlet.Name -and &quot;PSDrive&quot; -like $_param )
{
Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and  &quot;PSSnapin&quot; -like $_param)
{
if ( $global:_snapin -ne $null )
{
$global:_snapin -like $_opt  | % { $_base + $_ }
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin -like $_opt  | % { $_base + ($_ -replace '\s','` ') }
break;
}
}

if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
if ( $global:_snapin -ne $null )
{
$global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin -like $_opt | % { $_base + $_ }
break;
}
}

if ( &quot;Clear-Variable&quot;, &quot;Export-Alias&quot;, &quot;Get-Alias&quot;, &quot;Get-PSDrive&quot;, &quot;Get-Variable&quot;, &quot;Import-Alias&quot;,
&quot;New-Alias&quot;, &quot;New-PSDrive&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Alias&quot;, &quot;Set-Variable&quot; `
-contains $_cmdlet.Name -and &quot;Scope&quot; -like $_param )
{
&quot;Global&quot;, &quot;Local&quot;, &quot;Script&quot; -like $_opt
break;
}

if ( &quot;Get-Process&quot;, &quot;Stop-Process&quot;, &quot;Wait-Process&quot; -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name -and &quot;LogName&quot; -like $_param )
{
Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
break;
}

if ( &quot;Get-Help&quot; -eq $_cmdlet.Name )
{
if ( &quot;Name&quot; -like $_param )
{
Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
break;
}
if ( &quot;Category&quot; -like $_param )
{
&quot;Alias&quot;, &quot;Cmdlet&quot;, &quot;Provider&quot;, &quot;General&quot;, &quot;FAQ&quot;,
&quot;Glossary&quot;, &quot;HelpFile&quot;, &quot;All&quot; -like $_opt | sort | % { $_base + $_ }
break;
}
}

if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
&quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
-contains $_cmdlet.Name )
{
if ( &quot;Name&quot; -like $_param )
{
Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
break;
}
if ( &quot;DisplayName&quot; -like $_param )
{
Get-Service -Name $_opt | sort DisplayName | % { $_base + ($_.DisplayName -replace '\s','` ') }
break;
}
}

if ( &quot;New-Service&quot; -eq $_cmdlet.Name -and &quot;dependsOn&quot; -like $_param )
{
Get-Service -Name $_opt | sort Name | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Get-EventLog&quot; -eq $_cmdlet.Name -and &quot;EntryType&quot; -like $_param )
{
&quot;Error&quot;, &quot;Information&quot;, &quot;FailureAudit&quot;, &quot;SuccessAudit&quot;, &quot;Warning&quot; -like $_opt | sort | % { $_base + $_ }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
{
if ( &quot;Class&quot; -like $_param )
{
Write-ClassNames $_WMIClasses ($_opt.Split(&quot;_&quot;).Count-1) -sep '_'
break;
}
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
&quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
-contains $_cmdlet.Name -and &quot;Property&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Select-Object&quot; -eq $_cmdlet.Name )
{
if ( &quot;ExcludeProperty&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;ExpandProperty&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_.Name }
break;
}
}

select -InputObject $_cmdlet -ExpandProperty ParameterSets | select -ExpandProperty Parameters |
? { $_.Name -like $_param } | ? { $_.ParameterType.IsEnum } |
% { [Enum]::GetNames($_.ParameterType) } | ? { $_ -like $_opt } | sort -Unique | % { $_base + $_ }

}




# parse the script...
$_tokens = [System.Management.Automation.PSParser]::Tokenize($line, [ref] $null)

if ($_tokens)
{
$_lastToken = $_tokens[$_tokens.count - 1]
if ($_lastToken.Type -eq 'Command')
{
$_cmd = $_lastToken.Content

# don't look for paths...
if ($_cmd.IndexOfAny('/\') -eq -1)
{
# handle parsing errors - the last token string should be the last
# string in the line...
if ($lastword.substring($lastword.length-$_cmd.length) -eq $_cmd)
{
$_pat = $_cmd + '*'
$_base = $lastword.substring(0, $lastword.length-$_cmd.length)
&quot;begin {&quot;, &quot;break&quot;, &quot;catch {&quot;, &quot;continue&quot;, &quot;data {&quot;, &quot;do {&quot;, &quot;dynamicparam (&quot;, &quot;else {&quot;, &quot;elseif (&quot;,
&quot;end {&quot;, &quot;exit&quot;, &quot;filter &quot;, &quot;finally {&quot;, &quot;for (&quot;, &quot;foreach &quot;, &quot;from&quot;, &quot;function &quot;, &quot;if (&quot;, &quot;in &quot;,
&quot;param (&quot;, &quot;process {&quot;, &quot;return&quot;, &quot;switch &quot;, &quot;throw &quot;, &quot;trap &quot;, &quot;try {&quot;, &quot;until (&quot;, &quot;while (&quot; `
-like $_pat | %  {'{0}{1}' -f $_base,$_ }
$ExecutionContext.InvokeCommand.GetCommandName($_pat,$true, $false) |
Sort-Object -Unique | ForEach-Object {'{0}{1}' -f $_base,$_ }
}
}
}
}
}
}
}
}

</code></pre>

</div>
			<!-- sidebar? -->
		</div>
		<hr>
		<footer class="blog-footer">
			<p>Generated by Joel &quot;Jaykul&quot; Bennett - 2018</p>
		</footer>
	</div> <!-- /container -->

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>
    <script src="/js/vendor/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>