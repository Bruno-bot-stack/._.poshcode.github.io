
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="PoshCode - Community resources for PowerShell coders">
    <meta name="author" content="foobar">
    <title>TabExpansion for V2CTP3 - PoshCode</title>

    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/main.css">
    <style>
        body {
            padding-top: 50px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
    <header>
    <nav class="navbar navbar-expand-sm fixed-top navbar-dark bg-dark">
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand" href="http://PoshCode.org/">PoshCode</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
            </div>
            <div id="navbarResponsive" class="collapse navbar-collapse navbar-responsive-collapse navbar-right">
                <ul class="nav navbar-nav nav-tabs ml-auto" data-tabs="tabs" id="tabs">
                    <li class="nav-item"><a class="nav-link active show" href="/scripts" data-toggle="tab">Scripts</a></li>
                    <li class="nav-item"><a class="nav-link" href="/video" data-toggle="tab">Video Feed</a></li>
                </ul>
            </div><!--/.navbar-collapse -->
        </div>
    </nav>
    </header>

    

<div class="blog-post">
    <h2 class="blog-post-title">TabExpansion for V2CTP3</h2>
    <p class="blog-post-meta">
        <span class="blog-post-time">2009-03-28</span> by <a class="blog-post-author">foobar</a>
    </p>

    <h1>TabExpansion for V2CTP3</h1>
<h3><a href="//scripts/978.ps1">download</a> - <a href="//scripts/913.md">parent</a></h3>
<p>Ported TabExpansion from V2CTP2 to V2CTP3 and extended. Please dot souce this script file to use.</p>
<pre><code class="language-posh">## Tab-Completion
#################
## For V2CTP3.
## This won't work on V1 and V2CTP and V2CTP2.
## Please dot souce this script file.
## In first loading, it may take a several minutes, in order to generate ProgIDs and TypeNames list.
## 
## What this can do is:
##
## [datetime]::n&lt;tab&gt;
## [datetime]::now.d&lt;tab&gt;
## $a = New-Object &quot;Int32[,]&quot; 2,3; $b = &quot;PowerShell&quot;,&quot;PowerShell&quot;
## $c = [ref]$a; $d = [ref]$b,$c
## $d[0].V&lt;tab&gt;[0][0].Get&lt;tab&gt;
## $d[1].V&lt;tab&gt;[0,0].tos&lt;tab&gt;
## $function:a&lt;tab&gt;
## $env:a&lt;tab&gt;
## [System.Type].a&lt;tab&gt;
## [datetime].Assembly.a&lt;tab&gt;
## ).a&lt;tab&gt; # shows System.Type properties and methods...

## #native command name expansion
## fsu&lt;tab&gt;

## #command option name expansion (for fsutil ipconfig net powershell only)
## fsutil &lt;tab&gt;
## ipconfig &lt;tab&gt;
## net &lt;tab&gt;
## powershell &lt;tab&gt;

## #TypeNames and Type accelerators expansion
## [Dec&lt;tab&gt;
## [system.Man&lt;tab&gt;.auto&lt;tab&gt;.p&lt;tab&gt;
## New-Object -TypeName IO.Dir&lt;tab&gt;
## New-Object System.win&lt;tab&gt;.for&lt;tab&gt;.bu&lt;tab&gt;

## #ProgIDs expansion
## New-Object -Com shel&lt;tab&gt;

## #Enum option expansion
## Set-ExecutionPolicy &lt;tab&gt;
## Set-ExecutionPolicy All&lt;tab&gt;
## Set-ExcusionPolisy -ex &lt;tab&gt;
## Get-TraceSource Inte&lt;tab&gt;
## iex -Errora &lt;tab&gt; -wa Sil&lt;tab&gt;

## #WmiClasses expansion
## Get-WmiObject -class Win32_&lt;tab&gt;
## gwmi __Instance&lt;tab&gt;

## #Encoding expansion
## [Out-File | Export-CSV | Select-String | Export-Clixml] -enc &lt;tab&gt;
## [Add-Content | Get-Content | Set-Content} -Encoding Big&lt;tab&gt;

## #PSProvider name expansion
## [Get-Location | Get-PSDrive | Get-PSProvider | New-PSDrive | Remove-PSDrive] -PSProvider &lt;tab&gt;
## Get-PSProvider &lt;tab&gt;
## pwd -psp al&lt;tab&gt;

## #PSDrive name expansion
## [Get-PSDrive | New-PSDrive | Remove-PSDrive] [-Name] &lt;tab&gt;
## Get-PSDrive &lt;tab&gt;
## pwd -psd &lt;tab&gt;

## #PSSnapin name expansion
## [Add-PSSnapin | Get-PSSnapin | Remove-PSSnapin ] [-Name] &lt;tab&gt;
## Get-Command -PSSnapin &lt;tab&gt;
## Remove-PSSnapin &lt;tab&gt;
## Get-PSSnapin M&lt;tab&gt;

## #Eventlog name and expansion
## Get-Eventlog -Log &lt;tab&gt;
## Get-Eventlog w&lt;tab&gt;

## #Eventlog's entrytype expansion
## Get-EventLog -EntryType &lt;tab&gt;
## Get-EventLog -EntryType Er&lt;tab&gt;
## Get-EventLog -Ent &lt;tab&gt;

## #Service name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-Name] &lt;tab&gt;
## New-Service -DependsOn &lt;tab&gt;
## New-Service -Dep e&lt;tab&gt;
## Get-Service -n &lt;tab&gt;
## Get-Service &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;
## gsv &lt;tab&gt;

## #Service display name expansion
## [Get-Service | Restart-Service | Resume-Service | Start-Service | Stop-Service | Suspend-Service] [-DisplayName] &lt;tab&gt;
## Get-Service -Dis &lt;tab&gt;
## gsv -Dis &lt;tab&gt;,w&lt;tab&gt;,b&lt;tab&gt;

## #Cmdlet and Topic name expansion (this also support default help function and man alias)
## Get-Help [-Name] about_&lt;tab&gt;
## Get-Help &lt;tab&gt;

## #Category name expansion (this also support default help function and man alias)
## Get-Help -Category c&lt;tab&gt;,&lt;tab&gt;

## #Command name expansion
## Get-Command [-Name] &lt;tab&gt;
## Get-Command -Name &lt;tab&gt;
## gcm a&lt;tab&gt;,&lt;tab&gt;

## #Scope expansion
## [Clear-Variable | Export-Alias | Get-Alias | Get-PSDrive | Get-Variable | Import-Alias
## New-Alias | New-PSDrive | New-Variable | Remove-Variable | Set-Alias | Set-Variable] -Scope &lt;tab&gt;
## Clear-Variable -Scope G&lt;tab&gt;
## Set-Alias  -s &lt;tab&gt;

## #Process name expansion
## [Get-Process | Stop-Process] [-Name] &lt;tab&gt;
## Stop-Process -Name &lt;tab&gt;
## Stop-Process -N pow&lt;tab&gt;
## Get-Process &lt;tab&gt;
## ps power&lt;tab&gt;

## #Trace sources expansion
## [Trace-Command | Get-TraceSource | Set-TraceSource] [-Name] &lt;tab&gt;,a&lt;tab&gt;,p&lt;tab&gt;

## #Trace -ListenerOption expansion
## [Set-TraceSource | Trace-Command] -ListenerOption &lt;tab&gt;
## Set-TraceSource -Lis &lt;tab&gt;,n&lt;tab&gt;

## #Trace -Option expansion
## [Set-TraceSource | Trace-Command] -Option &lt;tab&gt;
## Set-TraceSource -op &lt;tab&gt;,con&lt;tab&gt;

## #ItemType expansion
## New-Item -Item &lt;tab&gt;
## ni -ItemType d&lt;tab&gt;

## #ErrorAction and WarningAction option expansion
## CMDLET [-ErrorAction | -WarningAction] &lt;tab&gt;
## CMDLET -Errora s&lt;tab&gt;
## CMDLET -ea con&lt;tab&gt;
## CMDLET -wa &lt;tab&gt;

## #Continuous expansion with comma when parameter can treat multiple option
## # if there are spaces, occur display bug in the line
## # if strings contains '$' or '-', not work
## Get-Command -CommandType &lt;tab&gt;,&lt;tab&gt;&lt;tab&gt;,cm&lt;tab&gt;
## pwd -psp &lt;tab&gt;,f&lt;tab&gt;,va&lt;tab&gt;
## Get-EventLog -EntryType &lt;tab&gt;,i&lt;tab&gt;,s&lt;tab&gt;

## #Enum expansion in method call expression
## # this needs one or more spaces after left parenthesis or comma
## $str = &quot;day   night&quot;
## $str.Split( &quot; &quot;,&lt;space&gt;rem&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; ) &lt;Enter&gt; ERROR
## $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as&lt;space&gt;&lt;tab&gt;
## &gt;&gt;&gt; $str.Split( &quot; &quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions] ) &lt;Enter&gt; Success
## $type = [System.Type]
## $type.GetMembers(&lt;space&gt;Def&lt;tab&gt;
## [IO.Directory]::GetFiles( &quot;C:\&quot;, &quot;*&quot;,&lt;space&gt;All&lt;tab&gt;
## # this can do continuous enum expansion with comma and no spaces
## $type.GetMembers( &quot;IgnoreCase&lt;comma&gt;Dec&lt;tab&gt;&lt;comma&gt;In&lt;tab&gt;&quot;
## [IO.Directory]::GetAccessControl( &quot;C:\&quot;,&lt;space&gt;au&lt;tab&gt;&lt;comma&gt;ac&lt;tab&gt;&lt;comma&gt;G&lt;tab&gt;

## #Better '$_.' expansion when cmdlet output objects or method return objects
## ls |group { $_.Cr&lt;tab&gt;.Tost&lt;tab&gt;&quot;y&quot;)} | tee -var foo| ? { $_.G&lt;tab&gt;.c&lt;tab&gt; -gt 5 } | % { md $_.N&lt;tab&gt; ; copy $_.G&lt;tab&gt; $_.N&lt;tab&gt;  }
## [IO.DriveInfo]::GetDrives() | ? { $_.A&lt;tab&gt; -gt 1GB }
## $Host.UI.RawUI.GetBufferContents($rect) | % { $str += $_.c&lt;tab&gt; }
## gcm Add-Content |select -exp Par&lt;tab&gt;| select -ExpandProperty Par&lt;tab&gt; | ? { $_.Par&lt;tab&gt;.N&lt;tab&gt; -eq &quot;string&quot; }
## $data = Get-Process
## $data[2,4,5]  | % { $_.&lt;tab&gt;
## #when Get-PipeLineObject failed, '$_.' shows methods and properties name of FileInfo and String and Type

## #Property name expansion by -Property parameter
## [ Format-List | Format-Custom | Format-Table | Format-Wide | Compare-Object |
##  ConvertTo-Html | Measure-Object | Select-Object | Group-Object | Sort-Object ] [-Property] &lt;tab&gt;
## Select-Object -ExcludeProperty &lt;tab&gt;
## Select-Object -ExpandProperty &lt;tab&gt;
## gcm Get-Acl|select -exp Par&lt;tab&gt;
## ps |group na&lt;tab&gt;
## ls | ft A&lt;tab&gt;,M&lt;tab&gt;,L&lt;tab&gt;

## #Hashtable key expansion in the variable name and '.&lt;tab&gt;'
## Get-Process | Get-Unique | % { $hash += @{$_.ProcessName=$_} }
## $hash.pow&lt;tab&gt;.pro&lt;tab&gt;

## #Parameter expansion for function, filter and script
## man -f&lt;tab&gt;
## 'param([System.StringSplitOptions]$foo,[System.Management.Automation.ActionPreference]$bar,[System.Management.Automation.CommandTypes]$baz) {}' &gt; foobar.ps1
## .\foobar.ps1 -&lt;tab&gt; -b&lt;tab&gt;

## #Enum expansion for function, filter and scripts
## # this can do continuous enum expansion with comma and no spaces
## .\foobar.ps1 -foo rem&lt;tab&gt; -bar &lt;tab&gt;&lt;comma&gt;c&lt;tab&gt;&lt;comma&gt;sc&lt;tab&gt; -ea silent&lt;tab&gt; -wa con&lt;tab&gt;

## #Enum expansion for assignment expression
## #needs space(s) after '=' and comma
## #strongly-typed with -as operator and space(s)
## $ErrorActionPreference =&lt;space&gt;&lt;tab&gt;
## $cmdtypes = New-Object System.Management.Automation.CommandTypes[] 3
## $cmdtypes =&lt;space&gt;&lt;tab&gt;&lt;comma&gt;&lt;space&gt;func&lt;tab&gt;&lt;comma&gt;&lt;space&gt;cmd&lt;tab&gt; -as&lt;space&gt;&lt;tab&gt;

## #Path expansion with variable and '\' or '/'
## $PWD\../../&lt;tab&gt;\&lt;tab&gt;
## &quot;$env:SystemDrive/pro&lt;tab&gt;/&lt;tab&gt;

## #Operator expansion which starts with '-'
## &quot;Power&quot;,&quot;Shell&quot; -m&lt;tab&gt; &quot;Power&quot; -r&lt;tab&gt; '(Pow)(er)','$1d$2'
## 1..9 -co&lt;tab&gt; 5

## #Keyword expansion
## fu&lt;tab&gt; test { p&lt;tab&gt; $foo, $bar ) b&lt;tab&gt; &quot;foo&quot; } pr&lt;tab&gt; $_ } en&lt;tab&gt; &quot;$bar&quot; } }

## #Variable name expansion (only global scope)
## [Clear-Variable | Get-Variable | New-Variable | Remove-Variable | Set-Variable] [-Name] &lt;tab&gt;
## [Cmdlet | Function | Filter | ExternalScript] -ErrorVariable &lt;tab&gt;
## [Cmdlet | Function | Filter | ExternalScript] -OutVariable &lt;tab&gt;
## Tee-Object -Variable &lt;tab&gt;
##  gv pro&lt;tab&gt;,&lt;tab&gt;
##  Remove-Variable -Name out&lt;tab&gt;,&lt;tab&gt;,ps&lt;tab&gt;
##  ... | ... | tee -v &lt;tab&gt;

## #Alias name expansion
## [Get-Alias | New-Alias | Set-Alias] [-Name] &lt;tab&gt;
## Export-Alias -Name &lt;tab&gt;
##  Get-Alias i&lt;tab&gt;,e&lt;tab&gt;,a&lt;tab&gt;
##  epal -n for&lt;tab&gt;

## #Property name expansion with -groupBy parameter
## [Format-List | Format-Custom | Format-Table | Format-Wide] -groupBy &lt;tab&gt;
##  ps | ft -g &lt;tab&gt;
##  gcm | Format-Wide -GroupBy Par&lt;tab&gt;

## #Type accelerators expansion with no charactors
##  [&lt;tab&gt;
##  New-Object -typename &lt;tab&gt;
##  New-Object &lt;tab&gt;

## # File glob expansion with '@'
##  ls *.txt@&lt;tab&gt;
##  ls file.txt, foo1.txt, 'bar``[1``].txt', 'foo bar .txt'	# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter *.txt						# 2 &lt;tab&gt; refactoring 
##  ls *.txt							# 3 &lt;tab&gt; (or 1 &lt;tab&gt; &amp; 1 &lt;shift&gt;+&lt;tab&gt;) return original glob pattern

## This can also use '^'(hat) or '~'(tilde) for Excluding
##  ls &lt;hat&gt;*.txt@&lt;tab&gt;
##  ls foo.ps1, 'bar``[1``].xml'		# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter * -Excluding *.txt		# 2 &lt;tab&gt; refactoring 
##  *.txt&lt;tilde&gt;foo*&lt;tilde&gt;bar*@&lt;tab&gt;
##  ls file.txt					# 1 &lt;tab&gt; expanding with comma
##  ls * -Filter *.txt -Excluding foo*, bar*	# 2 &lt;tab&gt; refactoring 

## # Ported history expansion from V2CTP3 TabExpansion with '#' ( #&lt;pattern&gt; or #&lt;id&gt; )
##  ls * -Filter * -Excluding foo*, bar*&lt;Enter&gt;
##  #ls&lt;tab&gt;
##  #1&lt;tab&gt;

## # Command buffer stack with ';'(semicolon)
##  ls * -Filter * -Excluding foo*, bar*&lt;semicolon&gt;&lt;tab&gt; # push command1
##  echo &quot;PowerShell&quot;&lt;semicolon&gt;&lt;tab&gt; # push command2
##  get-process&lt;semicolon&gt;&lt;tab&gt; # push command3
##  {COMMAND}&lt;Enter&gt; # execute another command 
##  get-process # Auto pop command3 from stack by LIFO
## This can also hand-operated pop with ';,'(semicolon&amp;comma) or ';:'(semicolon&amp;colon)
##  get-process; &lt;semicolon&gt;&lt;comma&gt;&lt;tab&gt;
##  get-process; echo &quot;PowerShell&quot; # pop command2 from stack by LIFO

## # Function name expansion after 'function' or 'filter' keywords
## function cl&lt;tab&gt;

## #Switch syntax option expansion
##  switch -w&lt;tab&gt; -f&lt;tab&gt;

## #Better powershell.exe option expansion with '-'
##  powershell -no&lt;tab&gt; -&lt;tab&gt; -en&lt;tab&gt;

## #A part of PowerShell attributes expansion ( CmdletBinding, Parameter, Alias, Validate*, Allow* )
##  [par&lt;tab&gt;
##  [cmd&lt;tab&gt;

## #Member expansion for CmdletBinding and Parameter attributes
##  [Parameter(man&lt;tab&gt;,&lt;tab&gt;1,val&lt;tab&gt;$true)]
##  [CmdletBinding( &lt;tab&gt;&quot;foo&quot;, su&lt;tab&gt;$true)]

## #Several current date/time formats with Ctrl+D
##  &lt;Ctrl+D&gt;&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;&lt;tab&gt;...

## #Hand-operated pop from command buffer with Ctrl+P (this is also available with ';:' or ';,')
##  &lt;command&gt;;&lt;tab&gt; # push command
##  &lt;Ctrl+D&gt;&lt;tab&gt; # pop

## #Paste clipboard with Ctrl+V
##  &lt;Ctrl+V&gt;&lt;tab&gt;

## # Cut current line with Ctrl+X
##  &lt;command&gt;&lt;Ctrl+X&gt;&lt;tab&gt;

## # Cut words with a charactor after Ctrl+X until the charactor
## 1: PS &gt; dir -Filter *.txt&lt;Ctrl+X&gt;-&lt;tab&gt; # Cut words until '-'
## 2: PS &gt; dir -
## 3: PS &gt; dir -&lt;Ctrl+V&gt;&lt;tab&gt; # Paste words that were copyed now

## # Cut last word in current line with Ctrl+Z
## 1: PS &gt;  Get-ChildItem *.txt&lt;Ctrl+Z&gt;&lt;tab&gt; # Cut last word in current line
## 2: PS &gt;  Get-ChildItem 
## 3: PS &gt;  Get-ChildItem -Exclude &lt;Ctrl+V&gt;&lt;tab&gt; # Paste last word that was copyed now


### Generate ProgIDs list...
if ( Test-Path $PSHOME\ProgIDs.txt )
{
$_ProgID = type $PSHOME\ProgIDs.txt -ReadCount 0
}
else
{
$_HKCR = [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\&quot;)
$_ProgID = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
foreach ( $_subkey in $_HKCR.GetSubKeyNames() )
{
foreach ( $_i in [Microsoft.Win32.Registry]::ClassesRoot.OpenSubKey(&quot;CLSID\$_subkey\ProgID&quot;) )
{
if ($_i -ne $null)
{
$_ProgID.Add($_i.GetValue(&quot;&quot;))
}
}
}
'$_ProgID was updated...' | Out-Host
$_ProgID = $_ProgID|sort -Unique

Set-Content -Value $_ProgID -Path $PSHOME\ProgIDs.txt -Verbose
}

### Generate TypeNames list...

if ( Test-Path $PSHOME\TypeNames.txt )
{
$_TypeNames = type $PSHOME\TypeNames.txt -ReadCount 0
}
else
{
$_TypeNames = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
foreach ( $_asm in [AppDomain]::CurrentDomain.GetAssemblies() )
{
foreach ( $_type in $_asm.GetTypes() )
{
$_TypeNames.Add($_type.FullName)
}
}
'$_TypeNames was updated...' | Out-Host
$_TypeNames = $_TypeNames | sort -Unique

Set-Content -Value $_TypeNames -Path $PSHOME\TypeNames.txt -Verbose
}

if ( Test-Path $PSHOME\TypeNames_System.txt )
{
$_TypeNames_System = type $PSHOME\TypeNames_System.txt -ReadCount 0
}
else
{
$_TypeNames_System = $_TypeNames -like &quot;System.*&quot; -replace '^System\.'
'$_TypeNames_System was updated...' | Out-Host
Set-Content -Value $_TypeNames_System -Path $PSHOME\TypeNames_System.txt -Verbose
}

### Generate WMIClasses list...
if ( Test-Path $PSHOME\WMIClasses.txt )
{
$_WMIClasses = type $PSHOME\WMIClasses.txt -ReadCount 0
}
else
{
$_WMIClasses = New-Object ( [System.Collections.Generic.List``1].MakeGenericType([String]) )
foreach ( $_class in gwmi -List )
{
$_WMIClasses.Add($_class.Name)
}
$_WMIClasses = $_WMIClasses | sort -Unique
'$_WMIClasses was updated...' | Out-Host
Set-Content -Value $_WMIClasses -Path $PSHOME\WMIClasses.txt -Verbose
}

[Reflection.Assembly]::LoadWithPartialName( &quot;System.Windows.Forms&quot; ) | Out-Null
$global:_cmdstack = New-Object Collections.Stack
$global:_snapin = $null
$global:_TypeAccelerators = [type]::gettype(&quot;System.Management.Automation.TypeAccelerators&quot;)::get.keys | sort

iex (@'
function prompt {
if ($_cmdstack.Count -gt 0) {
$line = $global:_cmdstack.Pop() -replace '([[\]\(\)+{}?~%])','{$1}'
[System.Windows.Forms.SendKeys]::SendWait($line)
}
'@ + @&quot;
${function:prompt}
}
&quot;@)

function Write-ClassNames ( $data, $i, $prefix='', $sep='.' )
{
$preItem = &quot;&quot;
foreach ( $class in $data -like $_opt )
{
$Item = $class.Split($sep)
if ( $preItem -ne $Item[$i] )
{
if ( $i+1 -eq $Item.Count )
{
if ( $prefix -eq &quot;[&quot; )
{
$suffix = &quot;]&quot;
}
elseif ( $sep -eq &quot;_&quot; )
{
$suffix = &quot;&quot;
}
else
{
$suffix = &quot; &quot;
}
}
else
{
$suffix = &quot;&quot;
}
$prefix + $_opt.Substring(0, $_opt.LastIndexOf($sep)+1) + $Item[$i] + $suffix

$preItem = $Item[$i]
}
}
}

function Get-PipeLineObject {

$i = -2
$property = $null
do {
$str = $line.Split(&quot;|&quot;)
# extract the command name from the string
# first split the string into statements and pipeline elements
# This doesn't handle strings however.
$_cmdlet = [regex]::Split($str[$i], '[|;=]')[-1]

# take the first space separated token of the remaining string
# as the command to look up. Trim any leading or trailing spaces
# so you don't get leading empty elements.
$_cmdlet = $_cmdlet.Trim().Split()[0]

if ( $_cmdlet -eq &quot;?&quot; )
{
$_cmdlet = &quot;Where-Object&quot;
}

$global:_exp = $_cmdlet

# now get the info object for it...
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet)[0]

# loop resolving aliases...
while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'cmdlet,alias' $_cmdlet.Definition)[0]
}

if ( &quot;Select-Object&quot; -eq $_cmdlet )
{
if ( $str[$i] -match '\s+-Exp\w*[\s:]+(\w+)' )
{
$property = $Matches[1] + &quot;;&quot; + $property
}
}

$i--
} while ( &quot;Get-Unique&quot;, &quot;Select-Object&quot;, &quot;Sort-Object&quot;, &quot;Tee-Object&quot;, &quot;Where-Object&quot; -contains $_cmdlet )

if ( $global:_forgci -eq $null )
{
$a = @(ls &quot;Alias:\&quot;)[0]
$e = @(ls &quot;Env:\&quot;)[0]
$f = @(ls &quot;Function:\&quot;)[0]
$h = @(ls &quot;HKCU:\&quot;)[0]
$v = @(ls &quot;Variable:\&quot;)[0]
$c = @(ls &quot;cert:\&quot;)[0]
$global:_forgci = gi $PSHOME\powershell.exe |
Add-Member  'NoteProperty'  CommandType  $f.CommandType -P |
Add-Member  'NoteProperty'  Definition  $a.Definition -P |
Add-Member  'NoteProperty'  Description  $a.Description -P |
Add-Member  'NoteProperty'  Key  $e.Key -P |
Add-Member  'NoteProperty'  Location  $c.Location -P |
Add-Member  'NoteProperty'  LocationName  $c.LocationName -P |
Add-Member  'NoteProperty'  Options  $a.Options -P |
Add-Member  'NoteProperty'  ReferencedCommand  $a.ReferencedCommand -P |
Add-Member  'NoteProperty'  ResolvedCommand  $a.ResolvedCommand -P |
Add-Member  'NoteProperty'  ScriptBlock  $f.ScriptBlock -P |
Add-Member  'NoteProperty'  StoreNames  $c.StoreNames -P |
Add-Member  'NoteProperty'  SubKeyCount  $h.SubKeyCount -P |
Add-Member  'NoteProperty'  Value  $e.Value -P |
Add-Member  'NoteProperty'  ValueCount  $h.ValueCount -P |
Add-Member  'NoteProperty'  Visibility  $a.Visibility -P |
Add-Member  'NoteProperty'  Property  $h.Property -P |
Add-Member  'NoteProperty'  ResolvedCommandName  $a.ResolvedCommandName -P |
Add-Member  'ScriptMethod'  Close  {} -P |
Add-Member  'ScriptMethod'  CreateSubKey  {} -P |
Add-Member  'ScriptMethod'  DeleteSubKey  {} -P |
Add-Member  'ScriptMethod'  DeleteSubKeyTree  {} -P |
Add-Member  'ScriptMethod'  DeleteValue  {} -P |
Add-Member  'ScriptMethod'  Flush  {} -P |
Add-Member  'ScriptMethod'  GetSubKeyNames  {} -P |
Add-Member  'ScriptMethod'  GetValue  {} -P |
Add-Member  'ScriptMethod'  GetValueKind  {} -P |
Add-Member  'ScriptMethod'  GetValueNames  {} -P |
Add-Member  'ScriptMethod'  IsValidValue  {} -P |
Add-Member  'ScriptMethod'  OpenSubKey  {} -P |
Add-Member  'ScriptMethod'  SetValue  {} -P
}

if ( $global:_mix -eq $null )
{
$f = gi $PSHOME\powershell.exe
$t = [type]
$s = &quot;&quot;
$global:_mix = `
Add-Member -InputObject (New-Object PSObject)  'NoteProperty'  Mode  $f.Mode -P |
Add-Member  'NoteProperty'  Assembly  $t.Assembly -P |
Add-Member  'NoteProperty'  AssemblyQualifiedName  $t.AssemblyQualifiedName -P |
Add-Member  'NoteProperty'  Attributes  $f.Attributes -P |
Add-Member  'NoteProperty'  BaseType  $t.BaseType -P |
Add-Member  'NoteProperty'  ContainsGenericParameters  $t.ContainsGenericParameters -P |
Add-Member  'NoteProperty'  CreationTime  $f.CreationTime -P |
Add-Member  'NoteProperty'  CreationTimeUtc  $f.CreationTimeUtc -P |
Add-Member  'NoteProperty'  DeclaringMethod  $t.DeclaringMethod -P |
Add-Member  'NoteProperty'  DeclaringType  $t.DeclaringType -P |
Add-Member  'NoteProperty'  Exists  $f.Exists -P |
Add-Member  'NoteProperty'  Extension  $f.Extension -P |
Add-Member  'NoteProperty'  FullName  $f.FullName -P |
Add-Member  'NoteProperty'  GenericParameterAttributes  $t.GenericParameterAttributes -P |
Add-Member  'NoteProperty'  GenericParameterPosition  $t.GenericParameterPosition -P |
Add-Member  'NoteProperty'  GUID  $t.GUID -P |
Add-Member  'NoteProperty'  HasElementType  $t.HasElementType -P |
Add-Member  'NoteProperty'  IsAbstract  $t.IsAbstract -P |
Add-Member  'NoteProperty'  IsAnsiClass  $t.IsAnsiClass -P |
Add-Member  'NoteProperty'  IsArray  $t.IsArray -P |
Add-Member  'NoteProperty'  IsAutoClass  $t.IsAutoClass -P |
Add-Member  'NoteProperty'  IsAutoLayout  $t.IsAutoLayout -P |
Add-Member  'NoteProperty'  IsByRef  $t.IsByRef -P |
Add-Member  'NoteProperty'  IsClass  $t.IsClass -P |
Add-Member  'NoteProperty'  IsCOMObject  $t.IsCOMObject -P |
Add-Member  'NoteProperty'  IsContextful  $t.IsContextful -P |
Add-Member  'NoteProperty'  IsEnum  $t.IsEnum -P |
Add-Member  'NoteProperty'  IsExplicitLayout  $t.IsExplicitLayout -P |
Add-Member  'NoteProperty'  IsGenericParameter  $t.IsGenericParameter -P |
Add-Member  'NoteProperty'  IsGenericType  $t.IsGenericType -P |
Add-Member  'NoteProperty'  IsGenericTypeDefinition  $t.IsGenericTypeDefinition -P |
Add-Member  'NoteProperty'  IsImport  $t.IsImport -P |
Add-Member  'NoteProperty'  IsInterface  $t.IsInterface -P |
Add-Member  'NoteProperty'  IsLayoutSequential  $t.IsLayoutSequential -P |
Add-Member  'NoteProperty'  IsMarshalByRef  $t.IsMarshalByRef -P |
Add-Member  'NoteProperty'  IsNested  $t.IsNested -P |
Add-Member  'NoteProperty'  IsNestedAssembly  $t.IsNestedAssembly -P |
Add-Member  'NoteProperty'  IsNestedFamANDAssem  $t.IsNestedFamANDAssem -P |
Add-Member  'NoteProperty'  IsNestedFamily  $t.IsNestedFamily -P |
Add-Member  'NoteProperty'  IsNestedFamORAssem  $t.IsNestedFamORAssem -P |
Add-Member  'NoteProperty'  IsNestedPrivate  $t.IsNestedPrivate -P |
Add-Member  'NoteProperty'  IsNestedPublic  $t.IsNestedPublic -P |
Add-Member  'NoteProperty'  IsNotPublic  $t.IsNotPublic -P |
Add-Member  'NoteProperty'  IsPointer  $t.IsPointer -P |
Add-Member  'NoteProperty'  IsPrimitive  $t.IsPrimitive -P |
Add-Member  'NoteProperty'  IsPublic  $t.IsPublic -P |
Add-Member  'NoteProperty'  IsSealed  $t.IsSealed -P |
Add-Member  'NoteProperty'  IsSerializable  $t.IsSerializable -P |
Add-Member  'NoteProperty'  IsSpecialName  $t.IsSpecialName -P |
Add-Member  'NoteProperty'  IsUnicodeClass  $t.IsUnicodeClass -P |
Add-Member  'NoteProperty'  IsValueType  $t.IsValueType -P |
Add-Member  'NoteProperty'  IsVisible  $t.IsVisible -P |
Add-Member  'NoteProperty'  LastAccessTime  $f.LastAccessTime -P |
Add-Member  'NoteProperty'  LastAccessTimeUtc  $f.LastAccessTimeUtc -P |
Add-Member  'NoteProperty'  LastWriteTime  $f.LastWriteTime -P |
Add-Member  'NoteProperty'  LastWriteTimeUtc  $f.LastWriteTimeUtc -P |
Add-Member  'NoteProperty'  MemberType  $t.MemberType -P |
Add-Member  'NoteProperty'  MetadataToken  $t.MetadataToken -P |
Add-Member  'NoteProperty'  Module  $t.Module -P |
Add-Member  'NoteProperty'  Name  $t.Name -P |
Add-Member  'NoteProperty'  Namespace  $t.Namespace -P |
Add-Member  'NoteProperty'  Parent  $f.Parent -P |
Add-Member  'NoteProperty'  ReflectedType  $t.ReflectedType -P |
Add-Member  'NoteProperty'  Root  $f.Root -P |
Add-Member  'NoteProperty'  StructLayoutAttribute  $t.StructLayoutAttribute -P |
Add-Member  'NoteProperty'  TypeHandle  $t.TypeHandle -P |
Add-Member  'NoteProperty'  TypeInitializer  $t.TypeInitializer -P |
Add-Member  'NoteProperty'  UnderlyingSystemType  $t.UnderlyingSystemType -P |
Add-Member  'NoteProperty'  PSChildName  $f.PSChildName -P |
Add-Member  'NoteProperty'  PSDrive  $f.PSDrive -P |
Add-Member  'NoteProperty'  PSIsContainer  $f.PSIsContainer -P |
Add-Member  'NoteProperty'  PSParentPath  $f.PSParentPath -P |
Add-Member  'NoteProperty'  PSPath  $f.PSPath -P |
Add-Member  'NoteProperty'  PSProvider  $f.PSProvider -P |
Add-Member  'NoteProperty'  BaseName  $f.BaseName -P |
Add-Member  'ScriptMethod'  Clone  {} -P |
Add-Member  'ScriptMethod'  CompareTo  {} -P |
Add-Member  'ScriptMethod'  Contains  {} -P |
Add-Member  'ScriptMethod'  CopyTo  {} -P |
Add-Member  'ScriptMethod'  Create  {} -P |
Add-Member  'ScriptMethod'  CreateObjRef  {} -P |
Add-Member  'ScriptMethod'  CreateSubdirectory  {} -P |
Add-Member  'ScriptMethod'  Delete  {} -P |
Add-Member  'ScriptMethod'  EndsWith  {} -P |
Add-Member  'ScriptMethod'  FindInterfaces  {} -P |
Add-Member  'ScriptMethod'  FindMembers  {} -P |
Add-Member  'ScriptMethod'  GetAccessControl  {} -P |
Add-Member  'ScriptMethod'  GetArrayRank  {} -P |
Add-Member  'ScriptMethod'  GetConstructor  {} -P |
Add-Member  'ScriptMethod'  GetConstructors  {} -P |
Add-Member  'ScriptMethod'  GetCustomAttributes  {} -P |
Add-Member  'ScriptMethod'  GetDefaultMembers  {} -P |
Add-Member  'ScriptMethod'  GetDirectories  {} -P |
Add-Member  'ScriptMethod'  GetElementType  {} -P |
Add-Member  'ScriptMethod'  GetEnumerator  {} -P |
Add-Member  'ScriptMethod'  GetEvent  {} -P |
Add-Member  'ScriptMethod'  GetEvents  {} -P |
Add-Member  'ScriptMethod'  GetField  {} -P |
Add-Member  'ScriptMethod'  GetFields  {} -P |
Add-Member  'ScriptMethod'  GetFiles  {} -P |
Add-Member  'ScriptMethod'  GetFileSystemInfos  {} -P |
Add-Member  'ScriptMethod'  GetGenericArguments  {} -P |
Add-Member  'ScriptMethod'  GetGenericParameterConstraints  {} -P |
Add-Member  'ScriptMethod'  GetGenericTypeDefinition  {} -P |
Add-Member  'ScriptMethod'  GetInterface  {} -P |
Add-Member  'ScriptMethod'  GetInterfaceMap  {} -P |
Add-Member  'ScriptMethod'  GetInterfaces  {} -P |
Add-Member  'ScriptMethod'  GetLifetimeService  {} -P |
Add-Member  'ScriptMethod'  GetMember  {} -P |
Add-Member  'ScriptMethod'  GetMembers  {} -P |
Add-Member  'ScriptMethod'  GetMethod  {} -P |
Add-Member  'ScriptMethod'  GetMethods  {} -P |
Add-Member  'ScriptMethod'  GetNestedType  {} -P |
Add-Member  'ScriptMethod'  GetNestedTypes  {} -P |
Add-Member  'ScriptMethod'  GetObjectData  {} -P |
Add-Member  'ScriptMethod'  GetProperties  {} -P |
Add-Member  'ScriptMethod'  GetProperty  {} -P |
Add-Member  'ScriptMethod'  GetTypeCode  {} -P |
Add-Member  'ScriptMethod'  IndexOf  {} -P |
Add-Member  'ScriptMethod'  IndexOfAny  {} -P |
Add-Member  'ScriptMethod'  InitializeLifetimeService  {} -P |
Add-Member  'ScriptMethod'  Insert  {} -P |
Add-Member  'ScriptMethod'  InvokeMember  {} -P |
Add-Member  'ScriptMethod'  IsAssignableFrom  {} -P |
Add-Member  'ScriptMethod'  IsDefined  {} -P |
Add-Member  'ScriptMethod'  IsInstanceOfType  {} -P |
Add-Member  'ScriptMethod'  IsNormalized  {} -P |
Add-Member  'ScriptMethod'  IsSubclassOf  {} -P |
Add-Member  'ScriptMethod'  LastIndexOf  {} -P |
Add-Member  'ScriptMethod'  LastIndexOfAny  {} -P |
Add-Member  'ScriptMethod'  MakeArrayType  {} -P |
Add-Member  'ScriptMethod'  MakeByRefType  {} -P |
Add-Member  'ScriptMethod'  MakeGenericType  {} -P |
Add-Member  'ScriptMethod'  MakePointerType  {} -P |
Add-Member  'ScriptMethod'  MoveTo  {} -P |
Add-Member  'ScriptMethod'  Normalize  {} -P |
Add-Member  'ScriptMethod'  PadLeft  {} -P |
Add-Member  'ScriptMethod'  PadRight  {} -P |
Add-Member  'ScriptMethod'  Refresh  {} -P |
Add-Member  'ScriptMethod'  Remove  {} -P |
Add-Member  'ScriptMethod'  Replace  {} -P |
Add-Member  'ScriptMethod'  SetAccessControl  {} -P |
Add-Member  'ScriptMethod'  Split  {} -P |
Add-Member  'ScriptMethod'  StartsWith  {} -P |
Add-Member  'ScriptMethod'  Substring  {} -P |
Add-Member  'ScriptMethod'  ToCharArray  {} -P |
Add-Member  'ScriptMethod'  ToLower  {} -P |
Add-Member  'ScriptMethod'  ToLowerInvariant  {} -P |
Add-Member  'ScriptMethod'  ToUpper  {} -P |
Add-Member  'ScriptMethod'  ToUpperInvariant  {} -P |
Add-Member  'ScriptMethod'  Trim  {} -P |
Add-Member  'ScriptMethod'  TrimEnd  {} -P |
Add-Member  'ScriptMethod'  TrimStart  {} -P |
Add-Member  'NoteProperty'  Chars  $s.Chars -P
}


if ( &quot;Add-Member&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Compare-Object&quot; -eq $_cmdlet )
{
$global:_dummy =  (Compare-Object 1 2)[0]
}


if ( &quot;ConvertFrom-SecureString&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;ConvertTo-SecureString&quot; -eq $_cmdlet )
{
$global:_dummy = convertto-securestring &quot;P@ssW0rD!&quot; -asplaintext -force
}


if ( &quot;ForEach-Object&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Acl&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Acl
}


if ( &quot;Get-Alias&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Alias)[0]
}


if ( &quot;Get-AuthenticodeSignature&quot; -eq $_cmdlet )
{
$global:_dummy = Get-AuthenticodeSignature $PSHOME\powershell.exe
}


if ( &quot;Get-ChildItem&quot; -eq $_cmdlet )
{
$global:_dummy = $global:_forgci
}


if ( &quot;Get-Command&quot; -eq $_cmdlet )
{
$global:_dummy = @(iex $str[$i+1])[0]
}


if ( &quot;Get-Content&quot; -eq $_cmdlet )
{
$global:_dummy = (type $PSHOME\profile.ps1)[0]
}


if ( &quot;Get-Credential&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Culture&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Culture
}


if ( &quot;Get-Date&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Date
}


if ( &quot;Get-Event&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Event)[0]
}


if ( &quot;Get-EventLog&quot; -eq $_cmdlet )
{
$global:_dummy = @(iex $str[$i+1])[0]
}


if ( &quot;Get-ExecutionPolicy&quot; -eq $_cmdlet )
{
$global:_dummy = Get-ExecutionPolicy
}


if ( &quot;Get-Help&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Help Add-Content
}


if ( &quot;Get-History&quot; -eq $_cmdlet )
{
$global:_dummy = Get-History -Count 1
}


if ( &quot;Get-Host&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Host
}


if ( &quot;Get-Item&quot; -eq $_cmdlet )
{
$global:_dummy = $global:_forgci
}


if ( &quot;Get-ItemProperty&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Location&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Location
}


if ( &quot;Get-Member&quot; -eq $_cmdlet )
{
$global:_dummy = (1|Get-Member)[0]
}


if ( &quot;Get-Module&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Module)[0]
}


if ( &quot;Get-PfxCertificate&quot; -eq $_cmdlet )
{
$global:_dummy = $null
}


if ( &quot;Get-Process&quot; -eq $_cmdlet )
{
$global:_dummy = ps powershell
}


if ( &quot;Get-PSBreakpoint&quot; -eq $_cmdlet )
{
$global:_dummy =
Add-Member -InputObject (New-Object PSObject)  'NoteProperty'  Action  '' -P |
Add-Member  'NoteProperty'  Command  '' -P |
Add-Member  'NoteProperty'  Enabled  '' -P |
Add-Member  'NoteProperty'  HitCount  '' -P |
Add-Member  'NoteProperty'  Id  '' -P |
Add-Member  'NoteProperty'  Script  '' -P
}


if ( &quot;Get-PSCallStack&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSCallStack
}


if ( &quot;Get-PSDrive&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSDrive Function
}


if ( &quot;Get-PSProvider&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSProvider FileSystem
}


if ( &quot;Get-PSSnapin&quot; -eq $_cmdlet )
{
$global:_dummy = Get-PSSnapin Microsoft.PowerShell.Core
}


if ( &quot;Get-Service&quot; -eq $_cmdlet )
{
$global:_dummy = (Get-Service)[0]
}


if ( &quot;Get-TraceSource&quot; -eq $_cmdlet )
{
$global:_dummy = Get-TraceSource AddMember
}


if ( &quot;Get-UICulture&quot; -eq $_cmdlet )
{
$global:_dummy = Get-UICulture
}


if ( &quot;Get-Variable&quot; -eq $_cmdlet )
{
$global:_dummy = Get-Variable _
}


if ( &quot;Get-WmiObject&quot; -eq $_cmdlet )
{
$global:_dummy = @(iex $str[$i+1])[0]
}


if ( &quot;Group-Object&quot; -eq $_cmdlet )
{
$global:_dummy = 1 | group
}


if ( &quot;Measure-Command&quot; -eq $_cmdlet )
{
$global:_dummy = Measure-Command {}
}


if ( &quot;Measure-Object&quot; -eq $_cmdlet )
{
$global:_dummy = Measure-Object
}


if ( &quot;New-PSDrive&quot; -eq $_cmdlet )
{
$global:_dummy =  Get-PSDrive Alias
}


if ( &quot;New-TimeSpan&quot; -eq $_cmdlet )
{
$global:_dummy = New-TimeSpan
}


if ( &quot;Resolve-Path&quot; -eq $_cmdlet )
{
$global:_dummy = $PWD
}


if ( &quot;Select-String&quot; -eq $_cmdlet )
{
$global:_dummy = &quot; &quot; | Select-String &quot; &quot;
}


if ( &quot;Set-Date&quot; -eq $_cmdlet )
{
$global:_dummy =  Get-Date
}

if ( $property -ne $null)
{
foreach ( $name in $property.Split(&quot;;&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) )
{
$global:_dummy = @($global:_dummy.$name)[0]
}
}
}


function TabExpansion {
# This is the default function to use for tab expansion. It handles simple
# member expansion on variables, variable name expansion and parameter completion
# on commands. It doesn't understand strings so strings containing ; | ( or { may
# cause expansion to fail.

param($line, $lastWord)

&amp; {
# Helper function to write out the matching set of members. It depends
# on dynamic scoping to get $_base, _$expression and $_pat
function Write-Members ($sep='.')
{
# evaluate the expression to get the object to examine...
Invoke-Expression ('$_val=' + $_expression)

if ( $_expression -match '^\$global:_dummy' )
{
$temp = $_expression -replace '^\$global:_dummy(.*)','$1'
$_expression = '$_' + $temp
}

$_method = [Management.Automation.PSMemberTypes] `
'Method,CodeMethod,ScriptMethod,ParameterizedProperty'
if ($sep -eq '.')
{
$params = @{view = 'extended','adapted','base'}
}
else
{
$params = @{static=$true}
}

if ( $_val -is [Hashtable] )
{
[Object[]]$_keys = $null
foreach ( $_name in $_val.Keys )
{
$_keys += `
New-Object Microsoft.PowerShell.Commands.MemberDefinition `
[int],$_name,&quot;Property&quot;,0
}
}

if ( $_keys -ne $null )
{
$_members = [Object[]](Get-Member @params -InputObject $_val $_pat) + ($_keys | ? {$_.name -like $_pat})
} else {
$_members = (Get-Member @params -InputObject $_val $_pat)
}

foreach ($_m in $_members | Sort-Object membertype,name)
{
if ($_m.MemberType -band $_method)
{
# Return a method...
$_base + $_expression + $sep + $_m.name + '('
}
else {
# Return a property...
$_base + $_expression + $sep + $_m.name
}
}
}

switch ([int]$line[-1])
{
# Ctrl+D several date/time formats
4 {
&quot;[DateTime]::Now&quot;
[DateTime]::Now
[DateTime]::Now.ToString(&quot;yyyyMMdd&quot;)
[DateTime]::Now.ToString(&quot;MMddyyyy&quot;)
[DateTime]::Now.ToString(&quot;yyyyMMddHHmmss&quot;)
[DateTime]::Now.ToString(&quot;MMddyyyyHHmmss&quot;)
'd f g m o r t u y'.Split(&quot; &quot;) | % { [DateTime]::Now.ToString($_) }
break;
}

# Ctrl+P hand-operated pop from command buffer stack
16 {
$_base = $lastword.SubString(0, $lastword.Length-1)
$_base + $global:_cmdstack.Pop()
break;
}

# Ctrl+R $Host.UI.RawUI.
18 {
'$Host.UI.RawUI.'
'$Host.UI.RawUI'
break;
}

# Ctrl+V paste clipboard
22 {
$_base = $lastword.SubString(0, $lastword.Length-1)
$_clip = New-Object System.Windows.Forms.TextBox
$_clip.Multiline = $true
$_clip.Paste()
$_base + $_clip.Text
break;
}

# Ctrl+X cut current line
24 {
$_clip = new-object System.Windows.Forms.TextBox;
$_clip.Multiline = $true;
$_clip.Text = $line.SubString(0, $line.Length-1)
$_clip.SelectAll()
$_clip.Copy()
[System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
break;
}

# Ctrl+Z cut last word in current line
26 {
$line.SubString(0, $line.Length-1) -match '(^(.*\s)([^\s]*)$)|(^[^\s]*$)' | Out-Null
$_clip = new-object System.Windows.Forms.TextBox;
$_clip.Multiline = $true;
$_clip.Text = $Matches[3]
$_clip.SelectAll()
$_clip.Copy()
[System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
$line = $Matches[2] -replace '([[\]\(\)+{}?~%])','{$1}'
[System.Windows.Forms.SendKeys]::SendWait($line)
break;
}
}

switch ( [int]$line[-2] )
{
# Ctrl+X cut words with a charactor after Ctrl+X until the charactor
24 {
$line.SubString(0, $line.Length-2) -match &quot;(^(.*$($line[-1]))([^$($line[-1])]*)`$)|(^[^\$($line[-1])]*`$)&quot; | Out-Null
$_clip = new-object System.Windows.Forms.TextBox;
$_clip.Multiline = $true;
$_clip.Text = $Matches[3]
$_clip.SelectAll()
$_clip.Copy()
[System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
$line = $Matches[2] -replace '([[\]\(\)+{}?~%])','{$1}'
[System.Windows.Forms.SendKeys]::SendWait($line)
break;
}
}


switch -regex ($lastWord)
{
# Handle property and method expansion at '$_'
'(^.*)(\$_\.)(\w*)$' {
$_base = $matches[1]
$_expression = '$global:_dummy'
$_pat = $matches[3] + '*'
$global:_dummy = $null
Get-PipeLineObject
if ( $global:_dummy -eq $null )
{
if ( $global:_exp -match '^\$.*\(.*$' )
{
$type = ( iex $global:_exp.Split(&quot;(&quot;)[0] ).OverloadDefinitions[0].Split(&quot; &quot;)[0] -replace '\[[^\[\]]*\]$' -as [type]

if ( $_expression -match '^\$global:_dummy' )
{
$temp = $_expression -replace '^\$global:_dummy(.*)','$1'
$_expression = '$_' + $temp
}

foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
{
if ($_m.MemberType -eq &quot;Method&quot;)
{
$_base + $_expression + '.' + $_m.name + '('
}
else {
$_base + $_expression + '.' + $_m.name
}
}
break;
}
elseif ( $global:_exp -match '^\[.*\:\:.*\(.*$' )
{
$tname, $mname = $_exp.Split(&quot;:(&quot;, &quot;RemoveEmptyEntries&quot;-as [System.StringSplitOptions])[0,1]
$type = @(iex ($tname + '.GetMember(&quot;' + $mname + '&quot;)'))[0].ReturnType.FullName -replace '\[[^\[\]]*\]$' -as [type]

if ( $_expression -match '^\$global:_dummy' )
{
$temp = $_expression -replace '^\$global:_dummy(.*)','$1'
$_expression = '$_' + $temp
}

foreach ( $_m in $type.GetMembers() | sort membertype,name | group name | ? { $_.Name -like $_pat } | % { $_.Group[0] } )
{
if ($_m.MemberType -eq &quot;Method&quot;)
{
$_base + $_expression + '.' + $_m.name + '('
}
else {
$_base + $_expression + '.' + $_m.name
}
}
break;
}
elseif ( $global:_exp -match '^(\$\w+(\[[0-9,\.]+\])*(\.\w+(\[[0-9,\.]+\])*)*)$' )
{
$global:_dummy = @(iex $Matches[1])[0]
}
else
{
$global:_dummy =  $global:_mix
}
}

Write-Members
break;
}

# Handle property and method expansion rooted at variables...
# e.g. $a.b.&lt;tab&gt;
'(^.*)(\$(\w|\.)+)\.(\w*)$' {
$_base = $matches[1]
$_expression = $matches[2]
$_pat = $matches[4] + '*'
[void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
if ( $_expression -match '^\$_\.' )
{
$_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
}
Write-Members
break;
}

# Handle simple property and method expansion on static members...
# e.g. [datetime]::n&lt;tab&gt;
'(^.*)(\[(\w|\.)+\])\:\:(\w*)$' {
$_base = $matches[1]
$_expression = $matches[2]
$_pat = $matches[4] + '*'
Write-Members '::'
break;
}

# Handle complex property and method expansion on static members
# where there are intermediate properties...
# e.g. [datetime]::now.d&lt;tab&gt;
'(^.*)(\[(\w|\.)+\]\:\:(\w+\.)+)(\w*)$' {
$_base = $matches[1]  # everything before the expression
$_expression = $matches[2].TrimEnd('.') # expression less trailing '.'
$_pat = $matches[5] + '*'  # the member to look for...
Write-Members
break;
}

# Handle variable name expansion...
'(^.*\$)(\w+)$' {
$_prefix = $matches[1]
$_varName = $matches[2]
foreach ($_v in Get-ChildItem ('variable:' + $_varName + '*'))
{
$_prefix + $_v.name
}
break;
}

# Handle env&amp;function drives variable name expansion...
'(^.*\$)(.*\:)(\w+)$' {
$_prefix = $matches[1]
$_drive = $matches[2]
$_varName = $matches[3]
if ($_drive -eq &quot;env:&quot; -or $_drive -eq &quot;function:&quot;)
{
foreach ($_v in Get-ChildItem ($_drive + $_varName + '*'))
{
$_prefix + $_drive + $_v.name
}
}
break;
}

# Handle array's element property and method expansion
# where there are intermediate properties...
# e.g. foo[0].n.b&lt;tab&gt;
'(^.*)(\$((\w+\.)|(\w+(\[(\w|,)+\])+\.))+)(\w*)$'
{
$_base = $matches[1]
$_expression = $matches[2].TrimEnd('.')
$_pat = $Matches[8] + '*'
[void] ( iex &quot;$_expression.IsDataLanguageOnly&quot; ) # for [ScriptBlock]
if ( $_expression -match '^\$_\.' )
{
$_expression = $_expression -replace '^\$_(.*)',('$global:_dummy' + '$1')
}
Write-Members
break;
}

# Handle property and method expansion rooted at type object...
# e.g. [System.Type].a&lt;tab&gt;
'(^\[(\w|\.)+\])\.(\w*)$'
{
if ( $(iex $Matches[1]) -isnot [System.Type] ) { break; }
$_expression = $Matches[1]
$_pat = $Matches[$matches.Count-1] + '*'
Write-Members
break;
}

# Handle complex property and method expansion on type object members
# where there are intermediate properties...
# e.g. [datetime].Assembly.a&lt;tab&gt;
'^(\[(\w|\.)+\]\.(\w+\.)+)(\w*)$' {
$_expression = $matches[1].TrimEnd('.') # expression less trailing '.'
$_pat = $matches[4] + '*'  # the member to look for...
if ( $(iex $_expression) -eq $null ) { break; }
Write-Members
break;
}

# Handle property and method expansion rooted at close parenthes...
# e.g. (123).a&lt;tab&gt;
'^(.*)\)((\w|\.)*)\.(\w*)$' {
$_base = $Matches[1] + &quot;)&quot;
if ( $matches[3] -eq $null) { $_expression = '[System.Type]' }
else { $_expression = '[System.Type]' + $Matches[2] }
$_pat = $matches[4] + '*'
iex &quot;$_expression | Get-Member $_pat | sort MemberType,Name&quot; |
% {
if ( $_.MemberType -like &quot;*Method*&quot; -or $_.MemberType -like &quot;*Parameterized*&quot; ) { $parenthes = &quot;(&quot; }
if ( $Matches[2] -eq &quot;&quot; ) { $_base + &quot;.&quot; + $_.Name + $parenthes }
else { $_base + $Matches[2] + &quot;.&quot; + $_.Name + $parenthes }
}
break;
}

# Handle .NET type name expansion ...
# e.g. [Microsoft.PowerShell.Com&lt;tab&gt;
'^\[(\w+(\.\w*)*)$' {
$_opt = $matches[1] + '*'
if ( $_opt -eq &quot;*&quot; )
{
$_TypeAccelerators -like $_opt -replace '^(.*)$', '[$1]'
}
else
{
$_TypeAccelerators -like $_opt -replace '^(.*)$', '[$1]'
&quot;CmdletBinding&quot;, &quot;Parameter&quot;, &quot;Alias&quot;,
&quot;ValidateArguments&quot;, &quot;ValidateCount&quot;, &quot;ValidateEnumeratedArguments&quot;, &quot;ValidateLength&quot;,
&quot;ValidateNotNull&quot;, &quot;ValidateNotNullOrEmpty&quot;, &quot;ValidatePattern&quot;, &quot;ValidateRange&quot;,
&quot;ValidateScript&quot;, &quot;ValidateSet&quot;, &quot;AllowEmptyCollection&quot;, &quot;AllowEmptyString&quot;, &quot;AllowNull&quot; `
-like $_opt -replace '^(.*)$', '[$1('
Write-ClassNames $_TypeNames_System ($_opt.Split(&quot;.&quot;).Count-1) '['
Write-ClassNames $_TypeNames ($_opt.Split(&quot;.&quot;).Count-1) '['
}
break;
}

# Handle file/directory name which contains $env: variable
# e.g.  $env:windir\&lt;tab&gt;
'^\$(env:)?\w+([\\/][^\\/]*)*$' {
$path = iex ('&quot;' + $Matches[0] + '&quot;')
if ( $Matches[2].Length -gt 1 )
{
$parent = Split-Path $path -Parent
$leaf = (Split-Path $path -Leaf) + '*'
}
else
{
$parent = $path
$leaf = '*'
}
if ( Test-Path $parent )
{
$i = $Matches[0].LastIndexOfAny(&quot;/\&quot;)
$_base = $Matches[0].Substring(0,$i+1)
[IO.Directory]::GetFileSystemEntries( $parent, $leaf ) | % { $_base + ($_.Split(&quot;\/&quot;)[-1] -replace '([\$\s&amp;])','`$1' -replace '([[\]])', '````$1') }
}
}

# Handle file glob expansion ...
# e.g. *.txt~about*@&lt;tab&gt;
'^(\^?([^~]+))(~(.*))*@$' {
if ( $Matches[1] -notlike &quot;^*&quot; )
{
$include = $Matches[2] -replace '``','`'
if ( $Matches[3] )
{
$exclude = $Matches[3].Split(&quot;~&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions]) -replace '``','`'
}
}
else
{
$include = &quot;*&quot;
$exclude = $Matches[2] -replace '``','`'
}
$fse = [IO.Directory]::GetFileSystemEntries($PWD)
$fse = $fse -replace '.*[\\/]([^/\\]*)$','$1'
% -in ($fse -like $include) { $fse = $_; $exclude | % { $fse = $fse -notlike $_ } }
$fse = $fse -replace '^.*\s.*$', (&quot;'`$0'&quot;)
$fse = $fse -replace '([\[\]])', '``$1' -replace '^.*([\[\]]).*$', (&quot;'`$0'&quot;)
$fse = $fse -replace &quot;''&quot;, &quot;'&quot;
$OFS = &quot;, &quot;; &quot;$fse&quot;
$OFS = &quot;, &quot;; &quot;* -Filter $include &quot; + $(if($exclude){&quot;-Exclude $exclude&quot;})
$Matches[0].Substring(0, $Matches[0].Length-1)
break;
}

# Handle command buffer stack...
'(.*);(.?)$' {
$_base = $Matches[1]
if ( $Matches[2] -eq &quot;:&quot; -or $Matches[2] -eq &quot;,&quot; )
{
if ( $_cmdstack.Count -gt 0 )
{
$_base + $global:_cmdstack.Pop()
}
else
{
&quot;&quot;; break;
}
}
elseif ( $Matches[2] -eq &quot;&quot; )
{
$global:_cmdstack.Push($line.SubString(0,$line.Length-1))
[System.Windows.Forms.SendKeys]::SendWait(&quot;{ESC}&quot;)
&quot;&quot;; break;
}
}

# Do completion on parameters...
'^-([\w0-9]*)' {
$_pat = $matches[1] + '*'

# extract the command name from the string
# first split the string into statements and pipeline elements
# This doesn't handle strings however.
$_command = [regex]::Split($line, '[|;=]')[-1]

#  Extract the trailing unclosed block e.g. ls | foreach { cp
if ($_command -match '\{([^\{\}]*)$')
{
$_command = $matches[1]
}

# Extract the longest unclosed parenthetical expression...
if ($_command -match '\(([^()]*)$')
{
$_command = $matches[1]
}

# take the first space separated token of the remaining string
# as the command to look up. Trim any leading or trailing spaces
# so you don't get leading empty elements.
$_command = $_command.Trim().Split()[0]

# now get the info object for it...
$_command = @(Get-Command -type 'All' $_command)[0]

# loop resolving aliases...
while ($_command.CommandType -eq 'alias')
{
$_command = @(Get-Command -type 'All' $_command.Definition)[0]
}

if ( $_command.name -eq &quot;powershell.exe&quot; )
{
if ( $global:_PSexeOption )
{
$global:_PSexeOption -like &quot;-$_pat&quot; -replace '^(-[^,]+).*$', '$1' | sort
}
else
{
($global:_PSexeOption = powershell.exe -?) -like &quot;-$_pat&quot; -replace '^(-[^,]+).*$', '$1' | sort
}
break;
}


if ( $_command -ne $null )
{
# expand the parameter sets and emit the matching elements
foreach ($_n in $_command.Parameters.Keys | sort)
{
if ($_n -like $_pat) { '-' + $_n }
}
}
elseif ( $line -match 'switch\s+(-\w+\s+)*-(\w*)$')
{
$_pat = $Matches[2] + '*'
&quot;regex&quot;, &quot;wildcard&quot;, &quot;exact&quot;, &quot;casesensitive&quot;, &quot;file&quot; -like $_pat -replace '^(.*)$', '-$1'
break;
}
else
{
&quot;-and&quot;, &quot;-as&quot;, &quot;-band&quot;, &quot;-bnot&quot;, &quot;-bor&quot;, &quot;-bxor&quot;, &quot;-ccontains&quot;, &quot;-ceq&quot;, &quot;-cge&quot;, &quot;-cgt&quot;, &quot;-cle&quot;, &quot;-clike&quot;, &quot;-clt&quot;,
&quot;-cmatch&quot;, &quot;-cne&quot;, &quot;-cnotcontains&quot;, &quot;-cnotlike&quot;, &quot;-cnotmatch&quot;, &quot;-contains&quot;, &quot;-creplace&quot;, &quot;-csplit&quot;, &quot;-eq&quot;, &quot;-f&quot;, &quot;-ge&quot;,
&quot;-gt&quot;, &quot;-icontains&quot;, &quot;-ieq&quot;, &quot;-ige&quot;, &quot;-igt&quot;, &quot;-ile&quot;, &quot;-ilike&quot;, &quot;-ilt&quot;, &quot;-imatch&quot;, &quot;-ine&quot;, &quot;-inotcontains&quot;, &quot;-inotlike&quot;,
&quot;-inotmatch&quot;, &quot;-ireplace&quot;, &quot;-is&quot;, &quot;-isnot&quot;, &quot;-isplit&quot;, &quot;-join&quot;, &quot;-le&quot;, &quot;-like&quot;, &quot;-lt&quot;, &quot;-match&quot;, &quot;-ne&quot;, &quot;-not&quot;, &quot;-notcontains&quot;, 
&quot;-notlike&quot;, &quot;-notmatch&quot;, &quot;-or&quot;, &quot;-replace&quot;, &quot;-split&quot;, &quot;-xor&quot; -like &quot;-$_pat&quot;
}
break;
}

# Tab complete against history either #&lt;pattern&gt; or #&lt;id&gt;
'^#(\w*)' {
$_pattern = $matches[1]
if ($_pattern -match '^[0-9]+$')
{
Get-History -ea SilentlyContinue -Id $_pattern | Foreach { $_.CommandLine } 
}
else
{
$_pattern = '*' + $_pattern + '*'
Get-History | Sort-Object -Descending Id| Foreach { $_.CommandLine } | where { $_ -like $_pattern }
}
break;
}

# try to find a matching command...
default {

# parse the script...
$_tokens = [System.Management.Automation.PSParser]::Tokenize($line, [ref] $null)

if ( $_tokens )
{
$_lastToken = $_tokens[$_tokens.count - 1]
if ($_lastToken.Type -eq 'Member')
{
$_pat = $_lastToken.Content + '*'
$i=$_tokens.count; do { $i-- } until ( $_tokens[$i].Type -eq &quot;Attribute&quot;)
if ( $lastWord -match &quot;^(.*)([\(,])\w*$&quot; )
{
$_base = $matches[1] + $matches[2]
}
switch ( $_tokens[$i].Content )
{
'Parameter' {
[System.Management.Automation.ParameterAttribute].GetProperties() | ? { $_.Name -like $_pat -and $_.Name -ne &quot;TypeId&quot; } | % { $_base + $_.Name + &quot;=&quot; }
}
'CmdletBinding' {
[System.Management.Automation.CmdletBindingAttribute].GetProperties() | ? { $_.Name -like $_pat -and $_.Name -ne &quot;TypeId&quot; } | % { $_base + $_.Name + &quot;=&quot; }
}
}
break;
}

if ( $_tokens[1].Type -eq &quot;Attribute&quot;)
{
if ( $line.Split(&quot;(&quot;).Count -gt $line.Split(&quot;)&quot;).Count )
{
if ( $lastWord -match &quot;^(.*)([\(,])\w*$&quot; )
{
$_base = $matches[1] + $matches[2]
}
switch ( $_tokens[1].Content )
{
'Parameter' {
[System.Management.Automation.ParameterAttribute].GetProperties() | % { $_base + $_.Name + &quot;=&quot; }
}
'CmdletBinding' {
[System.Management.Automation.CmdletBindingAttribute].GetProperties()  | % { $_base + $_.Name + &quot;=&quot; }
}
}
}
break;
}
}


$lastex =  [regex]::Split($line, '[|;]')[-1]
if ( $lastex -match '^\s*(\$\w+(\[[0-9,]+\])*(\.\w+(\[[0-9,]+\])*)*)\s*=\s+((&quot;\w+&quot;\s*,\s+)*)&quot;\w+&quot;\s*-as\s+$' )
{
if ( $Matches[6] -ne $nul )
{
$brackets = &quot;[]&quot;
}
'['+ $global:_enum + $brackets + ']'
break;
}


if ( $lastex -match '^\s*(\$\w+(\[[0-9,]+\])*(\.\w+(\[[0-9,]+\])*)*)\s*=\s+((&quot;\w+&quot;\s*,\s+)*)\s*(\w*)$' )
{
$_pat = $Matches[7] + '*'

$_type = @(iex $Matches[1])[0].GetType()
if ( $_type.IsEnum )
{
$global:_enum = $_type.FullName
[Enum]::GetValues($_type) -like $_pat -replace '^(.*)$','&quot;$1&quot;'
break;
}
}

$lastex =  [regex]::Split($line, '[|;=]')[-1]
if ($lastex  -match '[[$].*\w+\(.*-as\s*$')
{
'['+ $global:_enum + ']'
}
elseif ( $lastex -match '([[$].*(\w+))\((.*)$' )
{
$_method = $Matches[1]

if ( $Matches[3] -match &quot;(.*)((`&quot;|')(\w+,)+(\w*))$&quot; )
{
$continuous = $true
$_opt =  $Matches[5] + '*'
$_base =  $Matches[2].TrimStart('&quot;') -replace '(.*,)\w+$','$1'
$position = $Matches[1].Split(&quot;,&quot;).Length
}
else
{
$continuous = $false
$_opt = ($Matches[3].Split(',')[-1] -replace '^\s*','') + &quot;*&quot;
$position = $Matches[3].Split(&quot;,&quot;).Length
}

if ( ($_mdefs = iex ($_method + &quot;.OverloadDefinitions&quot;)) -eq $null )
{
$tname, $mname = $_method.Split(&quot;:&quot;, &quot;RemoveEmptyEntries&quot; -as [System.StringSplitOptions])
$_mdefs = iex ($tname + '.GetMember(&quot;' + $mname + '&quot;) | % { $_.ToString() }')
}

foreach ( $def in $_mdefs )
{
[void] ($def -match '\((.*)\)')
foreach ( $param in [regex]::Split($Matches[1], ', ')[$position-1] )
{
if ($param -eq $null -or $param -eq &quot;&quot;)
{
continue;
}
$type = $param.split()[0]

if ( $type -like '*`[*' -or $type -eq &quot;Params&quot; -or $type -eq &quot;&quot; )
{
continue;
}
$fullname  = @($_typenames -like &quot;*$type*&quot;)
foreach ( $name in $fullname )
{
if ( $continuous -eq $true -and ( $name  -as [System.Type] ).IsEnum )
{
$output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$',($_base + '$1')
$output | sort
}
elseif ( ( $name  -as [System.Type] ).IsEnum ) 
{
$global:_enum = $name
$output = [Enum]::GetValues($name) -like $_opt -replace '^(.*)$','&quot;$1&quot;'
$output | sort
}
}
}
}
if ( $output -ne $null )
{
break;
}
}

if ( $line -match '(function|filter)\s+(\w*)$')
{
$_pat = 'function:\' + $Matches[2] + '*'
Get-ChildItem $_pat| % { $_.Name }
break;
}


if ( $line[-1] -eq &quot; &quot; )
{
$_cmdlet = $line.TrimEnd(&quot; &quot;).Split(&quot; |(;={&quot;)[-1]

$_cmdlet = @(Get-Command -type 'cmdlet,alias,function' $_cmdlet)[0]

while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'cmdlet,alias,function' $_cmdlet.Definition)[0]
}

if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
{
&quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; | sort
break;
}

if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
{
Get-TraceSource | % { $_.Name } | sort -Unique
break;
}

if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
{
$_TypeAccelerators
break;
}

if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
{
$_WMIClasses
break;
}

if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
{
Get-Process | % { $_.Name } | sort
break;
}

if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
{
if ( $global:_snapin -ne $null )
{
$global:_snapin
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin
break;
}
}

if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; )
{
Get-PSDrive | sort
break;
}

if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
{
Get-EventLog -List | % { $_base + ($_.Log -replace '\s','` ') }
break;
}

if ( &quot;Get-Help&quot; -eq $_cmdlet.Name -or &quot;help&quot; -eq $_cmdlet.Name )
{
Get-Help -Category all | % { $_.Name } | sort -Unique
break;
}

if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
&quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
-contains $_cmdlet.Name )
{
Get-Service | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
{
Get-Command -CommandType All | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
&quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
-contains $_cmdlet.Name )
{
Get-PipeLineObject
$_dummy | gm -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Clear-Variable&quot;, &quot;Get-Variable&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Variable&quot; -contains $_cmdlet.Name )
{
Get-Variable -Scope Global | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Alias&quot;, &quot;New-Alias&quot;, &quot;Set-Alias&quot; -contains $_cmdlet.Name )
{
Get-Alias | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}
}


if ( $line[-1] -eq &quot; &quot; )
{
$_cmdlet = [regex]::Split($line, '[|;=]')[-1]

if ($_cmdlet -match '\{([^\{\}]*)$')
{
$_cmdlet = $matches[1]
}

if ($_cmdlet -match '\(([^()]*)$')
{
$_cmdlet = $matches[1]
}

$_cmdlet = $_cmdlet.Trim().Split()[0]

$_cmdlet = @(Get-Command -type 'Application' $_cmdlet)[0]

if ( $_cmdlet.Name -eq &quot;powershell.exe&quot; )
{
&quot;-PSConsoleFile&quot;, &quot;-Version&quot;, &quot;-NoLogo&quot;, &quot;-NoExit&quot;, &quot;-Sta&quot;, &quot;-NoProfile&quot;, &quot;-NonInteractive&quot;,
&quot;-InputFormat&quot;, &quot;-OutputFormat&quot;, &quot;-EncodedCommand&quot;, &quot;-File&quot;, &quot;-Command&quot; | sort
break;
}
if ( $_cmdlet.Name -eq &quot;fsutil.exe&quot; )
{
&quot;behavior query&quot;, &quot;behavior set&quot;, &quot;dirty query&quot;, &quot;dirty set&quot;, 
&quot;file findbysid&quot;, &quot;file queryallocranges&quot;, &quot;file setshortname&quot;, &quot;file setvaliddata&quot;, &quot;file setzerodata&quot;, &quot;file createnew&quot;, 
&quot;fsinfo drives&quot;, &quot;fsinfo drivetype&quot;, &quot;fsinfo volumeinfo&quot;, &quot;fsinfo ntfsinfo&quot;, &quot;fsinfo statistics&quot;, 
&quot;hardlink create&quot;, &quot;objectid query&quot;, &quot;objectid set&quot;, &quot;objectid delete&quot;, &quot;objectid create&quot;,
&quot;quota disable&quot;, &quot;quota track&quot;, &quot;quota enforce&quot;, &quot;quota violations&quot;, &quot;quota modify&quot;, &quot;quota query&quot;,
&quot;reparsepoint query&quot;, &quot;reparsepoint delete&quot;, &quot;sparse setflag&quot;, &quot;sparse queryflag&quot;, &quot;sparse queryrange&quot;, &quot;sparse setrange&quot;,
&quot;usn createjournal&quot;, &quot;usn deletejournal&quot;, &quot;usn enumdata&quot;, &quot;usn queryjournal&quot;, &quot;usn readdata&quot;, &quot;volume dismount&quot;, &quot;volume diskfree&quot; | sort
break;
}
if ( $_cmdlet.Name -eq &quot;net.exe&quot; )
{
&quot;ACCOUNTS &quot;, &quot; COMPUTER &quot;, &quot; CONFIG &quot;, &quot; CONTINUE &quot;, &quot; FILE &quot;, &quot; GROUP &quot;, &quot; HELP &quot;, 
&quot;HELPMSG &quot;, &quot; LOCALGROUP &quot;, &quot; NAME &quot;, &quot; PAUSE &quot;, &quot; PRINT &quot;, &quot; SEND &quot;, &quot; SESSION &quot;, 
&quot;SHARE &quot;, &quot; START &quot;, &quot; STATISTICS &quot;, &quot; STOP &quot;, &quot; TIME &quot;, &quot; USE &quot;, &quot; USER &quot;, &quot; VIEW&quot; | sort
break;
}
if ( $_cmdlet.Name -eq &quot;ipconfig.exe&quot; )
{
&quot;/?&quot;, &quot;/all&quot;, &quot;/renew&quot;, &quot;/release&quot;, &quot;/flushdns&quot;, &quot;/displaydns&quot;,
&quot;/registerdns&quot;, &quot;/showclassid&quot;, &quot;/setclassid&quot;
break;
}
}

if ( $line -match '\w+\s+(\w+(\.|[^\s\.])*)$' )
{
$_cmdlet = $line.TrimEnd(&quot; &quot;).Split(&quot; |(;={&quot;)[-2]

$_opt = $Matches[1].Split(&quot; ,&quot;)[-1] + '*'
$_base = $Matches[1].Substring(0,$Matches[1].Length-$Matches[1].Split(&quot; ,&quot;)[-1].length)

$_cmdlet = @(Get-Command -type 'cmdlet,alias,function' $_cmdlet)[0]

while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'cmdlet,alias,function' $_cmdlet.Definition)[0]
}

if ( &quot;Set-ExecutionPolicy&quot; -eq $_cmdlet.Name )
{
&quot;Unrestricted&quot;, &quot;RemoteSigned&quot;, &quot;AllSigned&quot;, &quot;Restricted&quot;, &quot;Default&quot; -like $_opt | sort
break;
}

if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name )
{
Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;New-Object&quot; -eq $_cmdlet.Name )
{
$_TypeAccelerators -like $_opt
Write-ClassNames $_TypeNames_System ($_opt.Split(&quot;.&quot;).Count-1)
Write-ClassNames $_TypeNames ($_opt.Split(&quot;.&quot;).Count-1)
break;
}

if ( $_cmdlet.Name -like &quot;*WMI*&quot; )
{
Write-ClassNames $_WMIClasses ($_opt.Split(&quot;_&quot;).Count-1) -sep '_'
break;
}

if ( &quot;Get-Process&quot; -eq $_cmdlet.Name )
{
Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; -contains $_cmdlet.Name )
{
if ( $global:_snapin -ne $null )
{
$global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
break;
}
}

if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; )
{
Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-PSProvider&quot; -eq $_cmdlet.Name )
{
Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}


if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name )
{
Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
break;
}

if ( &quot;Get-Help&quot; -eq $_cmdlet.Name -or &quot;help&quot; -eq $_cmdlet.Name )
{
Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
break;
}

if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
&quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
-contains $_cmdlet.Name )
{
Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name )
{
Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
&quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
-contains $_cmdlet.Name )
{

Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Clear-Variable&quot;, &quot;Get-Variable&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Variable&quot; -contains $_cmdlet.Name )
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Alias&quot;, &quot;New-Alias&quot;, &quot;Set-Alias&quot; -contains $_cmdlet.Name )
{
Get-Alias -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}
}

if ( $line -match '(-(\w+))\s+([^-]*$)' )
{

$_param = $matches[2] + '*'
$_opt = $Matches[3].Split(&quot; ,&quot;)[-1] + '*'
$_base = $Matches[3].Substring(0,$Matches[3].Length-$Matches[3].Split(&quot; ,&quot;)[-1].length)

$_cmdlet = [regex]::Split($line, '[|;=]')[-1]

if ($_cmdlet -match '\{([^\{\}]*)$')
{
$_cmdlet = $matches[1]
}

if ($_cmdlet -match '\(([^()]*)$')
{
$_cmdlet = $matches[1]
}

$_cmdlet = $_cmdlet.Trim().Split()[0]

$_cmdlet = @(Get-Command -type 'Cmdlet,Alias,Function,Filter,ExternalScript' $_cmdlet)[0]

while ($_cmdlet.CommandType -eq 'alias')
{
$_cmdlet = @(Get-Command -type 'Cmdlet,Alias,Function,Filter,ExternalScript' $_cmdlet.Definition)[0]
}

if ( $_param.TrimEnd(&quot;*&quot;) -eq &quot;ea&quot; -or $_param.TrimEnd(&quot;*&quot;) -eq &quot;wa&quot; )
{
&quot;SilentlyContinue&quot;, &quot;Stop&quot;, &quot;Continue&quot;, &quot;Inquire&quot; |
? { $_ -like $_opt } | sort -Unique
break;
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot; -contains $_cmdlet.Name `
-and &quot;groupBy&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_.Name }
break;
}

if ( $_param.TrimEnd(&quot;*&quot;) -eq &quot;ev&quot; -or $_param.TrimEnd(&quot;*&quot;) -eq &quot;ov&quot; -or
&quot;ErrorVariable&quot; -like $_param -or &quot;OutVariable&quot; -like $_param)
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort
break;
}

if ( &quot;Tee-Object&quot; -eq $_cmdlet.Name -and &quot;Variable&quot; -like $_param )
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort
break;
}

if ( &quot;Clear-Variable&quot;, &quot;Get-Variable&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Variable&quot; -contains $_cmdlet.Name `
-and &quot;Name&quot; -like $_param)
{
Get-Variable -Scope Global -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Export-Alias&quot;, &quot;Get-Alias&quot;, &quot;New-Alias&quot;, &quot;Set-Alias&quot; -contains $_cmdlet.Name `
-and &quot;Name&quot; -like $_param)
{
Get-Alias -Name $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Out-File&quot;,&quot;Export-CSV&quot;,&quot;Select-String&quot;,&quot;Export-Clixml&quot; -contains $_cmdlet.Name `
-and &quot;Encoding&quot; -like $_param)
{
&quot;Unicode&quot;,  &quot;UTF7&quot;, &quot;UTF8&quot;, &quot;ASCII&quot;, &quot;UTF32&quot;, &quot;BigEndianUnicode&quot;, &quot;Default&quot;, &quot;OEM&quot; |
? { $_ -like $_opt } | sort -Unique
break;
}

if ( &quot;Trace-Command&quot;,&quot;Get-TraceSource&quot;,&quot;Set-TraceSource&quot; -contains $_cmdlet.Name `
-and &quot;Name&quot; -like $_param)
{
Get-TraceSource -Name $_opt | % { $_.Name } | sort -Unique | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;New-Object&quot; -like $_cmdlet.Name )
{
if ( &quot;ComObject&quot; -like $_param )
{
$_ProgID -like $_opt | % { $_ -replace '\s','` ' }
break;
}

if ( &quot;TypeName&quot; -like $_param )
{
if ( $_opt -eq &quot;*&quot; )
{
$_TypeAccelerators -like $_opt
}
else
{
$_TypeAccelerators -like $_opt
Write-ClassNames $_TypeNames_System ($_opt.Split(&quot;.&quot;).Count-1)
Write-ClassNames $_TypeNames ($_opt.Split(&quot;.&quot;).Count-1)
}
break;
}
}

if ( &quot;New-Item&quot; -eq $_cmdlet.Name )
{
if ( &quot;ItemType&quot; -like $_param )
{
&quot;directory&quot;, &quot;file&quot; -like $_opt
break;
}
}

if ( &quot;Get-Location&quot;, &quot;Get-PSDrive&quot;, &quot;Get-PSProvider&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name `
-and &quot;PSProvider&quot; -like $_param )
{
Get-PSProvider -PSProvider $_opt | % { $_.Name } | sort  | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Location&quot; -eq $_cmdlet.Name -and &quot;PSDrive&quot; -like $_param )
{
Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-PSDrive&quot;, &quot;New-PSDrive&quot;, &quot;Remove-PSDrive&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
Get-PSDrive -Name $_opt | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and  &quot;PSSnapin&quot; -like $_param)
{
if ( $global:_snapin -ne $null )
{
$global:_snapin -like $_opt  | % { $_base + $_ }
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin -like $_opt  | % { $_base + ($_ -replace '\s','` ') }
break;
}
}

if ( &quot;Add-PSSnapin&quot;, &quot;Get-PSSnapin&quot;, &quot;Remove-PSSnapin&quot; `
-contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
if ( $global:_snapin -ne $null )
{
$global:_snapin -like $_opt | % { $_base + ($_ -replace '\s','` ') }
break;
}
else
{
$global:_snapin = $(Get-PSSnapIn -Registered;Get-PSSnapIn)| sort Name -Unique;
$global:_snapin -like $_opt | % { $_base + $_ }
break;
}
}

if ( &quot;Clear-Variable&quot;, &quot;Export-Alias&quot;, &quot;Get-Alias&quot;, &quot;Get-PSDrive&quot;, &quot;Get-Variable&quot;, &quot;Import-Alias&quot;,
&quot;New-Alias&quot;, &quot;New-PSDrive&quot;, &quot;New-Variable&quot;, &quot;Remove-Variable&quot;, &quot;Set-Alias&quot;, &quot;Set-Variable&quot; `
-contains $_cmdlet.Name -and &quot;Scope&quot; -like $_param )
{
&quot;Global&quot;, &quot;Local&quot;, &quot;Script&quot; -like $_opt
break;
}

if ( &quot;Get-Process&quot;, &quot;Stop-Process&quot;, &quot;Wait-Process&quot; -contains $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
Get-Process $_opt | % { $_.Name } | sort | % { $_base + ($_ -replace '\s','` ') }
break;
}

if ( &quot;Get-Eventlog&quot; -eq $_cmdlet.Name -and &quot;LogName&quot; -like $_param )
{
Get-EventLog -List | ? { $_.Log -like $_opt } | % { $_base + ($_.Log -replace '\s','` ') }
break;
}

if ( &quot;Get-Help&quot; -eq $_cmdlet.Name -or &quot;help&quot; -eq $_cmdlet.Name )
{
if ( &quot;Name&quot; -like $_param )
{
Get-Help -Category all -Name $_opt | % { $_.Name } | sort -Unique
break;
}
if ( &quot;Category&quot; -like $_param )
{
&quot;Alias&quot;, &quot;Cmdlet&quot;, &quot;Provider&quot;, &quot;General&quot;, &quot;FAQ&quot;,
&quot;Glossary&quot;, &quot;HelpFile&quot;, &quot;All&quot; -like $_opt | sort | % { $_base + $_ }
break;
}
}

if ( &quot;Get-Service&quot;, &quot;Restart-Service&quot;, &quot;Resume-Service&quot;,
&quot;Start-Service&quot;, &quot;Stop-Service&quot;, &quot;Suspend-Service&quot; `
-contains $_cmdlet.Name )
{
if ( &quot;Name&quot; -like $_param )
{
Get-Service -Name $_opt | sort Name  | % { $_base + ($_.Name -replace '\s','` ') }
break;
}
if ( &quot;DisplayName&quot; -like $_param )
{
Get-Service -Name $_opt | sort DisplayName | % { $_base + ($_.DisplayName -replace '\s','` ') }
break;
}
}

if ( &quot;New-Service&quot; -eq $_cmdlet.Name -and &quot;dependsOn&quot; -like $_param )
{
Get-Service -Name $_opt | sort Name | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Get-EventLog&quot; -eq $_cmdlet.Name -and &quot;EntryType&quot; -like $_param )
{
&quot;Error&quot;, &quot;Information&quot;, &quot;FailureAudit&quot;, &quot;SuccessAudit&quot;, &quot;Warning&quot; -like $_opt | sort | % { $_base + $_ }
break;
}

if ( &quot;Get-Command&quot; -eq $_cmdlet.Name -and &quot;Name&quot; -like $_param )
{
Get-Command -CommandType All -Name $_opt | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( $_cmdlet.Noun -like &quot;*WMI*&quot; )
{
if ( &quot;Class&quot; -like $_param )
{
Write-ClassNames $_WMIClasses ($_opt.Split(&quot;_&quot;).Count-1) -sep '_'
break;
}
}

if ( &quot;Format-List&quot;, &quot;Format-Custom&quot;, &quot;Format-Table&quot;, &quot;Format-Wide&quot;, &quot;Compare-Object&quot;,
&quot;ConvertTo-Html&quot;, &quot;Measure-Object&quot;, &quot;Select-Object&quot;, &quot;Group-Object&quot;, &quot;Sort-Object&quot; `
-contains $_cmdlet.Name -and &quot;Property&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;Select-Object&quot; -eq $_cmdlet.Name )
{
if ( &quot;ExcludeProperty&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_base + ($_.Name -replace '\s','` ') }
break;
}

if ( &quot;ExpandProperty&quot; -like $_param )
{
Get-PipeLineObject
$_dummy | Get-Member -Name $_opt -MemberType Properties,ParameterizedProperty | sort membertype | % { $_.Name }
break;
}
}

select -InputObject $_cmdlet -ExpandProperty ParameterSets | select -ExpandProperty Parameters |
? { $_.Name -like $_param } | ? { $_.ParameterType.IsEnum } |
% { [Enum]::GetNames($_.ParameterType) } | ? { $_ -like $_opt } | sort -Unique | % { $_base + $_ }

}

if ($_tokens)
{
$_lastToken = $_tokens[$_tokens.count - 1]
if ($_lastToken.Type -eq 'Command')
{
$_cmd = $_lastToken.Content

# don't look for paths...
if ($_cmd.IndexOfAny('/\') -eq -1)
{
# handle parsing errors - the last token string should be the last
# string in the line...
if ($lastword.substring($lastword.length-$_cmd.length) -eq $_cmd)
{
$_pat = $_cmd + '*'
$_base = $lastword.substring(0, $lastword.length-$_cmd.length)
&quot;begin {&quot;, &quot;break&quot;, &quot;catch {&quot;, &quot;continue&quot;, &quot;data {&quot;, &quot;do {&quot;, &quot;dynamicparam (&quot;, &quot;else {&quot;, &quot;elseif (&quot;,
&quot;end {&quot;, &quot;exit&quot;, &quot;filter &quot;, &quot;finally {&quot;, &quot;for (&quot;, &quot;foreach &quot;, &quot;from&quot;, &quot;function &quot;, &quot;if (&quot;, &quot;in &quot;,
&quot;param (&quot;, &quot;process {&quot;, &quot;return&quot;, &quot;switch &quot;, &quot;throw &quot;, &quot;trap &quot;, &quot;try {&quot;, &quot;until (&quot;, &quot;while (&quot; `
-like $_pat | %  {'{0}{1}' -f $_base,$_ }
$ExecutionContext.InvokeCommand.GetCommandName($_pat,$true, $false) |
Sort-Object -Unique | ForEach-Object {'{0}{1}' -f $_base,$_ }
}
}
}
}
}
}
}
}

</code></pre>

</div>

    <footer class="blog-footer">
        <p>&copy; Joel &quot;Jaykul&quot; Bennett 2018</p>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
        crossorigin="anonymous"></script>
    <script src="/js/main.js"></script>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-59988721-1', 'auto');
      ga('send', 'pageview');

      $(function () {
          $('#contentTabs a:first').tab('show')
      })

    </script>
</body>
</html>